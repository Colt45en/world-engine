<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS Holy Beat System - 3D Sacred Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(circle at center, #0a0a1e 0%, #000 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00ffff;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            min-width: 300px;
            backdrop-filter: blur(5px);
        }

        .status-section {
            margin-bottom: 15px;
        }

        .status-title {
            color: #00ffaa;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .status-value {
            color: #ffffff;
            font-size: 12px;
            margin-left: 10px;
        }

        .connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        .connected {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #00ff00;
        }

        .disconnected {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff0000;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(5px);
        }

        .control-group {
            margin-bottom: 10px;
        }

        .control-group label {
            display: block;
            color: #00ffaa;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .control-group input {
            width: 150px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #ffffff;
            padding: 3px 6px;
            border-radius: 3px;
        }

        .control-group button {
            background: rgba(0, 255, 170, 0.2);
            border: 1px solid #00ffaa;
            color: #00ffaa;
            padding: 5px 12px;
            border-radius: 3px;
            cursor: pointer;
            margin: 2px;
        }

        .control-group button:hover {
            background: rgba(0, 255, 170, 0.4);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div class="status-section">
            <div class="status-title">üåÄ Quantum State</div>
            <div class="status-value">Mode: <span id="quantum-mode">0</span></div>
            <div class="status-value">BPM: <span id="bpm">120</span></div>
            <div class="status-value">Amplitude: <span id="amplitude">0.0</span></div>
        </div>

        <div class="status-section">
            <div class="status-title">üé® Sacred Geometry</div>
            <div class="status-value">Petals: <span id="petals">8</span></div>
            <div class="status-value">Harmonics: <span id="harmonics">4</span></div>
            <div class="status-value">Spiral Phase: <span id="spiral-phase">0.0</span></div>
        </div>

        <div class="status-section">
            <div class="status-title">üåê System Metrics</div>
            <div class="status-value">FPS: <span id="fps">60</span></div>
            <div class="status-value">Entities: <span id="entities">0</span></div>
            <div class="status-value">Memory: <span id="memory">0MB</span></div>
        </div>
    </div>

    <div class="connection-status" id="connection-status">
        Connecting...
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Visualization Mode:</label>
            <button onclick="setVisualizationMode('sacred')">Sacred Geometry</button>
            <button onclick="setVisualizationMode('quantum')">Quantum Field</button>
            <button onclick="setVisualizationMode('harmonic')">Harmonic Waves</button>
        </div>

        <div class="control-group">
            <label>Camera Mode:</label>
            <button onclick="setCameraMode('orbit')">Orbit</button>
            <button onclick="setCameraMode('spiral')">Sacred Spiral</button>
            <button onclick="setCameraMode('free')">Free Fly</button>
        </div>

        <div class="control-group">
            <label>Audio Sensitivity:</label>
            <input type="range" id="audio-sensitivity" min="0.1" max="3.0" step="0.1" value="1.0" onchange="updateAudioSensitivity(this.value)">
            <span id="sensitivity-value">1.0</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class NexusHolyBeat3DVisualization {
            constructor() {
                // Three.js components
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;

                // Visualization objects
                this.sacredGeometry = [];
                this.quantumParticles = [];
                this.harmonicWaves = [];
                this.crystalFormations = [];
                this.energyFields = [];

                // Animation state
                this.time = 0;
                this.audioData = {
                    amplitude: 0,
                    frequency: 440,
                    bpm: 120,
                    quantumMode: 0
                };

                // Settings
                this.visualizationMode = 'sacred';
                this.cameraMode = 'orbit';
                this.audioSensitivity = 1.0;

                // WebSocket connection
                this.websocket = null;
                this.connected = false;

                // Performance tracking
                this.frameCount = 0;
                this.lastFPSUpdate = performance.now();
            }

            initialize() {
                console.log('üéµ‚ú® Initializing NEXUS Holy Beat 3D Visualization ‚ú®üéµ');

                // Setup Three.js
                this.setupThreeJS();

                // Create visualization objects
                this.createSacredGeometry();
                this.createQuantumField();
                this.createHarmonicWaves();
                this.createCrystalFormations();
                this.createEnergyFields();

                // Setup WebSocket
                this.connectWebSocket();

                // Start animation loop
                this.animate();

                console.log('‚úÖ 3D Visualization initialized');
            }

            setupThreeJS() {
                const container = document.getElementById('canvas-container');

                // Scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000000, 10, 1000);

                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.camera.position.set(0, 50, 100);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0x00ffff, 1);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                // Resize handler
                window.addEventListener('resize', () => this.onWindowResize());
            }

            createSacredGeometry() {
                console.log('üî∫ Creating sacred geometry structures...');

                // Central Sacred Flower of Life pattern
                const flowerGroup = new THREE.Group();
                const petalCount = 12;
                const radius = 30;

                for (let i = 0; i < petalCount; i++) {
                    const angle = (i / petalCount) * Math.PI * 2;

                    // Petal geometry
                    const petalGeometry = new THREE.TorusGeometry(8, 2, 8, 16);
                    const petalMaterial = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL((i / petalCount) * 0.8, 0.8, 0.6),
                        transparent: true,
                        opacity: 0.7,
                        emissive: new THREE.Color().setHSL((i / petalCount) * 0.8, 0.5, 0.2)
                    });

                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    petal.position.x = Math.cos(angle) * radius;
                    petal.position.y = Math.sin(angle) * radius;
                    petal.position.z = Math.sin(angle * 3) * 5;
                    petal.rotation.z = angle;

                    flowerGroup.add(petal);
                }

                this.scene.add(flowerGroup);
                this.sacredGeometry.push(flowerGroup);

                // Sacred spiral towers
                for (let tower = 0; tower < 8; tower++) {
                    const towerAngle = (tower / 8) * Math.PI * 2;
                    const towerRadius = 80;

                    const spiralGroup = new THREE.Group();
                    spiralGroup.position.x = Math.cos(towerAngle) * towerRadius;
                    spiralGroup.position.z = Math.sin(towerAngle) * towerRadius;

                    // Create spiral of cubes
                    for (let level = 0; level < 20; level++) {
                        const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
                        const cubeMaterial = new THREE.MeshPhongMaterial({
                            color: new THREE.Color().setHSL((level / 20) * 0.6 + 0.3, 0.9, 0.7),
                            emissive: new THREE.Color().setHSL((level / 20) * 0.6 + 0.3, 0.5, 0.1)
                        });

                        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

                        const spiralAngle = level * 0.618; // Golden ratio
                        const spiralRadius = 5 + level * 0.5;

                        cube.position.x = Math.cos(spiralAngle) * spiralRadius;
                        cube.position.z = Math.sin(spiralAngle) * spiralRadius;
                        cube.position.y = level * 2;

                        cube.rotation.y = spiralAngle;

                        spiralGroup.add(cube);
                    }

                    this.scene.add(spiralGroup);
                    this.sacredGeometry.push(spiralGroup);
                }
            }

            createQuantumField() {
                console.log('‚öõÔ∏è Creating quantum particle field...');

                const particleCount = 2000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);

                for (let i = 0; i < particleCount; i++) {
                    // Random spherical distribution
                    const radius = Math.random() * 200 + 50;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = 2 * Math.PI * Math.random();

                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);

                    const color = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.8, 0.6);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;

                    sizes[i] = Math.random() * 2 + 1;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        amplitude: { value: 0 }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        varying vec3 vColor;
                        uniform float time;
                        uniform float amplitude;

                        void main() {
                            vColor = color;

                            vec3 pos = position;

                            // Quantum fluctuations
                            float noise = sin(pos.x * 0.01 + time * 2.0) * cos(pos.y * 0.01 + time * 1.5) * sin(pos.z * 0.01 + time * 1.8);
                            pos += normalize(pos) * noise * amplitude * 10.0;

                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z) * (1.0 + amplitude * 2.0);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;

                        void main() {
                            float r = distance(gl_PointCoord, vec2(0.5));
                            if (r > 0.5) discard;

                            float alpha = 1.0 - smoothstep(0.2, 0.5, r);
                            gl_FragColor = vec4(vColor, alpha);
                        }
                    `,
                    transparent: true,
                    vertexColors: true
                });

                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.quantumParticles.push(particles);
            }

            createHarmonicWaves() {
                console.log('üåä Creating harmonic wave structures...');

                // Create wave rings
                for (let ring = 0; ring < 5; ring++) {
                    const radius = 40 + ring * 20;
                    const segments = 64;

                    const geometry = new THREE.RingGeometry(radius - 2, radius + 2, segments);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(ring * 0.15, 0.8, 0.5),
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });

                    const wave = new THREE.Mesh(geometry, material);
                    wave.rotation.x = -Math.PI / 2;
                    wave.position.y = -20 + ring * 2;

                    this.scene.add(wave);
                    this.harmonicWaves.push(wave);
                }
            }

            createCrystalFormations() {
                console.log('üíé Creating crystal formations...');

                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const radius = 150;

                    // Octahedron crystal
                    const geometry = new THREE.OctahedronGeometry(8, 2);
                    const material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL((i / 12) * 0.8 + 0.1, 0.9, 0.6),
                        transparent: true,
                        opacity: 0.8,
                        emissive: new THREE.Color().setHSL((i / 12) * 0.8 + 0.1, 0.5, 0.2),
                        shininess: 100
                    });

                    const crystal = new THREE.Mesh(geometry, material);
                    crystal.position.x = Math.cos(angle) * radius;
                    crystal.position.z = Math.sin(angle) * radius;
                    crystal.position.y = Math.sin(angle * 3) * 20;

                    crystal.rotation.x = Math.random() * Math.PI;
                    crystal.rotation.y = Math.random() * Math.PI;
                    crystal.rotation.z = Math.random() * Math.PI;

                    this.scene.add(crystal);
                    this.crystalFormations.push(crystal);
                }
            }

            createEnergyFields() {
                console.log('‚ö° Creating energy field visualizations...');

                // Central energy sphere
                const sphereGeometry = new THREE.SphereGeometry(30, 32, 32);
                const sphereMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        amplitude: { value: 0 },
                        quantumMode: { value: 0 }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float amplitude;
                        varying vec3 vPosition;
                        varying vec3 vNormal;

                        void main() {
                            vPosition = position;
                            vNormal = normal;

                            vec3 pos = position;

                            // Pulsing effect
                            float pulse = sin(time * 2.0 + length(pos) * 0.1) * amplitude * 5.0;
                            pos += normal * pulse;

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float amplitude;
                        uniform float quantumMode;
                        varying vec3 vPosition;
                        varying vec3 vNormal;

                        void main() {
                            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 2.0);

                            vec3 color = vec3(0.0, 0.8, 1.0);

                            // Quantum mode color shifts
                            if (quantumMode > 0.0) {
                                color = mix(color, vec3(1.0, 0.3, 0.8), quantumMode * 0.125);
                            }

                            float alpha = fresnel * (0.3 + amplitude * 0.7);
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                const energySphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                this.scene.add(energySphere);
                this.energyFields.push(energySphere);
            }

            connectWebSocket() {
                console.log('üåê Connecting to NEXUS WebSocket bridge...');

                this.websocket = new WebSocket('ws://localhost:8080');

                this.websocket.onopen = () => {
                    console.log('‚úÖ Connected to NEXUS Holy Beat System');
                    this.connected = true;
                    this.updateConnectionStatus();
                };

                this.websocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.processNexusData(data);
                    } catch (e) {
                        console.warn('Invalid WebSocket message:', event.data);
                    }
                };

                this.websocket.onclose = () => {
                    console.log('‚ùå Disconnected from NEXUS Holy Beat System');
                    this.connected = false;
                    this.updateConnectionStatus();

                    // Attempt reconnection after 3 seconds
                    setTimeout(() => this.connectWebSocket(), 3000);
                };

                this.websocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }

            processNexusData(data) {
                if (data.type === 'audio') {
                    this.audioData.amplitude = data.amplitude || 0;
                    this.audioData.frequency = data.frequency || 440;
                    this.updateUIElement('amplitude', this.audioData.amplitude.toFixed(2));
                }

                if (data.type === 'visual') {
                    if (data.bpm) {
                        this.audioData.bpm = data.bpm;
                        this.updateUIElement('bpm', Math.round(data.bpm));
                    }

                    if (data.quantumMode !== undefined) {
                        this.audioData.quantumMode = data.quantumMode;
                        this.updateUIElement('quantum-mode', data.quantumMode);
                    }

                    if (data.petals) {
                        this.updateUIElement('petals', data.petals);
                    }

                    if (data.harmonics) {
                        this.updateUIElement('harmonics', data.harmonics);
                    }
                }

                if (data.type === 'system') {
                    if (data.fps) {
                        this.updateUIElement('fps', Math.round(data.fps));
                    }

                    if (data.entities) {
                        this.updateUIElement('entities', data.entities);
                    }

                    if (data.memory) {
                        this.updateUIElement('memory', Math.round(data.memory) + 'MB');
                    }
                }
            }

            updateConnectionStatus() {
                const statusElement = document.getElementById('connection-status');
                if (this.connected) {
                    statusElement.textContent = 'Connected to NEXUS';
                    statusElement.className = 'connection-status connected';
                } else {
                    statusElement.textContent = 'Disconnected';
                    statusElement.className = 'connection-status disconnected';
                }
            }

            updateUIElement(id, value) {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.time += 0.016; // Approximate 60fps delta
                this.frameCount++;

                this.updateVisualizations();
                this.updateCamera();
                this.updateUI();

                this.renderer.render(this.scene, this.camera);
            }

            updateVisualizations() {
                const amplitude = this.audioData.amplitude * this.audioSensitivity;
                const bpmPhase = (this.time * this.audioData.bpm / 60) * Math.PI * 2;
                const quantumPhase = this.audioData.quantumMode * 0.125;

                // Update sacred geometry
                this.sacredGeometry.forEach((group, index) => {
                    if (index === 0) { // Central flower
                        group.rotation.y = this.time * 0.2;
                        group.rotation.z = Math.sin(bpmPhase) * 0.1;
                        group.scale.setScalar(1.0 + amplitude * 0.3);
                    } else { // Spiral towers
                        group.rotation.y = this.time * 0.1 + index * 0.5;
                        group.children.forEach((cube, cubeIndex) => {
                            const phase = bpmPhase + cubeIndex * 0.2;
                            cube.material.emissive.setHSL((cubeIndex / 20) * 0.6 + 0.3 + quantumPhase, 0.5, 0.1 + amplitude * 0.3);
                        });
                    }
                });

                // Update quantum particles
                this.quantumParticles.forEach(particles => {
                    particles.material.uniforms.time.value = this.time;
                    particles.material.uniforms.amplitude.value = amplitude;
                    particles.rotation.y = this.time * 0.05;
                });

                // Update harmonic waves
                this.harmonicWaves.forEach((wave, index) => {
                    const wavePhase = bpmPhase + index * 0.3;
                    wave.scale.setScalar(1.0 + Math.sin(wavePhase) * amplitude * 0.5);
                    wave.material.opacity = 0.3 + amplitude * 0.4;
                    wave.rotation.z = this.time * 0.1;
                });

                // Update crystals
                this.crystalFormations.forEach((crystal, index) => {
                    crystal.rotation.x += 0.01;
                    crystal.rotation.y += 0.015;
                    crystal.rotation.z += 0.008;

                    const pulse = 1.0 + Math.sin(bpmPhase + index * 0.5) * amplitude * 0.3;
                    crystal.scale.setScalar(pulse);

                    crystal.material.emissive.setHSL((index / 12) * 0.8 + 0.1 + quantumPhase, 0.5, 0.2 + amplitude * 0.3);
                });

                // Update energy fields
                this.energyFields.forEach(field => {
                    field.material.uniforms.time.value = this.time;
                    field.material.uniforms.amplitude.value = amplitude;
                    field.material.uniforms.quantumMode.value = this.audioData.quantumMode;
                    field.rotation.y = this.time * 0.3;
                    field.rotation.x = Math.sin(this.time * 0.2) * 0.1;
                });
            }

            updateCamera() {
                if (this.cameraMode === 'orbit') {
                    const radius = 150;
                    this.camera.position.x = Math.cos(this.time * 0.1) * radius;
                    this.camera.position.z = Math.sin(this.time * 0.1) * radius;
                    this.camera.position.y = 50 + Math.sin(this.time * 0.05) * 30;
                    this.camera.lookAt(0, 0, 0);
                } else if (this.cameraMode === 'spiral') {
                    const goldenAngle = this.time * 0.1 * 2.399; // Golden angle
                    const radius = 120 + Math.sin(this.time * 0.03) * 50;

                    this.camera.position.x = Math.cos(goldenAngle) * radius;
                    this.camera.position.z = Math.sin(goldenAngle) * radius;
                    this.camera.position.y = 30 + Math.sin(this.time * 0.08) * 40;
                    this.camera.lookAt(0, 10, 0);
                }

                // Audio-reactive camera shake
                const shake = this.audioData.amplitude * this.audioSensitivity * 2;
                this.camera.position.x += (Math.random() - 0.5) * shake;
                this.camera.position.y += (Math.random() - 0.5) * shake;
                this.camera.position.z += (Math.random() - 0.5) * shake;
            }

            updateUI() {
                // Update FPS counter
                if (performance.now() - this.lastFPSUpdate > 1000) {
                    const fps = this.frameCount / ((performance.now() - this.lastFPSUpdate) / 1000);
                    this.updateUIElement('fps', Math.round(fps));
                    this.frameCount = 0;
                    this.lastFPSUpdate = performance.now();
                }

                // Update spiral phase
                this.updateUIElement('spiral-phase', (this.time % (Math.PI * 2)).toFixed(2));
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Global functions for UI controls
        function setVisualizationMode(mode) {
            console.log('Setting visualization mode:', mode);
            // Implementation depends on specific mode requirements
        }

        function setCameraMode(mode) {
            if (window.nexusViz) {
                window.nexusViz.cameraMode = mode;
                console.log('Camera mode set to:', mode);
            }
        }

        function updateAudioSensitivity(value) {
            if (window.nexusViz) {
                window.nexusViz.audioSensitivity = parseFloat(value);
                document.getElementById('sensitivity-value').textContent = value;
            }
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            window.nexusViz = new NexusHolyBeat3DVisualization();
            window.nexusViz.initialize();
        });

        console.log('üéµ‚ú® NEXUS Holy Beat 3D Visualization Ready ‚ú®üéµ');
    </script>
</body>
</html>
