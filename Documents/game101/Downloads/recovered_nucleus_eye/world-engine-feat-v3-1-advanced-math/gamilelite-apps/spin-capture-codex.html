<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spin Capture Codex ‚Äî 360¬∞ GLB to PNG Frames</title>
    <style>
        :root {
            --bg: #0a0f17;
            --ink: #e9f0ff;
            --muted: #9fb0d1;
            --line: rgba(170,220,255,.25);
            --accent: #3b82f6;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: var(--bg); 
            color: var(--ink); 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            padding: 2rem;
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--line);
            border-radius: 16px;
            padding: 2rem;
        }
        h1 { margin-bottom: 1.5rem; font-size: 1.5rem; }
        .preview { 
            width: 100%; 
            border-radius: 12px; 
            border: 1px solid var(--line);
            background: #000;
            margin-bottom: 1.5rem;
        }
        canvas { display: block; width: 100%; border-radius: 12px; }
        .controls { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .control-group { display: flex; flex-direction: column; gap: 0.75rem; }
        .control { 
            display: flex; 
            align-items: center; 
            gap: 0.75rem;
            font-size: 0.875rem;
        }
        label { min-width: 100px; color: var(--muted); }
        input[type="text"], input[type="number"] {
            flex: 1;
            background: rgba(0,0,0,0.4);
            border: 1px solid var(--line);
            color: var(--ink);
            padding: 0.5rem;
            border-radius: 6px;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            background: var(--line);
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            width: 16px; height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="checkbox"] {
            width: 18px; height: 18px;
            cursor: pointer;
        }
        .value { min-width: 50px; text-align: right; color: var(--muted); }
        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        button:hover:not(:disabled) { 
            background: #60a5fa; 
            transform: translateY(-1px);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .buttons { display: flex; gap: 1rem; flex-wrap: wrap; }
        .section-title {
            font-weight: 600;
            font-size: 0.9rem;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            opacity: 0.9;
        }
        pre {
            background: rgba(0,0,0,0.5);
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 1rem;
            font-size: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
            color: var(--muted);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Spin Capture Codex ‚Äî 360¬∞ GLB ‚Üí PNG Frames ZIP</h1>
        
        <div class="preview">
            <canvas id="canvas"></canvas>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="control">
                    <label>Name</label>
                    <input type="text" id="name" value="spin">
                </div>
                
                <div class="control">
                    <label>Preview Spin</label>
                    <input type="checkbox" id="previewSpin" checked>
                    <label style="min-width: 60px;">Speed</label>
                    <input type="range" id="speed" min="0" max="2" step="0.01" value="0.6">
                    <span class="value" id="speedVal">0.60</span>
                </div>

                <div class="control">
                    <label>Capture Size (px)</label>
                    <input type="range" id="size" min="256" max="2048" step="64" value="768">
                    <span class="value" id="sizeVal">768</span>
                </div>

                <div class="control">
                    <label>Step Degrees</label>
                    <input type="range" id="stepDeg" min="1" max="60" step="1" value="10">
                    <span class="value" id="stepDegVal">10</span>
                </div>

                <div class="control">
                    <label>FPS (metadata)</label>
                    <input type="range" id="fps" min="6" max="60" step="1" value="24">
                    <span class="value" id="fpsVal">24</span>
                </div>
            </div>

            <div class="control-group">
                <div class="section-title">Post-Processing</div>
                
                <div class="control">
                    <label>Exposure</label>
                    <input type="range" id="exposure" min="0.2" max="2" step="0.01" value="1">
                    <span class="value" id="exposureVal">1.00</span>
                </div>

                <div class="section-title">Bloom</div>
                <div class="control">
                    <input type="checkbox" id="bloomEnable" checked>
                    <label style="min-width: 80px;">Strength</label>
                    <input type="range" id="bloomStrength" min="0" max="2.5" step="0.01" value="1">
                    <span class="value" id="bloomStrengthVal">1.00</span>
                </div>
                <div class="control">
                    <label>Threshold</label>
                    <input type="range" id="bloomThreshold" min="0" max="1" step="0.005" value="0.18">
                    <span class="value" id="bloomThresholdVal">0.18</span>
                </div>
                <div class="control">
                    <label>Radius</label>
                    <input type="range" id="bloomRadius" min="0" max="1" step="0.005" value="0.6">
                    <span class="value" id="bloomRadiusVal">0.60</span>
                </div>

                <div class="section-title">Depth of Field</div>
                <div class="control">
                    <input type="checkbox" id="dofEnable">
                    <label style="min-width: 80px;">Focus</label>
                    <input type="range" id="dofFocus" min="0.1" max="10" step="0.01" value="1">
                    <span class="value" id="dofFocusVal">1.00</span>
                </div>
                <div class="control">
                    <label>Aperture</label>
                    <input type="range" id="dofAperture" min="0.00001" max="0.002" step="0.00001" value="0.00015">
                    <span class="value" id="dofApertureVal">0.00015</span>
                </div>
                <div class="control">
                    <label>Max Blur</label>
                    <input type="range" id="dofMaxBlur" min="0" max="0.02" step="0.0005" value="0.01">
                    <span class="value" id="dofMaxBlurVal">0.01</span>
                </div>
            </div>
        </div>

        <div class="buttons">
            <button id="loadBtn">üìÅ Load GLB/GLTF</button>
            <button id="captureBtn" disabled>üé¨ Capture 360¬∞ ‚Üí ZIP</button>
        </div>

        <pre id="log">Ready. Load a GLB/GLTF file to begin.</pre>
    </div>

    <input type="file" id="fileInput" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" style="display:none">

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';

    const $ = (id) => document.getElementById(id);
    const canvas = $('canvas');
    const fileInput = $('fileInput');
    const logEl = $('log');

    let scene, camera, renderer, controls, composer, bloomPass, bokehPass;
    let modelGroup = new THREE.Group();
    let clock = new THREE.Clock();
    let busy = false;

    function log(...lines) {
        logEl.textContent = lines.join('\n');
    }

    // Init THREE.js
    function init() {
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f1420);

        camera = new THREE.PerspectiveCamera(36, 1, 0.01, 200);

        scene.add(new THREE.AmbientLight(0xffffff, 0.25));
        
        const key = new THREE.DirectionalLight(0xffffff, 1.15);
        key.position.set(4, 6, 5);
        key.castShadow = true;
        key.shadow.mapSize.setScalar(1024);
        scene.add(key);

        const fill = new THREE.DirectionalLight(0x88c0ff, 0.5);
        fill.position.set(-4, 3, -3);
        scene.add(fill);

        const rim = new THREE.DirectionalLight(0xff7a7a, 0.35);
        rim.position.set(0, 2, -6);
        scene.add(rim);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 40),
            new THREE.MeshStandardMaterial({ color: 0x1a2332, metalness: 0.05, roughness: 0.95 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1.5;
        ground.receiveShadow = true;
        scene.add(ground);

        const grid = new THREE.GridHelper(40, 40, 0x334455, 0x223344);
        grid.material.transparent = true;
        grid.material.opacity = 0.18;
        grid.position.y = -1.49;
        scene.add(grid);

        scene.add(modelGroup);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 1.0, 0.6, 0.18);
        composer.addPass(bloomPass);

        bokehPass = new BokehPass(scene, camera, { focus: 1.0, aperture: 0.00015, maxblur: 0.01 });
        composer.addPass(bokehPass);

        resize();
        window.addEventListener('resize', resize);
        animate();
    }

    function resize() {
        const w = canvas.parentElement.clientWidth || 800;
        const h = Math.max(320, Math.floor(w * 0.56));
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        composer.setSize(w, h);
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();

        if ($('previewSpin').checked && modelGroup.children.length > 0) {
            const speed = parseFloat($('speed').value);
            modelGroup.rotation.y += (speed * Math.PI / 180) * 60 * dt;
        }

        renderer.toneMappingExposure = parseFloat($('exposure').value);
        
        bloomPass.enabled = $('bloomEnable').checked;
        bloomPass.strength = parseFloat($('bloomStrength').value);
        bloomPass.threshold = parseFloat($('bloomThreshold').value);
        bloomPass.radius = parseFloat($('bloomRadius').value);

        bokehPass.enabled = $('dofEnable').checked;
        bokehPass.uniforms['focus'].value = parseFloat($('dofFocus').value);
        bokehPass.uniforms['aperture'].value = parseFloat($('dofAperture').value);
        bokehPass.uniforms['maxblur'].value = parseFloat($('dofMaxBlur').value);

        controls.update();
        composer.render();
    }

    // UI Updates
    ['speed', 'size', 'stepDeg', 'fps', 'exposure', 'bloomStrength', 'bloomThreshold', 'bloomRadius', 
     'dofFocus', 'dofAperture', 'dofMaxBlur'].forEach(id => {
        const el = $(id);
        const val = $(id + 'Val');
        el.addEventListener('input', () => {
            const v = parseFloat(el.value);
            val.textContent = id === 'dofAperture' ? v.toFixed(5) : v.toFixed(2);
        });
    });

    // Load Model
    $('loadBtn').addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        busy = true;
        $('captureBtn').disabled = true;
        log(`‚ñ∂ Loading ${file.name}...`);

        try {
            const url = URL.createObjectURL(file);
            const loader = new GLTFLoader();
            const gltf = await loader.loadAsync(url);
            URL.revokeObjectURL(url);

            const root = gltf.scene.clone(true);
            
            // Clear old model
            modelGroup.clear();

            // Merge and setup
            const merged = mergeMeshes(root);
            centerAndUnitize(merged, 2);
            const mesh = new THREE.Mesh(
                merged,
                new THREE.MeshStandardMaterial({ color: 0xb7c0d6, metalness: 0.05, roughness: 0.75 })
            );
            mesh.castShadow = mesh.receiveShadow = true;
            modelGroup.add(mesh);

            frameCameraTo(modelGroup);
            log('‚úì Model loaded\n‚úì Ready to capture');
            $('captureBtn').disabled = false;
        } catch (err) {
            log(`‚úó Error: ${err.message}`);
        } finally {
            busy = false;
        }
    });

    // Capture 360
    $('captureBtn').addEventListener('click', async () => {
        if (busy || modelGroup.children.length === 0) return;

        busy = true;
        $('captureBtn').disabled = true;
        $('loadBtn').disabled = true;

        const name = $('name').value || 'spin';
        const size = parseInt($('size').value);
        const stepDeg = parseInt($('stepDeg').value);
        const fps = parseInt($('fps').value);
        const total = Math.max(1, Math.round(360 / stepDeg));

        log(`‚ñ∂ Capturing ${total} frames @ ${size}px\n‚Ä¢ Rendering...`);

        try {
            const prevSize = new THREE.Vector2();
            renderer.getSize(prevSize);
            const prevPixelRatio = renderer.getPixelRatio();
            
            renderer.setPixelRatio(1);
            renderer.setSize(size, size, false);
            composer.setSize(size, size);

            const zip = new JSZip();
            const startY = modelGroup.rotation.y;
            const stepRad = THREE.MathUtils.degToRad(stepDeg);

            for (let i = 0; i < total; i++) {
                modelGroup.rotation.y = startY + stepRad * i;
                
                // Render twice to settle post-processing
                composer.render();
                await new Promise(r => requestAnimationFrame(r));
                composer.render();

                const blob = await new Promise((res, rej) => {
                    canvas.toBlob(b => b ? res(b) : rej(new Error('toBlob failed')), 'image/png');
                });

                zip.file(`frames/${name}_frame_${String(i).padStart(3, '0')}.png`, blob);
                
                if (i % Math.max(1, Math.floor(total / 10)) === 0) {
                    log(`‚ñ∂ Capturing ${total} frames @ ${size}px\n‚Ä¢ ${i}/${total} frames`);
                }
            }

            // Manifest
            const manifest = {
                codex: "spin_capture_codex",
                createdAt: new Date().toISOString(),
                name,
                frames: total,
                stepDeg,
                suggestedFps: fps,
                size,
                camera: {
                    fov: camera.fov,
                    aspect: camera.aspect,
                    near: camera.near,
                    far: camera.far,
                    position: camera.position.toArray(),
                    target: controls.target.toArray()
                }
            };
            zip.file(`${name}_manifest.json`, JSON.stringify(manifest, null, 2));

            log(`‚ñ∂ Generating ZIP...`);
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            
            const a = document.createElement('a');
            a.href = URL.createObjectURL(zipBlob);
            a.download = `${name}_spin.zip`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(a.href), 1500);

            log(`‚úì Complete!\n‚úì Downloaded ${name}_spin.zip\n‚úì ${total} frames @ ${size}x${size}px`);

            // Restore
            renderer.setPixelRatio(prevPixelRatio);
            renderer.setSize(prevSize.x, prevSize.y, false);
            composer.setSize(prevSize.x, prevSize.y);
        } catch (err) {
            log(`‚úó Error: ${err.message}`);
        } finally {
            busy = false;
            $('captureBtn').disabled = false;
            $('loadBtn').disabled = false;
        }
    });

    // Helper Functions
    function mergeMeshes(root) {
        const geos = [];
        root.traverse((o) => {
            if (o.isMesh && o.geometry) {
                const g = o.geometry.clone();
                o.updateWorldMatrix(true, false);
                g.applyMatrix4(o.matrixWorld);
                geos.push(g);
            }
        });

        const pos = [], idx = [];
        let off = 0;
        for (const g of geos) {
            const p = g.getAttribute('position');
            const i = g.index ? g.index.array : [...Array(p.count).keys()];
            for (let k = 0; k < p.count; k++) {
                pos.push(p.getX(k), p.getY(k), p.getZ(k));
            }
            for (let k = 0; k < i.length; k += 3) {
                idx.push(off + i[k], off + i[k+1], off + i[k+2]);
            }
            off += p.count;
        }

        const out = new THREE.BufferGeometry();
        out.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pos), 3));
        out.setIndex(idx);
        out.computeVertexNormals();
        return out;
    }

    function centerAndUnitize(g, targetSize = 2) {
        g.computeBoundingBox();
        const bb = g.boundingBox;
        const center = new THREE.Vector3();
        bb.getCenter(center);
        const size = new THREE.Vector3();
        bb.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z) || 1e-6;
        const scale = targetSize / maxDim;
        
        const p = g.getAttribute('position');
        for (let i = 0; i < p.count; i++) {
            p.setXYZ(
                i,
                (p.getX(i) - center.x) * scale,
                (p.getY(i) - center.y) * scale,
                (p.getZ(i) - center.z) * scale
            );
        }
        p.needsUpdate = true;
        g.computeBoundingSphere();
    }

    function frameCameraTo(group) {
        const box = new THREE.Box3().setFromObject(group);
        const sphere = new THREE.Sphere();
        box.getBoundingSphere(sphere);
        const dist = sphere.radius / Math.tan((camera.fov * Math.PI) / 360) * 1.35;
        camera.position.copy(sphere.center).add(
            new THREE.Vector3(0.3, 0.4, 1).normalize().multiplyScalar(dist)
        );
        camera.near = Math.max(0.01, dist / 100);
        camera.far = dist * 20;
        camera.lookAt(sphere.center);
        camera.updateProjectionMatrix();
        controls.target.copy(sphere.center);
        controls.update();
    }

    init();
    </script>
</body>
</html>
