<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Square–Triangle–Circle IDE (Unified + StudioBridge)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b0f14;--panel:#0f1720;--ink:#e6f1ff;--muted:#9fb0c6;
      --accent:#64ffda;--hot:#ff7a7a;--cool:#7ac8ff;--ok:#64ffb2;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid #1d2937;background:linear-gradient(180deg,#0f1720,#0b121a);}
    .brand{display:flex;align-items:center;gap:10px;font-weight:700;letter-spacing:.3px}
    .brand .dot{width:10px;height:10px;border-radius:50%;background:var(--accent);box-shadow:0 0 10px var(--accent);animation:pulse 2.5s infinite;}
    @keyframes pulse{0%{transform:scale(.95);opacity:.8}50%{transform:scale(1.15);opacity:1}100%{transform:scale(.95);opacity:.8}}
    main{display:grid;grid-template-columns:400px 1fr;grid-template-rows:auto 1fr;min-height:calc(100vh - 48px);}
    .left{border-right:1px solid #17212d;background:var(--panel);display:flex;flex-direction:column;min-height:0}
    .section{padding:10px 12px;border-bottom:1px solid #17212d}
    .section h3{margin:0 0 8px 0;font-size:13px;color:var(--muted);font-weight:600;letter-spacing:.25px;text-transform:uppercase}
    textarea{width:100%;min-height:120px;resize:vertical;background:#0e151e;color:var(--ink);border:1px solid #162231;border-radius:8px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
    .btns{display:flex;gap:8px;margin-top:8px}
    button{background:#121c27;border:1px solid #203042;color:var(--ink);padding:8px 10px;border-radius:8px;cursor:pointer}
    button:hover{border-color:#2f4b64}
    .log{flex:1;overflow:auto;padding:8px 12px;font-family:ui-monospace,monospace}
    .log .line{white-space:pre-wrap;color:var(--muted);margin:2px 0}
    canvas{display:block;width:100%;height:100%;background:#0a1219}
    .viz{position:relative}
    .legend{position:absolute;top:8px;right:8px;background:#0f1720;border:1px solid #1c2a3a;border-radius:10px;padding:8px 10px;color:var(--muted);font-size:12px}
    .legend div{margin:3px 0}
    footer{grid-column:1 / -1;border-top:1px solid #17212d;padding:6px 12px;color:var(--muted);font-size:12px;background:#0b1219}
    code.key{background:#0e151e;border:1px solid #162231;color:#a8b2d1;border-radius:6px;padding:1px 6px}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  </style>
</head>
<body>
  <header>
    <div class="brand"><div class="dot"></div>Square–Triangle–Circle IDE</div>
    <div>hard math • no external APIs • self-scaling</div>
  </header>
  <main>
    <div class="left">
      <div class="section">
        <h3>Input / Code</h3>
        <label for="code" class="sr-only">Code editor input</label>
        <textarea id="code" spellcheck="false">// Try me:
function heatWater(temp){
  if(temp &lt; 30){ return "cold"; }
  else if(temp &lt; 60){ return "warm"; }
  else { return "hot"; }
}
for(let i=0;i&lt;3;i++){ console.log(heatWater(i*40)); }</textarea>
        <div class="btns">
          <button id="ingest">Ingest</button>
          <button id="mine">Mine + Scale</button>
          <button id="clear">Clear</button>
        </div>
      </div>
      <div class="section">
        <h3>Scales</h3>
        <div class="btns">
          <button id="seedPol">Seed Polarity</button>
          <button id="seedTemp">Seed Temperature</button>
          <button id="seedInt">Seed Intensity</button>
        </div>
      </div>
      <div class="section" style="flex:1;min-height:0">
        <h3>Log</h3>
        <div id="log" class="log"></div>
      </div>
    </div>
    <div class="viz">
      <canvas id="canvas"></canvas>
      <div class="legend">
        <div><b>Visual mapping</b></div>
        <div>Radius = intensity ↑</div>
        <div>Hue = polarity (cool→hot)</div>
        <div>Spin = direction</div>
      </div>
    </div>
    <footer>
      Square foundation (sharded storage) • Triangle motion (pattern miner) • Circle rhythm (live viz).
      Keyboard: <code class="key">I</code> ingest, <code class="key">M</code> mine+scale.
    </footer>
  </main>

  <script type="module">
  // ───────────────────────────────────────────────────────────────
  // Upflow Automation — Sharded IndexedDB (inlined, no imports)
  // ───────────────────────────────────────────────────────────────
  function fnv1a32(str){ let h=2166136261; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h*16777619)>>>0;} return h; }

  async function createIDBIndexStorage({dbName='UpflowDB',storeName='lexicon',version=1,preloadKeys=[]}){
    let db=null; const memoryCache=new Map(); const pendingWrites=new Map();
    try{
      db=await new Promise((resolve,reject)=>{
        const req=indexedDB.open(dbName,version);
        req.onerror=()=>reject(req.error);
        req.onsuccess=()=>resolve(req.result);
        req.onupgradeneeded=(e)=>{const d=e.target.result; if(!d.objectStoreNames.contains(storeName)){ d.createObjectStore(storeName); }};
      });
    }catch(err){ console.warn('IndexedDB not available, fallback to localStorage:', err); }
    if(db && preloadKeys.length){
      const tx=db.transaction([storeName],'readonly'); const store=tx.objectStore(storeName);
      await Promise.all(preloadKeys.map(async (key)=>{
        const req=store.get(key);
        const val=await new Promise(res=>{ req.onsuccess=()=>res(req.result); req.onerror=()=>res(null); });
        if(val!==null) memoryCache.set(key,val);
      }));
    }
    const storage={
      get(key){
        if(memoryCache.has(key)) return memoryCache.get(key);
        if(!db){ const s=localStorage.getItem(`${dbName}.${key}`); return s?JSON.parse(s):null; }
        return null; // sync facade; IDB reads are async -> use preload or memory cache
      },
      set(key,value){
        memoryCache.set(key,value);
        if(db){ pendingWrites.set(key,value); setTimeout(()=>this._flushKey(key),0); }
        else { localStorage.setItem(`${dbName}.${key}`, JSON.stringify(value)); }
      },
      delete(key){
        memoryCache.delete(key);
        if(db){ const tx=db.transaction([storeName],'readwrite'); tx.objectStore(storeName).delete(key); }
        else { localStorage.removeItem(`${dbName}.${key}`); }
      },
      async _flushKey(key){
        if(!db || !pendingWrites.has(key)) return;
        const value=pendingWrites.get(key); pendingWrites.delete(key);
        try{ const tx=db.transaction([storeName],'readwrite'); tx.objectStore(storeName).put(value,key); }catch(e){ console.warn('IDB write fail:', e); pendingWrites.set(key,value); }
      },
      async flush(){
        if(!db || !pendingWrites.size) return;
        const writes=[...pendingWrites.entries()]; pendingWrites.clear();
        try{
          const tx=db.transaction([storeName],'readwrite'); const store=tx.objectStore(storeName);
          for(const [k,v] of writes) store.put(v,k);
          await new Promise((res,rej)=>{ tx.oncomplete=res; tx.onerror=()=>rej(tx.error); });
        }catch(e){ console.warn('Batch flush failed:', e); for(const [k,v] of writes) pendingWrites.set(k,v); }
      },
      async close(){ await this.flush(); if(db) db.close(); }
    };
    return storage;
  }

  function buildShardKeys(indexKey, shards) {
    const keys = [];
    for (let i = 0; i < shards; i++) {
      keys.push(`${indexKey}.shard.${i}`);
    }
    keys.push(`${indexKey}.w2s`);
    return keys;
  }

  function defaultAbbrs(word, english=''){
    const abbrs=new Set();
    if(word.length>=3){ abbrs.add(word.slice(0,3).toLowerCase()); if(word.length>3) abbrs.add(word.slice(-3).toLowerCase()); }
    if(english){ const ac=english.split(/\s+/).map(w=>w.charAt(0)).join('').toLowerCase(); if(ac.length>=2) abbrs.add(ac); }
    for(let i=2;i<=Math.min(4,word.length);i++) abbrs.add(word.slice(0,i).toLowerCase());
    return [...abbrs];
  }

  function defaultTokenize(text){
    return text.toLowerCase().split(/[^\w]+/).filter(t=>t.length>2).slice(0,5);
  }

  function createUpflowAutomation({ storage, indexKey='lexi.index', shards=16, morph=null, deriveAbbrs=defaultAbbrs, tokenize=defaultTokenize }){
    if(!storage){ // tiny localStorage fallback (kept minimal)
      const mem=new Map();
      storage = {
        get:(k)=>{
          if (mem.has(k)) return mem.get(k);
          const item = localStorage.getItem(`UpflowDB.${k}`);
          return item ? JSON.parse(item) : null;
        },
        set:(k,v)=>{ mem.set(k,v); localStorage.setItem(`UpflowDB.${k}`, JSON.stringify(v)); },
        delete:(k)=>{ mem.delete(k); localStorage.removeItem(`UpflowDB.${k}`); },
        flush: async()=>{}, close: async()=>{}
      };
    }
    const defaultMorph = (word)=>{
      const prefixes=['re','pre','un','dis','over','under','out','up','down'];
      const suffixes=['ing','ed','er','est','ly','tion','ness','ment','able','ful'];
      let prefix='', root=word.toLowerCase(), suffix='';
      for(const pre of prefixes){ if(root.startsWith(pre) && root.length>pre.length+2){ prefix=pre; root=root.slice(pre.length); break; } }
      for(const suf of suffixes){ if(root.endsWith(suf) && root.length>suf.length+2){ suffix=suf; root=root.slice(0,-suf.length); break; } }
      return {prefix,root,suffix};
    };
    const morphoFn = morph || defaultMorph;

    function getShardForRoot(root){ return fnv1a32(root) % shards; }
    function loadShard(n){ const key=`${indexKey}.shard.${n}`; return storage.get(key) || { byRoot:{}, byPrefix:{}, bySuffix:{}, byAbbrev:{}, words:{} }; }
    function saveShard(n, shard){ storage.set(`${indexKey}.shard.${n}`, shard); }
    function loadW2S(){ return storage.get(`${indexKey}.w2s`) || {}; }
    function saveW2S(w2s){ storage.set(`${indexKey}.w2s`, w2s); }

    function addWord(word, english='', metadata={}){
      const {prefix,root,suffix} = morphoFn(word);
      const abbrs = deriveAbbrs(word, english);
      const shardNum = getShardForRoot(root);
      const shard    = loadShard(shardNum);

      const w2s = loadW2S(); w2s[word]=shardNum; saveW2S(w2s);

      const ensureSet = (obj,key)=>{ if(!obj[key]) obj[key]=[]; }; // store as arrays (serializable)
      ensureSet(shard.byRoot, root); if(!shard.byRoot[root].includes(word)) shard.byRoot[root].push(word);
      if(prefix){ ensureSet(shard.byPrefix,prefix); if(!shard.byPrefix[prefix].includes(word)) shard.byPrefix[prefix].push(word); }
      if(suffix){ ensureSet(shard.bySuffix,suffix); if(!shard.bySuffix[suffix].includes(word)) shard.bySuffix[suffix].push(word); }
      for(const ab of abbrs){ ensureSet(shard.byAbbrev,ab); if(!shard.byAbbrev[ab].includes(word)) shard.byAbbrev[ab].push(word); }

      shard.words[word] = { word, english, root, prefix, suffix, abbrs, metadata, indexed: Date.now() };
      saveShard(shardNum, shard);
      return { word, root, prefix, suffix, abbrs };
    }

    const query = {
      byRoot(root){ const s=loadShard(getShardForRoot(root)); return s.byRoot[root]? [...s.byRoot[root]] : []; },
      byPrefix(prefix){ const res=new Set(); for(let i=0;i<shards;i++){ const s=loadShard(i); if(s.byPrefix[prefix]) s.byPrefix[prefix].forEach(w=>res.add(w)); } return [...res]; },
      bySuffix(suffix){ const res=new Set(); for(let i=0;i<shards;i++){ const s=loadShard(i); if(s.bySuffix[suffix]) s.bySuffix[suffix].forEach(w=>res.add(w)); } return [...res]; },
      byAbbrev(abbr){ const res=new Set(); for(let i=0;i<shards;i++){ const s=loadShard(i); if(s.byAbbrev[abbr]) s.byAbbrev[abbr].forEach(w=>res.add(w)); } return [...res]; },
      getWord(word){
        const w2s=loadW2S(); const n=w2s[word];
        if(n!==undefined){ const s=loadShard(n); return s.words[word]||null; }
        for(let i=0;i<shards;i++){ const s=loadShard(i); if(s.words[word]) return s.words[word]; }
        return null;
      }
    };

    const helper = {
      linkWord(word){
        const r=query.getWord(word); if(!r) return null;
        const {root,prefix,suffix,abbrs}=r;
        return {
          ...r,
          rootLinked:   query.byRoot(root).filter(w=>w!==word),
          prefixLinked: prefix? query.byPrefix(prefix).filter(w=>w!==word): [],
          suffixLinked: suffix? query.bySuffix(suffix).filter(w=>w!==word): [],
          abbrLinked:   abbrs.flatMap(a=> query.byAbbrev(a).filter(w=>w!==word)).slice(0,10)
        };
      },
      linkMany(words){ return words.map(w=>this.linkWord(w)).filter(Boolean); }
    };

    const librarian = {
      verify(){
        let totalWords=0,totalLinks=0;
        for(let i=0;i<shards;i++){
          const s=loadShard(i);
          totalWords += Object.keys(s.words).length;
          for(const set of Object.values(s.byRoot)) totalLinks += set.length;
        }
        return { ok:true, shards, totalWords, totalLinks, avgWordsPerShard: totalWords/shards };
      },
      snapshot(){
        const snap={ shards:[], w2s:loadW2S() };
        for(let i=0;i<shards;i++) snap.shards.push(loadShard(i));
        return snap;
      },
      compact(){
        const snap=this.snapshot(); let totalSize=0;
        for(let i=0;i<snap.shards.length;i++){ saveShard(i, snap.shards[i]); totalSize += JSON.stringify(snap.shards[i]).length; }
        saveW2S(snap.w2s); totalSize += JSON.stringify(snap.w2s).length;
        return { compacted:true, totalSize, shards:snap.shards.length };
      }
    };

    // expose minimal API used by IDE
    return { addWord, query, helper, librarian, tokenize, deriveAbbrs };
  }

  // ───────────────────────────────────────────────────────────────
  // IDE logic (merged) + StudioBridge linking
  // ───────────────────────────────────────────────────────────────
  const SB = window.StudioBridge || null;

  // Storage + Upflow init
  const storage = await createIDBIndexStorage({
    dbName: 'UpflowDB',
    storeName: 'lexicon',
    version: 1,
    preloadKeys: buildShardKeys('lexi.index', 16)
  });

  // Morph stub (root-first indexing for shards)
  function morpho(word){
    const w=String(word||'').toLowerCase();
    const m = w.match(/^([a-z]{0,2})(.*?)(ing|ed|ly|s)?$/) || [];
    return { prefix:m[1]||"", root:(m[2]||w)||w, suffix:m[3]||"" };
  }

  const up = createUpflowAutomation({
    storage,
    morph: morpho,
    deriveAbbrs: defaultAbbrs,
    tokenize: defaultTokenize
  });

  // ──────────────── Triangle: pattern miner ────────────────
  const reMore = /\bmore\s+([a-z-]+)\s+than\s+([a-z-]+)\b/ig;
  const reLess = /\bless\s+([a-z-]+)\s+than\s+([a-z\\-]+)\b/ig;
  const reVery = /\b(very|extremely|slightly|barely)\s+([a-z-]+)\b/ig;

  function analyzePatterns(code){
    const kinds = [];
    if (/for\s*\(|while\s*\(/.test(code)) kinds.push("loop");
    if (/if\s*\(/.test(code)) kinds.push("condition");
    if (/function\s+/.test(code)) kinds.push("function");
    return kinds;
  }

  function mineConstraints(text){
    const out = { intensity: [], temperature: [], polarity: [] };
    for (const m of text.matchAll(reMore)){ const a=m[1].toLowerCase(), b=m[2].toLowerCase(); out.intensity.push([b,a,0.6]); }
    for (const m of text.matchAll(reLess)){ const a=m[1].toLowerCase(), b=m[2].toLowerCase(); out.intensity.push([a,b,0.6]); }
    for (const m of text.matchAll(reVery)){
      const adv=m[1].toLowerCase(), adj=m[2].toLowerCase();
      const mult = {"very":1.4,"extremely":1.8,"slightly":0.7,"barely":0.5}[adv] || 1.0;
      if (mult>1) out.intensity.push([`less-${adj}`, adj, 0.4]);
      else if (mult<1) out.intensity.push([adj, `more-${adj}`, 0.4]);
    }
    return out;
  }

  // ──────────────── Hard-math scale engine (pure JS) ────────────────
  function fitTypeScale({name, anchors, yMin=-1, yMax=1, pairs=[], syn=[], ant=[], steps=1200, lr=0.06, margin=0.2, seedWeight=5.0, lamGraph=1.0, lamL2=1e-4}){
    const vocabSet = new Set(anchors);
    for (const [a,b] of pairs){ vocabSet.add(a); vocabSet.add(b); }
    for (const [u,v] of syn){ vocabSet.add(u); vocabSet.add(v); }
    for (const [u,v] of ant){ vocabSet.add(u); vocabSet.add(v); }
    const V = [...vocabSet]; const idx = Object.fromEntries(V.map((w,i)=>[w,i]));
    const x = new Float32Array(V.length);
    if (anchors.length>1){ anchors.forEach((w,i)=>{ x[idx[w]] = yMin + i*(yMax-yMin)/(anchors.length-1); }); }

    const A = pairs.map(p=>idx[p[0]]).filter(i=>i!==undefined);
    const B = pairs.map(p=>idx[p[1]]).filter(i=>i!==undefined);
    const W = pairs.map(p=>Math.max(0.1, Math.min(2.0, +p[2] || 1.0)));
    const seedPairs = new Set(anchors.slice(0,-1).map((w,i)=>`${anchors[i]}→${anchors[i+1]}`));
    const isSeed = pairs.map(([a,b])=> seedPairs.has(`${a}→${b}`) ? 1.0 : 0.0);

    const Su = syn.map(([u])=>idx[u]).filter(i=>i!==undefined);
    const Sv = syn.map(([,v])=>idx[v]).filter(i=>i!==undefined);
    const Sw = syn.map(([, ,w])=> +w || 1.0);

    const Tu = ant.map(([u])=>idx[u]).filter(i=>i!==undefined);
    const Tv = ant.map(([,v])=>idx[v]).filter(i=>i!==undefined);
    const Tw = ant.map(([, ,w])=> +w || 1.0);

    function stepOnce(){
      const g = new Float32Array(x.length);
      for (let i=0;i<A.length;i++){
        const a=A[i], b=B[i], w=W[i]*(1 + isSeed[i]*(seedWeight-1));
        const diff = x[b]-x[a]; const viol = margin - diff; if (viol>0){ g[a]+= w; g[b]-= w; }
      }
      for (let i=0;i<Su.length;i++){ const u=Su[i], v=Sv[i], w=Sw[i]; const d=x[u]-x[v]; const gg=2*lamGraph*w*d; g[u]+=gg; g[v]-=gg; }
      for (let i=0;i<Tu.length;i++){ const u=Tu[i], v=Tv[i], w=Tw[i]; const d=x[u]+x[v]; const gg=2*lamGraph*w*d; g[u]+=gg; g[v]+=gg; }
      for (let i=0;i<g.length;i++){ g[i]+= 2*lamL2*x[i]; }
      let norm=0;
      for (const element of g) norm+=element*element;
      norm=Math.sqrt(norm);
      const clip=5.0, scale = norm>clip ? (lr*clip/norm) : lr;
      for (let i=0;i<x.length;i++) x[i]-= scale*g[i];
    }
    for (let s=0;s<steps;s++){ stepOnce(); if ((s%97)===0){ for (let i=0;i<x.length;i++){ x[i]+= (Math.random()-0.5)*1e-4; } } }

    const topo = topoOrderFromPairs(pairs);
    if (topo.length>=2){
      const pos=Object.fromEntries(topo.map((w,i)=>[w,i]));
      const keep=V.filter(w=>pos[w]!==undefined); const xs=keep.map(w=>pos[w]); const ys=keep.map(w=>x[idx[w]]);
      const order=xs.map((v,i)=>[v,i]).sort((a,b)=>a[0]-b[0]).map(p=>p[1]);
      const cal=pav1d(xs.map((_,i)=>ys[order[i]]), yMin, yMax);
      for (let k=0;k<order.length;k++){ const w=keep[order[k]]; x[idx[w]]=cal[k]; }
    }
    return Object.fromEntries(V.map((w,i)=>[w, x[i]]));
  }

  function topoOrderFromPairs(pairs){
    const nodes=new Set(); const indeg=new Map(); const adj=new Map();
    for(const [a,b] of pairs){ nodes.add(a); nodes.add(b); }
    nodes.forEach(n=>{indeg.set(n,0); adj.set(n,[]);});
    for(const [a,b] of pairs){ adj.get(a).push(b); indeg.set(b, (indeg.get(b)||0)+1); }
    const q=[]; for(const n of nodes){ if((indeg.get(n)||0)===0) q.push(n); }
    const out=[]; while(q.length){ const u=q.shift(); out.push(u); for(const v of adj.get(u)){ indeg.set(v,indeg.get(v)-1); if(indeg.get(v)===0) q.push(v); } }
    return out;
  }

  function pav1d(y,yMin,yMax){
    const n=y.length; if(n===0) return [];
    const g=y.slice(); const w=new Array(n).fill(1);
    for(let i=0;i<n-1;i++){
      if(g[i]>g[i+1]){
        let j=i;
        while(j>=0 && g[j]>g[j+1]){
          const tot=w[j]+w[j+1]; const avg=(g[j]*w[j]+g[j+1]*w[j+1])/tot;
          g.splice(j,2,avg); w.splice(j,2,tot); j--;
        }
      }
    }
    const out=[]; for(let k=0;k<g.length;k++){ for(let t=0;t<w[k];t++) out.push(g[k]); }
    return out.slice(0,n).map(v=> Math.max(yMin, Math.min(yMax, v)));
  }

  // ──────────────── Scales/Seeds/Constraints ────────────────
  const SEEDS = {
    polarity:   ["terrible","bad","meh","okay","good","great","fantastic"],
    temperature:["freezing","cold","cool","lukewarm","warm","hot","boiling"],
    intensity:  ["faint","slight","moderate","strong","intense","extreme"],
  };
  const PAIRS_SEED = {
    polarity:   [["bad","okay",1],["okay","good",1],["good","great",1]],
    temperature:[["cool","warm",1],["warm","hot",1],["hot","boiling",1]],
    intensity:  [["slight","moderate",1],["moderate","strong",1],["strong","extreme",1]],
  };
  const SYN = [["hot","boiling",1],["cold","freezing",1],["cool","chilly",0.8],["good","great",0.8],["terrible","awful",0.9]];
  const ANT = [["hot","cold",1],["boiling","freezing",1],["good","bad",1],["great","terrible",1]];

  // ──────────────── Circle: viz + UI ────────────────
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const logEl = document.getElementById("log");
  const codeEl = document.getElementById("code");
  const nodes = new Map(); // word -> node
  let width=0, height=0;

  function resize(){ width = canvas.width = canvas.clientWidth; height = canvas.height = canvas.clientHeight; }
  window.addEventListener("resize", resize); resize();

  class Node{
    constructor(word){ this.word=word; this.angle=Math.random()*Math.PI*2; this.radius=120+Math.random()*160; this.size=8; this.spin=0.4; }
    update(dt){ this.angle += this.spin*dt; }
    draw(){
      const vec = JSON.parse(scaleStore.get(this.word)||"{}");
      const pol = +(vec.polarity ?? 0);
      const inten = +(vec.intensity ?? 0);
      const r = 140 + 140 * ((inten+1)/2);
      const x = width/2 + r*Math.cos(this.angle);
      const y = height/2 + r*Math.sin(this.angle);
      const hue = 200 - 200 * ((pol+1)/2);
      ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
      ctx.beginPath(); ctx.arc(x,y,this.size,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#cfe9ff"; ctx.fillText(this.word, x+10, y+4);
    }
  }
  function ensureNode(word){ if(!nodes.has(word)) nodes.set(word,new Node(word)); }
  function log(msg){ const d=document.createElement("div"); d.className="line"; d.textContent=msg; logEl.appendChild(d); logEl.scrollTop=logEl.scrollHeight; }

  // Sidecar for scale vectors
  const SCALE_KEY = "lexi.scale.vectors";
  const scaleStore = new Map(Object.entries(JSON.parse(localStorage.getItem(SCALE_KEY) || "{}")));
  function saveScaleStore(){ localStorage.setItem(SCALE_KEY, JSON.stringify(Object.fromEntries(scaleStore))); }

  // ──────────────── Ingest → Mine → Scale → Persist (+ StudioBridge events)
  function ingest(text){
    const toks = up.tokenize(text);
    for (const t of toks){ up.addWord(t, t); ensureNode(t); }
    const kinds = analyzePatterns(text);
    log("Patterns: "+kinds.join(", "));
    if (SB) SB.sendBus({ type:'lex.ingest', tokens:toks, patterns:kinds, ts:Date.now() });
  }

  function mineAndScale(){
    const txt = codeEl.value;
    const mined = mineConstraints(txt);

    const scalesOut = {};
    for (const scaleName of Object.keys(SEEDS)){
      const anchors = SEEDS[scaleName];
      const pairs = [...(PAIRS_SEED[scaleName]||[]) , ...(mined[scaleName]||[])];
      const scores = fitTypeScale({ name:scaleName, anchors, pairs, syn:SYN, ant:ANT, steps:1400, lr:0.06, margin:0.2, seedWeight:5.0 });
      scalesOut[scaleName] = scores;
    }

    const allWords = new Set(); Object.values(scalesOut).forEach(map=>{ Object.keys(map).forEach(w=>allWords.add(w)); });
    for (const w of allWords){
      const vec = { ...JSON.parse(scaleStore.get(w) || "{}") };
      for (const s of Object.keys(scalesOut)){ const val = scalesOut[s][w]; if (val!=null) vec[s]=val; }
      scaleStore.set(w, JSON.stringify(vec));
    }
    saveScaleStore();
    log(`Scaled ${allWords.size} words.`);
    if (SB) SB.sendBus({ type:'lex.scale', updated: allWords.size, scales: Object.keys(scalesOut), ts: Date.now() });
  }

  // viz animation
  let last=0;
  function frame(ts){
    const dt=(ts-last)/1000; last=ts;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle="#14314a"; ctx.beginPath(); ctx.arc(width/2,height/2,140,0,Math.PI*2); ctx.stroke();
    ctx.strokeStyle="#15435f"; ctx.beginPath(); ctx.arc(width/2,height/2,280,0,Math.PI*2); ctx.stroke();
    ctx.font="12px ui-monospace, monospace";
    for (const n of nodes.values()){ n.update(dt); n.draw(); }
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // UI
  document.getElementById("ingest").onclick = ()=> ingest(codeEl.value);
  document.getElementById("mine").onclick = ()=> { mineAndScale(); };
  document.getElementById("clear").onclick = ()=> { logEl.innerHTML=""; };

  document.getElementById("seedPol").onclick = ()=> seedBump("polarity");
  document.getElementById("seedTemp").onclick = ()=> seedBump("temperature");
  document.getElementById("seedInt").onclick = ()=> seedBump("intensity");

  function seedBump(scale){
    for (const w of SEEDS[scale]) ensureNode(w);
    log(`Seed anchors surfaced for ${scale}.`);
    if (SB) SB.sendBus({ type:'lex.seed', scale, anchors: SEEDS[scale], ts: Date.now() });
  }

  // keyboard: I=ingest, M=mine
  window.addEventListener("keydown",(e)=>{
    if (e.key==='i' || e.key==='I') ingest(codeEl.value);
    if (e.key==='m' || e.key==='M') mineAndScale();
  });

  // boot: ingest the seed text
  ingest(document.getElementById("code").value);
  </script>
</body>
</html>
