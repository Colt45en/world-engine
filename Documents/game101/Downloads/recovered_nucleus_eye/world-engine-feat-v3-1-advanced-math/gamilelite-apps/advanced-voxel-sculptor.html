<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üé® Advanced Voxel Sculptor - Full Integration</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <style>
        .tool-btn {
            padding: 8px 12px;
            margin: 2px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            color: white;
        }
        .tool-btn:hover {
            background: rgba(78,205,196,0.15);
            border-color: #4ecdc4;
            transform: translateY(-1px);
        }
        .tool-btn.active {
            background: rgba(78,205,196,0.25);
            border-color: #4ecdc4;
            color: #4ecdc4;
            font-weight: bold;
        }
        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body class="bg-slate-900 text-white">
    <div class="p-6 max-w-7xl mx-auto">
        <h1 class="text-4xl font-bold mb-2 text-center">üé® Advanced Voxel Sculptor</h1>
        <p class="text-slate-400 mb-6 text-center">Generate ‚Üí Transform ‚Üí Morph ‚Üí Sculpt ‚Üí Export</p>
        
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6 mb-6">
            <!-- Left Panel: Generation -->
            <div class="bg-slate-800 rounded-lg p-4">
                <h2 class="text-xl font-bold mb-4">üì§ 1. Generate</h2>
                <button id="uploadBtn" class="w-full px-4 py-3 bg-blue-500 hover:bg-blue-600 rounded-lg font-bold mb-3">
                    üìÅ Upload Silhouette PNG
                </button>
                
                <div class="space-y-3 text-sm">
                    <div>
                        <label class="block mb-1 font-bold text-cyan-400">üéØ Quick Presets:</label>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="presetBalanced" class="tool-btn">Balanced</button>
                            <button id="presetQuality" class="tool-btn">Quality</button>
                            <button id="presetFast" class="tool-btn">Fast</button>
                            <button id="presetArtistic" class="tool-btn">Artistic</button>
                        </div>
                    </div>
                    
                    <div class="flex items-center justify-between">
                        <span>Voxel Size:</span>
                        <input type="range" id="voxelSize" min="0.05" max="0.3" step="0.01" value="0.10" class="w-24">
                        <span id="voxelSizeVal" class="font-mono text-xs">0.10</span>
                    </div>
                    
                    <div class="flex items-center justify-between">
                        <span>Depth:</span>
                        <input type="range" id="depthFactor" min="0.1" max="0.8" step="0.05" value="0.5" class="w-24">
                        <span id="depthFactorVal" class="font-mono text-xs">0.5</span>
                    </div>
                    
                    <div class="flex items-center justify-between">
                        <span>Max Voxels:</span>
                        <input type="range" id="maxVoxels" min="50000" max="500000" step="50000" value="300000" class="w-24">
                        <span id="maxVoxelsVal" class="font-mono text-xs">300k</span>
                    </div>
                </div>
            </div>

            <!-- Center: Viewport -->
            <div class="lg:col-span-2 bg-slate-800 rounded-lg p-4">
                <h2 class="text-xl font-bold mb-2">üëÅÔ∏è 3D View</h2>
                <div id="previewCanvas" class="w-full h-96 bg-black rounded-lg relative"></div>
                <div class="mt-3 flex gap-2">
                    <button id="resetView" class="tool-btn flex-1">üîÑ Reset View</button>
                    <button id="exportGLB" class="flex-1 px-4 py-2 bg-green-500 hover:bg-green-600 rounded-lg font-bold" disabled>
                        üíæ Export GLB
                    </button>
                </div>
                
                <!-- Transform Mode Selector -->
                <div class="mt-3 p-3 bg-slate-700 rounded-lg">
                    <h3 class="font-bold text-sm mb-2">üîß Transform Mode:</h3>
                    <div class="grid grid-cols-4 gap-2">
                        <button class="tool-btn active" data-transform="translate">Move</button>
                        <button class="tool-btn" data-transform="rotate">Rotate</button>
                        <button class="tool-btn" data-transform="scale">Scale</button>
                        <button class="tool-btn" data-transform="none">Select</button>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Advanced Tools -->
            <div class="bg-slate-800 rounded-lg p-4 space-y-4">
                <div>
                    <h2 class="text-xl font-bold mb-3">üîÑ 2. Morph</h2>
                    
                    <div class="space-y-2 text-sm">
                        <div class="flex items-center justify-between">
                            <span>Amount:</span>
                            <input type="range" id="morphAmount" min="0" max="1" step="0.05" value="0" class="w-24">
                            <span id="morphAmountVal" class="font-mono text-xs">0.00</span>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-2 mt-2">
                        <button class="tool-btn" id="spherifyBtn" disabled>‚ö™ Spherify</button>
                        <button class="tool-btn" id="cubeifyBtn" disabled>üì¶ Cubeify</button>
                        <button class="tool-btn" id="twistBtn" disabled>üåÄ Twist</button>
                        <button class="tool-btn" id="bendBtn" disabled>üåä Bend</button>
                    </div>
                </div>

                <div>
                    <h2 class="text-xl font-bold mb-3">‚úÇÔ∏è 3. Sculpt</h2>
                    
                    <label class="flex items-center gap-2 mb-2">
                        <input type="checkbox" id="sculptMode">
                        <span class="text-sm font-bold">Enable Sculpting</span>
                    </label>
                    
                    <div class="grid grid-cols-2 gap-2 mb-2">
                        <button class="tool-btn sculpt-tool active" data-tool="push">‚¨ÜÔ∏è Push</button>
                        <button class="tool-btn sculpt-tool" data-tool="pull">‚¨áÔ∏è Pull</button>
                        <button class="tool-btn sculpt-tool" data-tool="smooth">‚ú® Smooth</button>
                        <button class="tool-btn sculpt-tool" data-tool="pinch">ü§è Pinch</button>
                    </div>
                    
                    <div class="space-y-2 text-sm">
                        <div class="flex items-center justify-between">
                            <span>Brush:</span>
                            <input type="range" id="brushSize" min="0.1" max="2" step="0.1" value="0.5" class="w-24">
                            <span id="brushSizeVal" class="font-mono text-xs">0.5</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span>Strength:</span>
                            <input type="range" id="sculptStrength" min="0.1" max="2" step="0.1" value="0.8" class="w-24">
                            <span id="sculptStrengthVal" class="font-mono text-xs">0.8</span>
                        </div>
                    </div>
                </div>

                <div>
                    <h2 class="text-xl font-bold mb-3">‚öôÔ∏è Operations</h2>
                    <div class="grid grid-cols-2 gap-2">
                        <button class="tool-btn" id="smoothMeshBtn" disabled>‚ú® Smooth</button>
                        <button class="tool-btn" id="resetToOriginal" disabled>‚Ü©Ô∏è Reset</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="bg-slate-800 rounded-lg p-4">
            <h2 class="text-xl font-bold mb-3">‚ÑπÔ∏è Status</h2>
            <div class="grid grid-cols-2 md:grid-cols-5 gap-4 text-sm">
                <div>
                    <div class="text-slate-400">Voxels:</div>
                    <div id="totalVoxels" class="text-xl font-bold text-green-400">0</div>
                </div>
                <div>
                    <div class="text-slate-400">Mode:</div>
                    <div id="currentMode" class="text-xl font-bold text-cyan-400">Generate</div>
                </div>
                <div>
                    <div class="text-slate-400">Tool:</div>
                    <div id="currentTool" class="text-xl font-bold text-purple-400">None</div>
                </div>
                <div>
                    <div class="text-slate-400">Processing:</div>
                    <div id="processTime" class="text-xl font-bold text-yellow-400">-</div>
                </div>
                <div>
                    <div class="text-slate-400">Status:</div>
                    <div id="statusText" class="text-xl font-bold text-orange-400">Ready</div>
                </div>
            </div>
        </div>

        <!-- Log -->
        <div class="bg-slate-800 rounded-lg p-4 mt-4">
            <h2 class="text-xl font-bold mb-3">üìù Log</h2>
            <div id="logOutput" class="bg-black rounded-lg p-3 font-mono text-xs text-green-400 h-32 overflow-y-auto"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

        let scene, camera, renderer, controls, transformControls;
        let currentMesh = null;
        let currentImageData = null;
        let originalGeometry = null;
        
        // Interaction state
        let currentTransformMode = 'translate';
        let isSculpting = false;
        let sculptTool = 'push';
        let isMouseDown = false;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Logging
        function log(msg) {
            const logDiv = document.getElementById('logOutput');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${time}] ${msg}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(msg);
        }

        // Update UI values
        function updateUIValues() {
            document.getElementById('voxelSizeVal').textContent = document.getElementById('voxelSize').value;
            document.getElementById('depthFactorVal').textContent = document.getElementById('depthFactor').value;
            document.getElementById('maxVoxelsVal').textContent = (document.getElementById('maxVoxels').value / 1000).toFixed(0) + 'k';
            document.getElementById('morphAmountVal').textContent = parseFloat(document.getElementById('morphAmount').value).toFixed(2);
            document.getElementById('brushSizeVal').textContent = document.getElementById('brushSize').value;
            document.getElementById('sculptStrengthVal').textContent = document.getElementById('sculptStrength').value;
        }

        ['voxelSize', 'depthFactor', 'maxVoxels', 'morphAmount', 'brushSize', 'sculptStrength'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateUIValues);
        });

        // Initialize Three.js scene
        function initScene() {
            const container = document.getElementById('previewCanvas');
            const w = container.clientWidth;
            const h = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(50, w / h, 0.1, 1000);
            camera.position.set(5, 5, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(w, h);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Transform controls
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (event) => {
                controls.enabled = !event.value;
            });
            transformControls.addEventListener('objectChange', () => {
                updateStatus('Transforming object');
            });
            scene.add(transformControls);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const fillLight = new THREE.DirectionalLight(0x4ecdc4, 0.3);
            fillLight.position.set(-3, 2, -2);
            scene.add(fillLight);

            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.MeshStandardMaterial({ color: 0x1a2332, roughness: 0.9 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            gridHelper.position.y = -1.99;
            scene.add(gridHelper);

            // Axes
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);

            // Mouse events
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('click', onCanvasClick);

            animate();
            log('üé¨ Scene initialized with full controls');
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (currentMesh && !isSculpting) {
                currentMesh.rotation.y += 0.002;
            }
            renderer.render(scene, camera);
        }

        // Mouse interaction
        function updateMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onMouseDown(event) {
            if (!isSculpting || !currentMesh) return;
            isMouseDown = true;
            updateMousePosition(event);
            applySculpting();
        }

        function onMouseMove(event) {
            updateMousePosition(event);
            if (isMouseDown && isSculpting && currentMesh) {
                applySculpting();
            }
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onCanvasClick(event) {
            if (isSculpting) return;
            updateMousePosition(event);
            raycaster.setFromCamera(mouse, camera);
            
            if (currentMesh) {
                const intersects = raycaster.intersectObject(currentMesh);
                if (intersects.length > 0) {
                    attachTransformControls();
                    log('‚úÖ Mesh selected for transformation');
                }
            }
        }

        // Transform Controls
        function setTransformMode(mode) {
            document.querySelectorAll('[data-transform]').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-transform="${mode}"]`).classList.add('active');
            
            currentTransformMode = mode;
            document.getElementById('currentTool').textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
            
            if (mode === 'none') {
                transformControls.detach();
            } else if (currentMesh) {
                transformControls.setMode(mode);
                transformControls.attach(currentMesh);
            }
            log(`üîß Transform mode: ${mode}`);
        }

        function attachTransformControls() {
            if (currentMesh && currentTransformMode !== 'none') {
                transformControls.setMode(currentTransformMode);
                transformControls.attach(currentMesh);
            }
        }

        document.querySelectorAll('[data-transform]').forEach(btn => {
            btn.addEventListener('click', () => setTransformMode(btn.dataset.transform));
        });

        // Sculpting
        function setSculptTool(tool) {
            document.querySelectorAll('.sculpt-tool').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            sculptTool = tool;
            document.getElementById('currentTool').textContent = tool.charAt(0).toUpperCase() + tool.slice(1);
            log(`‚úÇÔ∏è Sculpt tool: ${tool}`);
        }

        document.querySelectorAll('.sculpt-tool').forEach(btn => {
            btn.addEventListener('click', () => setSculptTool(btn.dataset.tool));
        });

        document.getElementById('sculptMode').addEventListener('change', (e) => {
            isSculpting = e.target.checked;
            document.getElementById('currentMode').textContent = isSculpting ? 'Sculpt' : 'Transform';
            if (isSculpting) {
                transformControls.detach();
                log('‚úÇÔ∏è Sculpting mode enabled');
            } else {
                attachTransformControls();
                log('üîß Transform mode enabled');
            }
        });

        function applySculpting() {
            if (!currentMesh) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentMesh);
            
            if (intersects.length === 0) return;
            
            const { point, face } = intersects[0];
            const geometry = currentMesh.geometry;
            const positions = geometry.attributes.position;
            const brushSize = parseFloat(document.getElementById('brushSize').value);
            const strength = parseFloat(document.getElementById('sculptStrength').value) * 0.01;
            
            const localPoint = currentMesh.worldToLocal(point.clone());
            
            for (let i = 0; i < positions.count; i++) {
                const vertex = new THREE.Vector3();
                vertex.fromBufferAttribute(positions, i);
                
                const distance = vertex.distanceTo(localPoint);
                if (distance < brushSize) {
                    const falloff = 1 - (distance / brushSize);
                    const normal = face ? face.normal.clone() : vertex.clone().normalize();
                    
                    let displacement = 0;
                    switch (sculptTool) {
                        case 'push':
                            displacement = strength * falloff;
                            break;
                        case 'pull':
                            displacement = -strength * falloff;
                            break;
                        case 'smooth':
                            // Simplified smoothing
                            displacement = strength * falloff * 0.5;
                            break;
                        case 'pinch':
                            const toCenter = localPoint.clone().sub(vertex).normalize();
                            vertex.add(toCenter.multiplyScalar(strength * falloff * 0.5));
                            break;
                    }
                    
                    if (sculptTool !== 'pinch') {
                        vertex.add(normal.multiplyScalar(displacement));
                    }
                    
                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
            }
            
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        // Morphing Operations
        function applyMorph(type) {
            if (!currentMesh || !originalGeometry) return;
            
            const geometry = currentMesh.geometry;
            const positions = geometry.attributes.position;
            const origPositions = originalGeometry.attributes.position;
            const morphAmount = parseFloat(document.getElementById('morphAmount').value);
            
            for (let i = 0; i < positions.count; i++) {
                const original = new THREE.Vector3();
                original.fromBufferAttribute(origPositions, i);
                
                let target = original.clone();
                
                switch (type) {
                    case 'spherify':
                        target.normalize().multiplyScalar(0.8);
                        break;
                    case 'cubeify':
                        target.x = Math.sign(target.x) * 0.8;
                        target.y = Math.sign(target.y) * 0.8;
                        target.z = Math.sign(target.z) * 0.8;
                        break;
                    case 'twist':
                        const angle = target.y * Math.PI * 0.5;
                        const x = target.x * Math.cos(angle) - target.z * Math.sin(angle);
                        const z = target.x * Math.sin(angle) + target.z * Math.cos(angle);
                        target.x = x;
                        target.z = z;
                        break;
                    case 'bend':
                        const bendAmount = target.y * 0.3;
                        target.x += Math.sin(bendAmount) * 0.5;
                        break;
                }
                
                const morphed = original.clone().lerp(target, morphAmount);
                positions.setXYZ(i, morphed.x, morphed.y, morphed.z);
            }
            
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
            log(`üîÑ Applied ${type} morph (${(morphAmount * 100).toFixed(0)}%)`);
        }

        document.getElementById('spherifyBtn').addEventListener('click', () => applyMorph('spherify'));
        document.getElementById('cubeifyBtn').addEventListener('click', () => applyMorph('cubeify'));
        document.getElementById('twistBtn').addEventListener('click', () => applyMorph('twist'));
        document.getElementById('bendBtn').addEventListener('click', () => applyMorph('bend'));

        // Smooth mesh operation
        document.getElementById('smoothMeshBtn').addEventListener('click', () => {
            if (!currentMesh) return;
            
            const geometry = currentMesh.geometry;
            const positions = geometry.attributes.position;
            const smoothAmount = 0.1;
            
            const newPositions = new Float32Array(positions.array);
            
            for (let i = 0; i < positions.count; i++) {
                const vertex = new THREE.Vector3().fromBufferAttribute(positions, i);
                let avgPos = new THREE.Vector3();
                let count = 0;
                
                for (let j = 0; j < positions.count; j++) {
                    if (i === j) continue;
                    const other = new THREE.Vector3().fromBufferAttribute(positions, j);
                    if (vertex.distanceTo(other) < 0.3) {
                        avgPos.add(other);
                        count++;
                    }
                }
                
                if (count > 0) {
                    avgPos.divideScalar(count);
                    vertex.lerp(avgPos, smoothAmount);
                }
                
                newPositions[i * 3] = vertex.x;
                newPositions[i * 3 + 1] = vertex.y;
                newPositions[i * 3 + 2] = vertex.z;
            }
            
            positions.array = newPositions;
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
            log('‚ú® Mesh smoothed');
        });

        // Reset to original
        document.getElementById('resetToOriginal').addEventListener('click', () => {
            if (!currentMesh || !originalGeometry) return;
            
            currentMesh.geometry.dispose();
            currentMesh.geometry = originalGeometry.clone();
            log('‚Ü©Ô∏è Reset to original geometry');
        });

        // Image processing functions (same as before)
        function imageToCanvas(img, maxSize = 256) {
            const canvas = document.createElement('canvas');
            let w = img.width, h = img.height;
            const maxDim = Math.max(w, h);
            if (maxDim > maxSize) {
                const scale = maxSize / maxDim;
                w = Math.floor(w * scale);
                h = Math.floor(h * scale);
            }
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);
            return canvas;
        }

        function canvasToGrayscale(canvas) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                const a = data[i + 3];
                const gray = a > 0 ? (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]) : 0;
                data[i] = data[i + 1] = data[i + 2] = gray;
                data[i + 3] = 255;
            }
            ctx.putImageData(imgData, 0, 0);
        }

        function otsuThreshold(canvas) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            const hist = new Array(256).fill(0);

            for (let i = 0; i < data.length; i += 4) {
                hist[data[i]]++;
            }

            const total = canvas.width * canvas.height;
            let sum = 0;
            for (let i = 0; i < 256; i++) sum += i * hist[i];

            let sumB = 0, wB = 0, wF = 0, maxVar = 0, threshold = 0;
            for (let t = 0; t < 256; t++) {
                wB += hist[t];
                if (wB === 0) continue;
                wF = total - wB;
                if (wF === 0) break;

                sumB += t * hist[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const varBetween = wB * wF * (mB - mF) * (mB - mF);

                if (varBetween > maxVar) {
                    maxVar = varBetween;
                    threshold = t;
                }
            }

            return threshold;
        }

        function applyThreshold(canvas, threshold) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;

            for (let i = 0; i < data.length; i += 4) {
                const v = data[i];
                const bin = v >= threshold ? 255 : 0;
                data[i] = data[i + 1] = data[i + 2] = bin;
                data[i + 3] = 255;
            }

            ctx.putImageData(imgData, 0, 0);
        }

        function readMask(canvas) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            const mask = new Uint8Array(canvas.width * canvas.height);
            for (let i = 0, p = 0; i < mask.length; i++, p += 4) {
                mask[i] = data[p];
            }
            return mask;
        }

        // Voxel generation (simplified checkerboard version)
        function createVoxelGeometry(mask, w, h, config) {
            const VOXEL_SIZE = parseFloat(config.voxelSize);
            const depthFactor = parseFloat(config.depthFactor);
            const maxVoxels = parseInt(config.maxVoxels);
            const depth = Math.floor(w * depthFactor);
            
            log(`üßä Creating voxels (size=${VOXEL_SIZE}, depth=${depth})...`);

            const allGeometries = [];
            const cubeGeo = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);
            let voxelCount = 0;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y * w + x;
                    if (mask[idx] === 0) continue;
                    
                    // Checkerboard pattern for efficiency
                    if ((x + y) % 2 !== 0) continue;

                    const voxelDepth = Math.floor(depth * 0.5);

                    for (let z = 0; z < voxelDepth; z++) {
                        const clonedGeo = cubeGeo.clone();
                        clonedGeo.translate(
                            (x - w / 2) * VOXEL_SIZE,
                            (h / 2 - y) * VOXEL_SIZE,
                            (z - voxelDepth / 2) * VOXEL_SIZE
                        );
                        allGeometries.push(clonedGeo);
                        voxelCount++;
                        if (voxelCount >= maxVoxels) break;
                    }
                    if (voxelCount >= maxVoxels) break;
                }
                if (voxelCount >= maxVoxels) break;
            }

            log(`‚úÖ Created ${voxelCount} voxels`);
            document.getElementById('totalVoxels').textContent = voxelCount.toLocaleString();

            // Merge geometries
            const mergedGeometry = new THREE.BufferGeometry();
            const positionArrays = [];
            const normalArrays = [];
            const indexArrays = [];
            let indexOffset = 0;

            for (const geo of allGeometries) {
                const pos = geo.attributes.position.array;
                const norm = geo.attributes.normal.array;
                const idx = geo.index ? geo.index.array : null;

                positionArrays.push(pos);
                normalArrays.push(norm);

                if (idx) {
                    const offsetIdx = new Uint16Array(idx.length);
                    for (let i = 0; i < idx.length; i++) {
                        offsetIdx[i] = idx[i] + indexOffset;
                    }
                    indexArrays.push(offsetIdx);
                }

                indexOffset += pos.length / 3;
            }

            const totalPositions = positionArrays.reduce((sum, arr) => sum + arr.length, 0);
            const totalNormals = normalArrays.reduce((sum, arr) => sum + arr.length, 0);
            const totalIndices = indexArrays.reduce((sum, arr) => sum + arr.length, 0);

            const positionArray = new Float32Array(totalPositions);
            const normalArray = new Float32Array(totalNormals);
            const indexArray = new Uint32Array(totalIndices);

            let posOffset = 0, normOffset = 0, idxOffset = 0;

            for (let i = 0; i < positionArrays.length; i++) {
                positionArray.set(positionArrays[i], posOffset);
                normalArray.set(normalArrays[i], normOffset);
                indexArray.set(indexArrays[i], idxOffset);

                posOffset += positionArrays[i].length;
                normOffset += normalArrays[i].length;
                idxOffset += indexArrays[i].length;
            }

            mergedGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            mergedGeometry.setAttribute('normal', new THREE.BufferAttribute(normalArray, 3));
            mergedGeometry.setIndex(new THREE.BufferAttribute(indexArray, 1));

            return mergedGeometry;
        }

        // Process image
        function processImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    log(`üì∑ Image loaded: ${img.width}√ó${img.height}`);
                    
                    const canvas = imageToCanvas(img, 256);
                    log(`üìê Resized to: ${canvas.width}√ó${canvas.height}`);
                    
                    canvasToGrayscale(canvas);
                    const threshold = otsuThreshold(canvas);
                    applyThreshold(canvas, threshold);
                    
                    const mask = readMask(canvas);
                    currentImageData = { mask, width: canvas.width, height: canvas.height };
                    
                    regenerateModel();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Regenerate model
        function regenerateModel() {
            if (!currentImageData) return;

            log('üî® Generating 3D model...');
            const startTime = performance.now();
            
            const config = {
                voxelSize: document.getElementById('voxelSize').value,
                depthFactor: document.getElementById('depthFactor').value,
                maxVoxels: document.getElementById('maxVoxels').value
            };

            const geometry = createVoxelGeometry(
                currentImageData.mask,
                currentImageData.width,
                currentImageData.height,
                config
            );

            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh.geometry.dispose();
                currentMesh.material.dispose();
            }

            const material = new THREE.MeshStandardMaterial({
                color: 0x3b82f6,
                roughness: 0.7,
                metalness: 0.3,
                flatShading: false
            });

            currentMesh = new THREE.Mesh(geometry, material);
            currentMesh.castShadow = true;
            currentMesh.receiveShadow = true;
            scene.add(currentMesh);

            // Store original geometry for morphing
            originalGeometry = geometry.clone();

            const endTime = performance.now();
            const processingTime = ((endTime - startTime) / 1000).toFixed(2);
            document.getElementById('processTime').textContent = `${processingTime}s`;
            document.getElementById('statusText').textContent = 'Complete';
            
            // Enable all tools
            document.querySelectorAll('.tool-btn[disabled]').forEach(btn => btn.disabled = false);
            document.getElementById('exportGLB').disabled = false;
            
            // Attach transform controls
            attachTransformControls();
            
            log(`‚úÖ Model ready! (${processingTime}s)`);
        }

        // Upload button
        document.getElementById('uploadBtn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/png,image/jpeg';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) processImage(file);
            };
            input.click();
        });

        // Presets
        const presets = {
            balanced: { voxelSize: 0.10, depthFactor: 0.5, maxVoxels: 300000 },
            quality: { voxelSize: 0.08, depthFactor: 0.6, maxVoxels: 400000 },
            fast: { voxelSize: 0.15, depthFactor: 0.4, maxVoxels: 150000 },
            artistic: { voxelSize: 0.12, depthFactor: 0.5, maxVoxels: 250000 }
        };

        function applyPreset(name) {
            const preset = presets[name];
            document.getElementById('voxelSize').value = preset.voxelSize;
            document.getElementById('depthFactor').value = preset.depthFactor;
            document.getElementById('maxVoxels').value = preset.maxVoxels;
            updateUIValues();
            if (currentImageData) regenerateModel();
            log(`üéØ Applied "${name}" preset`);
        }

        document.getElementById('presetBalanced').addEventListener('click', () => applyPreset('balanced'));
        document.getElementById('presetQuality').addEventListener('click', () => applyPreset('quality'));
        document.getElementById('presetFast').addEventListener('click', () => applyPreset('fast'));
        document.getElementById('presetArtistic').addEventListener('click', () => applyPreset('artistic'));

        // Reset view
        document.getElementById('resetView').addEventListener('click', () => {
            camera.position.set(5, 5, 10);
            camera.lookAt(0, 0, 0);
            controls.reset();
            if (currentMesh) {
                currentMesh.rotation.set(0, 0, 0);
            }
            log('üîÑ View reset');
        });

        // Export GLB
        document.getElementById('exportGLB').addEventListener('click', () => {
            if (!currentMesh) return;

            log('üíæ Exporting GLB...');
            const exporter = new GLTFExporter();

            exporter.parse(
                currentMesh,
                (result) => {
                    const blob = new Blob([result], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'advanced_voxel_model.glb';
                    a.click();
                    URL.revokeObjectURL(url);
                    log('‚úÖ GLB exported!');
                },
                (error) => {
                    console.error('Export error:', error);
                    log('‚ùå Export failed!');
                },
                { binary: true }
            );
        });

        // Update status helper
        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }

        // Initialize
        initScene();
        updateUIValues();
        log('üöÄ Advanced Voxel Sculptor ready!');
        log('üí° Upload image ‚Üí Transform ‚Üí Morph ‚Üí Sculpt ‚Üí Export');
    </script>
</body>
</html>
