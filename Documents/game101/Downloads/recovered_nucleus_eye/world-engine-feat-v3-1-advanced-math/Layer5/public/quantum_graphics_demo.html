// ===== NEXUS Quantum Glyph Registry =====
// Advanced mathematical visualization system with audio-reactive parameters
export const glyphs = {
  // === Basic Mathematical Curves ===
  lissajous: {
    label: "Lissajous Curves",
    description: "Classic frequency-ratio patterns",
    category: "parametric",
    draw(ctx, t, {am, fm, amplitude, centroid}) {
      ctx.strokeStyle = `hsla(${200 + fm * 120},100%,${60 + amplitude * 40}%,0.8)`;
      ctx.lineWidth = 2 + amplitude * 3;
      ctx.beginPath();

      const cx = ctx.canvas.width / 2;
      const cy = ctx.canvas.height / 2;
      const scale = 80 + amplitude * 40;

      for (let a = 0; a < Math.PI * 2; a += 0.005) {
        const x = Math.sin((3 + fm) * a + am * 2) * scale;
        const y = Math.sin((2 + am) * a + fm * 3) * scale;

        if (a === 0) ctx.moveTo(cx + x, cy + y);
        else ctx.lineTo(cx + x, cy + y);
      }
      ctx.stroke();
    }
  },

  rose: {
    label: "Rose Curves",
    description: "Frequency-driven petal formations",
    category: "polar",
    draw(ctx, t, {centroid, amplitude, fm}) {
      ctx.strokeStyle = `hsla(${centroid * 360},80%,${70 + amplitude * 30}%,0.7)`;
      ctx.lineWidth = 1.5 + amplitude * 2;
      ctx.beginPath();

      const cx = ctx.canvas.width / 2;
      const cy = ctx.canvas.height / 2;
      const scale = 60 + amplitude * 50;
      const petals = 5 + Math.floor(fm * 8);

      for (let a = 0; a < Math.PI * 2; a += 0.01) {
        const r = scale * Math.cos(petals * a);
        const x = r * Math.cos(a);
        const y = r * Math.sin(a);

        if (a === 0) ctx.moveTo(cx + x, cy + y);
        else ctx.lineTo(cx + x, cy + y);
      }
      ctx.stroke();
    }
  },

  // === Audio-Reactive Patterns ===
  spectralSpiral: {
    label: "Spectral Spiral",
    description: "Amplitude-driven logarithmic spiral",
    category: "audio-reactive",
    draw(ctx, t, {amplitude, centroid, spectrum}) {
      if (!spectrum || spectrum.length === 0) return;

      const cx = ctx.canvas.width / 2;
      const cy = ctx.canvas.height / 2;

      ctx.beginPath();

      for (let i = 0; i < spectrum.length; i += 2) {
        const freq = spectrum[i] / 255;
        const angle = (i / spectrum.length) * Math.PI * 8 + t;
        const radius = 20 + freq * 120;

        const x = cx + radius * Math.cos(angle) * (1 + amplitude);
        const y = cy + radius * Math.sin(angle) * (1 + amplitude);

        ctx.strokeStyle = `hsla(${(i / spectrum.length) * 360 + centroid * 180}, 80%, ${60 + freq * 40}%, 0.6)`;
        ctx.lineWidth = 1 + freq * 3;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
  },

  frequencyOrbit: {
    label: "Frequency Orbit",
    description: "Multiple orbiting frequency bands",
    category: "audio-reactive",
    draw(ctx, t, {amplitude, centroid, spectrum, am, fm}) {
      if (!spectrum || spectrum.length === 0) return;

      const cx = ctx.canvas.width / 2;
      const cy = ctx.canvas.height / 2;
      const bands = 8;
      const bandSize = Math.floor(spectrum.length / bands);

      for (let band = 0; band < bands; band++) {
        let bandEnergy = 0;
        for (let i = 0; i < bandSize; i++) {
          bandEnergy += spectrum[band * bandSize + i] || 0;
        }
        bandEnergy = (bandEnergy / bandSize) / 255;

        const orbitRadius = 40 + band * 20;
        const speed = 0.5 + band * 0.2 + fm;
        const angle = t * speed + band * (Math.PI / 4);

        const x = cx + orbitRadius * Math.cos(angle) * (1 + bandEnergy * 2);
        const y = cy + orbitRadius * Math.sin(angle) * (1 + bandEnergy * 2);

        ctx.fillStyle = `hsla(${band * 45 + centroid * 120}, 80%, ${60 + bandEnergy * 40}%, 0.8)`;
        ctx.beginPath();
        ctx.arc(x, y, 3 + bandEnergy * 8, 0, Math.PI * 2);
        ctx.fill();

        // Draw trailing orbit path
        ctx.strokeStyle = `hsla(${band * 45 + centroid * 120}, 60%, 40%, 0.3)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(cx, cy, orbitRadius * (1 + bandEnergy), 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  },

  // === Geometric Fractals ===
  mandelbrot: {
    label: "Mandelbrot Zoom",
    description: "Audio-controlled fractal exploration",
    category: "fractal",
    draw(ctx, t, {amplitude, centroid}) {
      const width = ctx.canvas.width;
      const height = ctx.canvas.height;
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;

      const zoom = 1 + amplitude * 2;
      const centerX = -0.7 + centroid * 0.4;
      const centerY = 0 + centroid * 0.2;
      const maxIter = 50;

      for (let x = 0; x < width; x += 4) { // Skip pixels for performance
        for (let y = 0; y < height; y += 4) {
          const zx = (x - width / 2) / (width / 4) / zoom + centerX;
          const zy = (y - height / 2) / (height / 4) / zoom + centerY;

          let cx = zx, cy = zy;
          let iter = 0;

          while (cx * cx + cy * cy < 4 && iter < maxIter) {
            const tmp = cx * cx - cy * cy + zx;
            cy = 2 * cx * cy + zy;
            cx = tmp;
            iter++;
          }

          const color = iter < maxIter ? iter / maxIter : 0;
          const pixelIndex = (y * width + x) * 4;

          if (pixelIndex < data.length) {
            data[pixelIndex] = color * 255 * (1 + amplitude); // Red
            data[pixelIndex + 1] = color * 128 + centroid * 127; // Green
            data[pixelIndex + 2] = 255 - color * 200; // Blue
            data[pixelIndex + 3] = 255; // Alpha
          }
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }
  },

  // === Sacred Geometry ===
  flowerOfLife: {
    label: "Flower of Life",
    description: "Sacred geometry with harmonic resonance",
    category: "sacred",
    draw(ctx, t, {amplitude, centroid, am, fm}) {
      const cx = ctx.canvas.width / 2;
      const cy = ctx.canvas.height / 2;
      const radius = 40 + amplitude * 30;
      const layers = 3;

      ctx.strokeStyle = `hsla(${60 + centroid * 240}, 70%, ${60 + amplitude * 30}%, 0.6)`;
      ctx.lineWidth = 1 + amplitude * 2;

      // Central circle
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.stroke();

      // Surrounding circles in layers
      for (let layer = 1; layer <= layers; layer++) {
        const circleCount = layer * 6;
        const layerRadius = radius * layer + am * 20;

        for (let i = 0; i < circleCount; i++) {
          const angle = (i / circleCount) * Math.PI * 2 + t * fm;
          const x = cx + layerRadius * Math.cos(angle);
          const y = cy + layerRadius * Math.sin(angle);

          ctx.globalAlpha = 0.5 + amplitude * 0.3;
          ctx.beginPath();
          ctx.arc(x, y, radius * 0.8, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      ctx.globalAlpha = 1;
    }
  },

  metatronsCube: {
    label: "Metatron's Cube",
    description: "13-circle sacred geometry pattern",
    category: "sacred",
    draw(ctx, t, {amplitude, centroid, am, fm}) {
      const cx = ctx.canvas.width / 2;
      const cy = ctx.canvas.height / 2;
      const radius = 25 + amplitude * 20;

      // 13 circles of Metatron's Cube
      const positions = [
        [0, 0], // Center
        [-1, -1], [0, -1], [1, -1], // Top row
        [-1.5, 0], [-0.5, 0], [0.5, 0], [1.5, 0], // Middle rows
        [-1, 1], [0, 1], [1, 1], // Bottom row
        [-0.5, -2], [0.5, -2] // Additional positions
      ];

      ctx.strokeStyle = `hsla(${280 + centroid * 80}, 80%, ${60 + amplitude * 30}%, 0.7)`;
      ctx.lineWidth = 1.5 + amplitude;

      // Draw circles
      positions.forEach(([dx, dy], i) => {
        const x = cx + dx * radius * 2;
        const y = cy + dy * radius * 2;

        ctx.globalAlpha = 0.6 + Math.sin(t + i) * 0.2;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.stroke();
      });

      // Draw connecting lines (cube edges)
      ctx.globalAlpha = 0.4 + amplitude * 0.3;
      ctx.beginPath();

      // Connect specific circles to form the cube structure
      const connections = [
        [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], // Center to surrounding
        [1, 2], [2, 3], [3, 7], [7, 10], [10, 9], [9, 8], [8, 4], [4, 1] // Outer connections
      ];

      connections.forEach(([i, j]) => {
        const [x1, y1] = [cx + positions[i][0] * radius * 2, cy + positions[i][1] * radius * 2];
        const [x2, y2] = [cx + positions[j][0] * radius * 2, cy + positions[j][1] * radius * 2];

        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
      });

      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  },

  // === Advanced Audio Visualizations ===
  waveformMandala: {
    label: "Waveform Mandala",
    description: "Circular waveform with radial symmetry",
    category: "audio-reactive",
    draw(ctx, t, {amplitude, waveform, centroid}) {
      if (!waveform || waveform.length === 0) return;

      const cx = ctx.canvas.width / 2;
      const cy = ctx.canvas.height / 2;
      const baseRadius = 60;
      const symmetry = 8; // 8-fold radial symmetry

      for (let sym = 0; sym < symmetry; sym++) {
        const symAngle = (sym / symmetry) * Math.PI * 2;

        ctx.strokeStyle = `hsla(${sym * 45 + centroid * 180}, 80%, ${60 + amplitude * 30}%, 0.6)`;
        ctx.lineWidth = 1 + amplitude * 2;
        ctx.beginPath();

        for (let i = 0; i < waveform.length; i += 2) {
          const sample = (waveform[i] - 128) / 128; // Normalize to -1 to 1
          const angle = symAngle + (i / waveform.length) * Math.PI * 2;
          const radius = baseRadius + sample * 40 * (1 + amplitude);

          const x = cx + radius * Math.cos(angle);
          const y = cy + radius * Math.sin(angle);

          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        ctx.closePath();
        ctx.stroke();
      }
    }
  },

  bassVisualizer: {
    label: "Bass Visualizer",
    description: "Low-frequency reactive geometric patterns",
    category: "audio-reactive",
    draw(ctx, t, {amplitude, spectrum, centroid, am}) {
      if (!spectrum || spectrum.length === 0) return;

      const cx = ctx.canvas.width / 2;
      const cy = ctx.canvas.height / 2;

      // Get bass frequencies (first 10% of spectrum)
      const bassRange = Math.floor(spectrum.length * 0.1);
      let bassEnergy = 0;
      for (let i = 0; i < bassRange; i++) {
        bassEnergy += spectrum[i];
      }
      bassEnergy = (bassEnergy / bassRange) / 255;

      // Draw pulsing hexagon based on bass
      const sides = 6;
      const radius = 40 + bassEnergy * 80 + am * 20;

      ctx.strokeStyle = `hsla(${20 + bassEnergy * 60}, 90%, ${50 + bassEnergy * 40}%, 0.8)`;
      ctx.fillStyle = `hsla(${20 + bassEnergy * 60}, 70%, 30%, ${bassEnergy * 0.3})`;
      ctx.lineWidth = 2 + bassEnergy * 4;

      ctx.beginPath();
      for (let i = 0; i <= sides; i++) {
        const angle = (i / sides) * Math.PI * 2 + t + bassEnergy;
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Add inner resonance circles
      for (let i = 1; i <= 3; i++) {
        const innerRadius = (radius / (i + 1)) * (1 + bassEnergy * 0.5);
        ctx.strokeStyle = `hsla(${20 + bassEnergy * 60}, 60%, ${70 - i * 20}%, ${0.5 + bassEnergy * 0.3})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  },

  // === Quantum Patterns ===
  quantumInterference: {
    label: "Quantum Interference",
    description: "Wave interference patterns",
    category: "quantum",
    draw(ctx, t, {amplitude, fm, am, centroid}) {
      const width = ctx.canvas.width;
      const height = ctx.canvas.height;

      // Create interference pattern
      for (let x = 0; x < width; x += 3) {
        for (let y = 0; y < height; y += 3) {
          const dx1 = x - width * 0.3;
          const dy1 = y - height * 0.5;
          const dx2 = x - width * 0.7;
          const dy2 = y - height * 0.5;

          const d1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
          const d2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

          const wave1 = Math.sin(d1 * 0.1 + t * (2 + fm) + am);
          const wave2 = Math.sin(d2 * 0.1 + t * (2 + am) + fm);
          const interference = (wave1 + wave2) * amplitude;

          const intensity = (interference + 2) / 4; // Normalize to 0-1

          ctx.fillStyle = `hsla(${centroid * 360 + interference * 60}, 70%, ${intensity * 80}%, 0.6)`;
          ctx.fillRect(x, y, 3, 3);
        }
      }
    }
  }
};
