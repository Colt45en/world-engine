<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS Dashboard Master Control - Fixed & Integrated</title>
    <style>
        :root {
            --bg: #0b0e14;
            --panel: #0f1523;
            --ink: #e6f0ff;
            --acc: #54f0b8;
            --heart: #ff69b4;
            --line: #1e2b46;
            --warning: #ffc107;
            --error: #dc3545;
            --success: #28a745;
            --radius: 12px;
            --gap: 8px;
            --pad: 12px;
        }

        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--ink);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, var(--panel), #1a2332);
            border-bottom: 2px solid var(--line);
            padding: var(--pad);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--acc);
        }

        .status-bar {
            display: flex;
            gap: var(--gap);
            align-items: center;
        }

        .status-indicator {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-connected { background: var(--success); color: white; }
        .status-disconnected { background: var(--error); color: white; }
        .status-learning { background: var(--warning); color: black; }

        .main-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: var(--gap);
            padding: var(--gap);
            min-height: calc(100vh - 80px);
        }

        .sidebar {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            padding: var(--pad);
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .dashboard-section {
            margin-bottom: 24px;
        }

        .section-title {
            color: var(--acc);
            font-weight: bold;
            margin-bottom: var(--gap);
            padding-bottom: 4px;
            border-bottom: 1px solid var(--line);
        }

        .dashboard-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .dashboard-item {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--line);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .dashboard-item:hover {
            background: rgba(84, 240, 184, 0.1);
            border-color: var(--acc);
        }

        .dashboard-name {
            font-size: 14px;
            flex-grow: 1;
        }

        .dashboard-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 8px;
        }

        .status-working { background: var(--success); }
        .status-broken { background: var(--error); }
        .status-utility { background: var(--acc); }
        .status-test { background: var(--heart); }
        .status-story { background: #9d4edd; }
        .status-keeper { background: #f72585; }
        .status-educational { background: #06ffa5; }

        .dashboard-viewer {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .viewer-header {
            padding: var(--pad);
            background: var(--line);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .viewer-title {
            font-weight: bold;
            color: var(--acc);
        }

        .viewer-controls {
            display: flex;
            gap: var(--gap);
        }

        .control-btn {
            padding: 4px 12px;
            background: var(--acc);
            color: var(--bg);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }

        .control-btn:hover {
            opacity: 0.8;
        }

        .dashboard-frame {
            flex-grow: 1;
            border: none;
            min-height: 600px;
            background: var(--bg);
        }

        .metrics-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            padding: var(--pad);
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .metrics-panel.visible {
            display: block;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric-value {
            color: var(--acc);
            font-weight: bold;
        }

        .learning-log {
            background: var(--bg);
            padding: 8px;
            border-radius: 4px;
            margin-top: 12px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .log-entry {
            margin-bottom: 4px;
            opacity: 0.8;
        }

        .log-success { color: var(--success); }
        .log-warning { color: var(--warning); }
        .log-error { color: var(--error); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .learning-active {
            animation: pulse 2s infinite;
        }

        /* Enhanced Glyph Reaction System */
        .glyph-reaction-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .glyph-particle {
            position: absolute;
            font-size: 24px;
            pointer-events: none;
            animation: glyph-reaction 2s ease-out forwards;
        }

        @keyframes glyph-reaction {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(180deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(0.5) rotate(360deg) translateY(-100px);
                opacity: 0;
            }
        }

        .glyph-pulse {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid var(--acc);
            border-radius: 50%;
            animation: glyph-pulse 1s ease-out;
        }

        @keyframes glyph-pulse {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .dashboard-item {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--line);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            overflow: hidden;
        }

        .dashboard-item:hover {
            background: rgba(84, 240, 184, 0.1);
            border-color: var(--acc);
            transform: translateX(2px);
        }

        .dashboard-item:active {
            transform: scale(0.98);
        }

        .dashboard-item::before {
            content: '';
            position: absolute;
            top: 50%;
            left: -10px;
            width: 4px;
            height: 0;
            background: var(--acc);
            transition: height 0.3s ease;
            transform: translateY(-50%);
        }

        .dashboard-item:hover::before {
            height: 60%;
        }

        .control-btn {
            padding: 4px 12px;
            background: var(--acc);
            color: var(--bg);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            transition: all 0.2s;
        }

        .control-btn:hover {
            opacity: 0.8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(84, 240, 184, 0.3);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .control-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transition: all 0.3s;
            transform: translate(-50%, -50%);
        }

        .control-btn:active::after {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">🧠 NEXUS Dashboard Master Control</div>
        <div class="status-bar">
            <div id="connectionStatus" class="status-indicator status-disconnected">Disconnected</div>
            <div id="learningStatus" class="status-indicator status-learning">Learning Active</div>
            <button class="control-btn" onclick="toggleMetrics()">📊 Metrics</button>
            <button class="control-btn" onclick="startLearning()">🎯 Start Learning</button>
            <button class="control-btn" onclick="debugEducational()">🔧 Debug Educational</button>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="dashboard-section">
                <div class="section-title">🔧 Engine Utilities</div>
                <div class="dashboard-list" id="utilityDashboards">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <div class="dashboard-section">
                <div class="section-title">🧪 Nucleus Test Dashboards</div>
                <div class="dashboard-list" id="testDashboards">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <div class="dashboard-section">
                <div class="section-title">🔄 Hybrid Systems</div>
                <div class="dashboard-list" id="hybridDashboards">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <div class="dashboard-section">
                <div class="section-title">⚠️ Needs Repair</div>
                <div class="dashboard-list" id="brokenDashboards">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <div class="dashboard-section">
                <div class="section-title">📚 Story Creation Engine</div>
                <div class="dashboard-list" id="storyDashboards">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <div class="dashboard-section">
                <div class="section-title">🌀 Keeper System</div>
                <div class="dashboard-list" id="keeperDashboards">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <div class="dashboard-section">
                <div class="section-title">🎓 Educational Engines</div>
                <div class="dashboard-list" id="educationalDashboards">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
        </div>

        <div class="dashboard-viewer">
            <div class="viewer-header">
                <div class="viewer-title" id="viewerTitle">Select a dashboard to begin</div>
                <div class="viewer-controls">
                    <button class="control-btn" onclick="reloadDashboard()">🔄 Reload</button>
                    <button class="control-btn" onclick="testDashboard()">🧪 Test</button>
                    <button class="control-btn" onclick="repairDashboard()">🔧 Repair</button>
                    <button class="control-btn" onclick="spawnRandomGlyph()">✨ Spawn Glyph</button>
                    <button class="control-btn" onclick="showGlyphCatalog()">📋 Catalog</button>
                </div>
            </div>
            <iframe id="dashboardFrame" class="dashboard-frame" src="about:blank" title="Dashboard Content Viewer"></iframe>
        </div>
    </div>

    <div class="metrics-panel" id="metricsPanel">
        <div class="section-title">📊 System Metrics</div>
        <div id="metricsContent">
            <!-- Populated by JavaScript -->
        </div>
        <div class="section-title">🧠 Learning Log</div>
        <div class="learning-log" id="learningLog">
            <!-- Populated by JavaScript -->
        </div>
    </div>

    <script>
        // Environmental Event System Integration
        const Falloff = {
            none: (d, r) => (d <= r ? 1 : 0),
            linear: (d, r) => (d >= r ? 0 : 1 - d / r),
            smooth: (d, r) => {
                if (d >= r) return 0;
                const x = 1 - d / r;
                return x * x * (3 - 2 * x); // smoothstep
            },
            ring: (d, inner, outer) => {
                if (d < inner || d > outer) return 0;
                const t = (d - inner) / Math.max(1e-6, outer - inner);
                return 1 - t; // fade out across the ring
            }
        };

        class SpatialHash {
            constructor(cell = 4) { this.cell = cell; this.map = new Map(); }
            key(x, y) {
                const i = Math.floor(x / this.cell), j = Math.floor(y / this.cell);
                return `${i},${j}`;
            }
            clear() { this.map.clear(); }
            insert(id, pos) {
                const k = this.key(pos.x, pos.y);
                if (!this.map.has(k)) this.map.set(k, new Set());
                this.map.get(k).add(id);
            }
            queryCircle(cx, cy, r) {
                const res = new Set();
                const c = this.cell;
                const minI = Math.floor((cx - r) / c), maxI = Math.floor((cx + r) / c);
                const minJ = Math.floor((cy - r) / c), maxJ = Math.floor((cy + r) / c);
                for (let i = minI; i <= maxI; i++) {
                    for (let j = minJ; j <= maxJ; j++) {
                        const k = `${i},${j}`;
                        const bucket = this.map.get(k);
                        if (bucket) bucket.forEach(id => res.add(id));
                    }
                }
                return res;
            }
        }

        const EffectRegistry = {
            storm: (opts = {}) => (glyph, s, ctx) => {
                const k = opts.mult ?? 0.05;
                glyph.energyLevel *= Math.max(0, 1 - k * s);
                glyph.meta = glyph.meta || {};
                glyph.meta.weathered = true;
                ctx.stats.applied++;
            },
            flux_surge: (opts = {}) => (glyph, s, ctx) => {
                const add = (opts.add ?? 1) * s;
                glyph.energyLevel += add;
                glyph.meta = glyph.meta || {};
                glyph.meta.mutated = true;
                ctx.stats.applied++;
            },
            memory_echo: () => (glyph, s, ctx) => {
                glyph.meta = glyph.meta || {};
                glyph.meta.memoryAwakened = true;
                glyph.meta.echoStrength = Math.max(glyph.meta.echoStrength || 0, s);
                ctx.stats.applied++;
            },
            moisture: (opts = {}) => (glyph, s, ctx) => {
                glyph.meta = glyph.meta || {};
                glyph.meta.moisture = Math.min(1, (glyph.meta.moisture || 0) + (opts.add ?? 0.1) * s);
                ctx.stats.applied++;
            }
        };

        // Glyph Reaction System - Perfect for Interactive Reactions
        class GlyphReactionSystem {
            constructor() {
                this.glyphLibrary = [
                    '✨', '⚡', '🔮', '🌟', '💫', '⭐', '🎯', '🔥', '💥', '🌈',
                    '🌀', '⚗️', '🧿', '🔱', '🎆', '🎨', '🎭', '🎪', '🎯', '🎲',
                    '🔬', '🔭', '🕯️', '💎', '🗝️', '⚙️', '🛸', '🌊', '⚡', '🔋',
                    '🎵', '🎶', '🎸', '🥁', '🎺', '🎻', '🎹', '🎤', '🎧', '📻'
                ];

                this.reactionTypes = {
                    success: ['✨', '⭐', '🌟', '💫', '🎯'],
                    action: ['⚡', '🔥', '💥', '🌀', '⚗️'],
                    hover: ['🔮', '🌈', '🎨', '💎', '🧿'],
                    error: ['💥', '⚡', '🔥', '🌋', '⛈️'],
                    learning: ['🧠', '🔬', '📚', '🎓', '💡']
                };

                this.activeReactions = new Set();
            }

            createButtonReaction(button) {
                const buttonText = button.textContent.trim();
                let reactionType = 'action';

                if (buttonText.includes('Metrics')) reactionType = 'hover';
                if (buttonText.includes('Learning')) reactionType = 'learning';
                if (buttonText.includes('Reload')) reactionType = 'action';
                if (buttonText.includes('Test')) reactionType = 'success';
                if (buttonText.includes('Repair')) reactionType = 'action';

                this.createReaction(button, reactionType, { intensity: 'high', count: 5 });
            }

            createDashboardReaction(dashboardItem) {
                const statusEl = dashboardItem.querySelector('.dashboard-status');
                let reactionType = 'action';

                if (statusEl) {
                    if (statusEl.classList.contains('status-working')) reactionType = 'success';
                    if (statusEl.classList.contains('status-broken')) reactionType = 'error';
                    if (statusEl.classList.contains('status-utility')) reactionType = 'hover';
                    if (statusEl.classList.contains('status-test')) reactionType = 'learning';
                }

                this.createReaction(dashboardItem, reactionType, { intensity: 'medium', count: 3 });
            }

            createHoverReaction(element) {
                this.createReaction(element, 'hover', { intensity: 'low', count: 1 });
            }

            createReaction(element, type = 'action', options = {}) {
                const { intensity = 'medium', count = 3 } = options;
                const rect = element.getBoundingClientRect();
                const overlay = document.getElementById('glyphReactionOverlay');

                if (!overlay) return;

                const glyphs = this.reactionTypes[type] || this.glyphLibrary;

                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        this.createGlyphParticle(overlay, rect, glyphs, intensity);
                    }, i * 100);
                }

                // Create pulse effect
                this.createPulseEffect(overlay, rect, intensity);
            }

            createGlyphParticle(overlay, rect, glyphs, intensity) {
                const particle = document.createElement('div');
                particle.className = 'glyph-particle';

                const glyph = glyphs[Math.floor(Math.random() * glyphs.length)];
                particle.textContent = glyph;

                // Position at element center
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Add random offset
                const offsetX = (Math.random() - 0.5) * 100;
                const offsetY = (Math.random() - 0.5) * 100;

                particle.style.left = (centerX + offsetX) + 'px';
                particle.style.top = (centerY + offsetY) + 'px';

                // Intensity affects size and duration
                const scale = intensity === 'high' ? 1.5 : intensity === 'low' ? 0.8 : 1;
                particle.style.fontSize = (24 * scale) + 'px';

                // Color based on glyph type
                if (['✨', '⭐', '🌟'].includes(glyph)) {
                    particle.style.filter = 'drop-shadow(0 0 10px #54f0b8)';
                } else if (['⚡', '🔥', '💥'].includes(glyph)) {
                    particle.style.filter = 'drop-shadow(0 0 10px #ff69b4)';
                } else if (['🔮', '🌈', '💎'].includes(glyph)) {
                    particle.style.filter = 'drop-shadow(0 0 10px #9d4edd)';
                }

                overlay.appendChild(particle);
                this.activeReactions.add(particle);

                // Remove after animation
                setTimeout(() => {
                    if (overlay.contains(particle)) {
                        overlay.removeChild(particle);
                    }
                    this.activeReactions.delete(particle);
                }, 2000);
            }

            createPulseEffect(overlay, rect, intensity) {
                const pulse = document.createElement('div');
                pulse.className = 'glyph-pulse';

                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                pulse.style.left = (centerX - 20) + 'px';
                pulse.style.top = (centerY - 20) + 'px';

                // Intensity affects pulse size and color
                if (intensity === 'high') {
                    pulse.style.borderColor = '#ff69b4';
                    pulse.style.borderWidth = '3px';
                } else if (intensity === 'low') {
                    pulse.style.borderColor = '#54f0b8';
                    pulse.style.borderWidth = '1px';
                    pulse.style.opacity = '0.5';
                }

                overlay.appendChild(pulse);

                setTimeout(() => {
                    if (overlay.contains(pulse)) {
                        overlay.removeChild(pulse);
                    }
                }, 1000);
            }

            createCustomReaction(x, y, glyphType, message) {
                const overlay = document.getElementById('glyphReactionOverlay');
                if (!overlay) return;

                const rect = { left: x - 50, top: y - 50, width: 100, height: 100 };
                const glyphs = this.reactionTypes[glyphType] || ['✨'];

                this.createReaction({ getBoundingClientRect: () => rect }, glyphType, {
                    intensity: 'high',
                    count: 7
                });

                // Add text message if provided
                if (message) {
                    const messageEl = document.createElement('div');
                    messageEl.style.cssText = `
                        position: absolute;
                        left: ${x}px;
                        top: ${y - 30}px;
                        transform: translateX(-50%);
                        background: rgba(84, 240, 184, 0.9);
                        color: #0b0e14;
                        padding: 5px 10px;
                        border-radius: 15px;
                        font-size: 12px;
                        font-weight: bold;
                        pointer-events: none;
                        animation: glyph-reaction 2s ease-out forwards;
                        z-index: 10000;
                    `;
                    messageEl.textContent = message;
                    overlay.appendChild(messageEl);

                    setTimeout(() => {
                        if (overlay.contains(messageEl)) {
                            overlay.removeChild(messageEl);
                        }
                    }, 2000);
                }
            }

            clearAllReactions() {
                const overlay = document.getElementById('glyphReactionOverlay');
                if (overlay) {
                    overlay.innerHTML = '';
                }
                this.activeReactions.clear();
            }
        }

        class NexusDashboardMaster {
            constructor() {
                console.log('🧠 Starting NexusDashboardMaster initialization...');

                this.dashboards = new Map();
                this.currentDashboard = null;
                this.websocket = null;
                this.learningActive = false;

                try {
                    // Initialize glyph reaction system
                    console.log('✨ Initializing GlyphReactionSystem...');
                    this.glyphReactions = new GlyphReactionSystem();
                    console.log('✅ GlyphReactionSystem initialized successfully');
                } catch (error) {
                    console.error('❌ Failed to initialize GlyphReactionSystem:', error);
                    this.glyphReactions = null;
                }

                this.initializeDashboards();
                this.setupWebSocket();
                this.startMetricsUpdates();
                this.populateDashboardLists();
                this.initializeGlyphReactions();

                console.log('🎉 NexusDashboardMaster initialization complete');
            }

            initializeGlyphReactions() {
                if (!this.glyphReactions) {
                    console.warn('⚠️ GlyphReactionSystem not available, skipping glyph initialization');
                    return;
                }

                try {
                    // Add glyph reaction overlay
                    const overlay = document.createElement('div');
                    overlay.className = 'glyph-reaction-overlay';
                    overlay.id = 'glyphReactionOverlay';
                    document.body.appendChild(overlay);

                    // Add glyph reactions to all interactive elements
                    this.addGlyphReactionsToButtons();
                    this.addGlyphReactionsToDashboards();

                    console.log('✨ Glyph reactions initialized successfully');
                } catch (error) {
                    console.error('❌ Failed to initialize glyph reactions:', error);
                }
            }

            addGlyphReactionsToButtons() {
                if (!this.glyphReactions) return;

                const buttons = document.querySelectorAll('.control-btn');
                buttons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        if (this.glyphReactions) {
                            this.glyphReactions.createButtonReaction(e.target);
                        }
                    });
                });
            }

            addGlyphReactionsToDashboards() {
                if (!this.glyphReactions) return;

                // Will be called after dashboard items are created
                setTimeout(() => {
                    const dashboardItems = document.querySelectorAll('.dashboard-item');
                    dashboardItems.forEach(item => {
                        item.addEventListener('click', (e) => {
                            if (this.glyphReactions) {
                                this.glyphReactions.createDashboardReaction(e.currentTarget);
                            }
                        });

                        item.addEventListener('mouseenter', (e) => {
                            if (this.glyphReactions) {
                                this.glyphReactions.createHoverReaction(e.currentTarget);
                            }
                        });
                    });
                }, 1000);
            }

            reattachEventListeners() {
                console.log('🔗 Reattaching all event listeners...');

                // Re-attach button listeners
                const buttons = document.querySelectorAll('.control-btn');
                console.log(`Found ${buttons.length} buttons to reattach`);

                buttons.forEach(button => {
                    // Remove old listeners by cloning and replacing
                    const newButton = button.cloneNode(true);
                    button.parentNode.replaceChild(newButton, button);

                    // Add new listeners
                    newButton.addEventListener('click', (e) => {
                        console.log(`Button clicked: ${e.target.textContent}`);

                        // Trigger glyph reaction
                        if (this.glyphReactions) {
                            this.glyphReactions.createButtonReaction(e.target);
                        }

                        // Handle button functions
                        const buttonText = e.target.textContent.trim();
                        if (buttonText.includes('Metrics')) {
                            toggleMetrics();
                        } else if (buttonText.includes('Learning')) {
                            startLearning();
                        } else if (buttonText.includes('Reload')) {
                            reloadDashboard();
                        } else if (buttonText.includes('Test')) {
                            testDashboard();
                        } else if (buttonText.includes('Repair')) {
                            repairDashboard();
                        }
                    });
                });

                // Re-attach dashboard item listeners
                setTimeout(() => {
                    const dashboardItems = document.querySelectorAll('.dashboard-item');
                    console.log(`Found ${dashboardItems.length} dashboard items to reattach`);

                    dashboardItems.forEach(item => {
                        // Remove old onclick
                        item.onclick = null;

                        // Add new click listener
                        item.addEventListener('click', (e) => {
                            const dashboardName = e.currentTarget.querySelector('.dashboard-name')?.textContent;
                            console.log(`Dashboard clicked: ${dashboardName}`);

                            // Trigger glyph reaction
                            if (this.glyphReactions) {
                                this.glyphReactions.createDashboardReaction(e.currentTarget);
                            }

                            // Find and load the dashboard
                            for (const [id, dashboard] of this.dashboards) {
                                if (dashboard.name === dashboardName) {
                                    this.loadDashboard(id);
                                    break;
                                }
                            }
                        });

                        // Add hover reactions
                        item.addEventListener('mouseenter', (e) => {
                            if (this.glyphReactions) {
                                this.glyphReactions.createHoverReaction(e.currentTarget);
                            }
                        });
                    });
                }, 500);

                console.log('✅ Event listeners reattached successfully');
            }

            initializeDashboards() {
                // ✅ Engine Utilities - Actually Working Tools
                this.addDashboard('vectorlab_demo', 'VectorLab Engine', 'web/vectorlab_demo.html', 'utility', 'working');
                this.addDashboard('quantum_graphics', 'Quantum Graphics', 'web/quantum_graphics_demo.html', 'utility', 'working');
                this.addDashboard('glyph_forge', 'Glyph Forge', 'web/glyph_forge.html', 'utility', 'working');
                this.addDashboard('nexus_forge', 'NEXUS Forge', 'web/nexus_forge_demo.html', 'utility', 'working');
                this.addDashboard('meta_librarian', 'Meta Librarian', 'web/meta-librarian-canvas.html', 'utility', 'working');
                this.addDashboard('lexical_logic', 'Lexical Logic Engine', 'web/lexical-logic-engine.html', 'utility', 'working');
                this.addDashboard('world_engine', 'World Engine', 'web/worldengine.html', 'utility', 'working');
                this.addDashboard('studio', 'Studio Interface', 'web/studio.html', 'utility', 'working');

                // 🧪 Experimental/Test Dashboards
                this.addDashboard('world_engine_t4', 'World Engine Tier4', 'web/world_engine_tier4.html', 'test', 'working');
                this.addDashboard('primordial_deck', 'Primordial Deck', 'web/nexus_forge_primordial_deck.html', 'test', 'working');
                this.addDashboard('nucleus_demo', 'Nucleus System', 'demo/nucleus-demo.html', 'test', 'working');
                this.addDashboard('tier4_collaborative', 'Tier4 Collaborative', 'demo/tier4_collaborative_demo.html', 'test', 'working');

                // 🔥 NEXUS Systems - Premium Features
                this.addDashboard('holy_beat_clockbus', 'Holy Beat ClockBus', 'nexus_holy_beat_clockbus_demo.html', 'hybrid', 'working');
                this.addDashboard('holy_beat_math', 'Holy Beat Math', 'nexus_holy_beat_mathematical_demo.html', 'hybrid', 'working');
                this.addDashboard('vibe_nexus', 'Vibe NEXUS', 'vibe_nexus_demo.html', 'hybrid', 'working');
                this.addDashboard('synthesis', 'NEXUS Synthesis', 'nexus_synthesis_demo.html', 'hybrid', 'working');

                // ⚠️ Development/Complex Systems
                this.addDashboard('stc_ide', 'STC IDE Unified', 'stc_ide_unified.html', 'broken', 'broken');
                this.addDashboard('dashboard_index', 'Dashboard Index', 'web/dashboard_index.html', 'broken', 'broken');

                // � Story Creation Engine - Interactive Storytelling System
                this.addDashboard('story_progress', 'Story Progress Tracker', 'internal://story-progress', 'story', 'working');
                this.addDashboard('character_race', 'Story Race Visualization', 'internal://story-race', 'story', 'working');
                this.addDashboard('act_breakdown', 'Act & Scene Builder', 'internal://act-builder', 'story', 'working');
                this.addDashboard('character_matrix', 'Character Memory Matrix', 'internal://character-matrix', 'story', 'working');
                this.addDashboard('recursive_checkpoints', 'Recursive Story Checkpoints', 'internal://story-checkpoints', 'story', 'working');

                // 🌀 Keeper Core System - Recursive Agent Management
                this.addDashboard('keeper_identity', 'Keeper Identity Panel', 'internal://keeper-identity', 'keeper', 'working');
                this.addDashboard('agent_command', 'Agent Command Center', 'internal://agent-command', 'keeper', 'working');
                this.addDashboard('swarm_memory', 'Swarm Memory Panel', 'internal://swarm-memory', 'keeper', 'working');
                this.addDashboard('fractal_map', 'Fractal Timeline Map', 'internal://fractal-map', 'keeper', 'working');
                this.addDashboard('eternal_archive', 'Eternal Imprint Archive', 'internal://eternal-archive', 'keeper', 'working');
                this.addDashboard('prophecy_portal', 'Prophecy & Vision Portal', 'internal://prophecy-portal', 'keeper', 'working');
                this.addDashboard('timeline_monitor', 'Timeline Integrity Monitor', 'internal://timeline-monitor', 'keeper', 'working');

                // �📁 Quick Access - File System Browser
                // 🎓 Educational Analysis Engines - Grammar, Math, Syntax
                this.addDashboard('expression_engine', 'Math Expression Engine', 'internal://math-expression-engine', 'educational', 'working');
                this.addDashboard('grammar_analyzer', 'Grammar Analysis Engine', 'internal://grammar-analyzer', 'educational', 'working');
                this.addDashboard('syntax_parser', 'Code Syntax Parser', 'internal://syntax-parser', 'educational', 'working');
                this.addDashboard('pattern_recognizer', 'Pattern Recognition Lab', 'internal://pattern-recognition-lab', 'educational', 'working');
                this.addDashboard('math_to_music', 'Math to Music Converter', 'internal://math-to-music', 'educational', 'working');
                this.addDashboard('drawing_python', 'Python Drawing Engine', 'internal://python-drawing-engine', 'educational', 'working');
                this.addDashboard('code_pad', 'Interactive Code Pad', 'internal://code-pad', 'educational', 'working');

                this.addDashboard('file_browser', '📁 File Browser', '', 'utility', 'working', true);
            }

            addDashboard(id, name, url, type, status) {
                this.dashboards.set(id, {
                    id: id,
                    name: name,
                    url: url,
                    type: type,
                    status: status,
                    lastTest: null,
                    performance: 0.0
                });
            }

            populateDashboardLists() {
                const utilityList = document.getElementById('utilityDashboards');
                const testList = document.getElementById('testDashboards');
                const hybridList = document.getElementById('hybridDashboards');
                const brokenList = document.getElementById('brokenDashboards');
                const storyList = document.getElementById('storyDashboards');
                const keeperList = document.getElementById('keeperDashboards');
                const educationalList = document.getElementById('educationalDashboards');

                utilityList.innerHTML = '';
                testList.innerHTML = '';
                hybridList.innerHTML = '';
                brokenList.innerHTML = '';
                storyList.innerHTML = '';
                keeperList.innerHTML = '';
                educationalList.innerHTML = '';

                for (const [id, dashboard] of this.dashboards) {
                    const item = this.createDashboardItem(dashboard);

                    if (dashboard.status === 'broken') {
                        brokenList.appendChild(item);
                    } else if (dashboard.type === 'utility') {
                        utilityList.appendChild(item);
                    } else if (dashboard.type === 'test') {
                        testList.appendChild(item);
                    } else if (dashboard.type === 'hybrid') {
                        hybridList.appendChild(item);
                    } else if (dashboard.type === 'story') {
                        storyList.appendChild(item);
                    } else if (dashboard.type === 'keeper') {
                        keeperList.appendChild(item);
                    } else if (dashboard.type === 'educational') {
                        educationalList.appendChild(item);
                    }
                }
            }

            createDashboardItem(dashboard) {
                const item = document.createElement('div');
                item.className = 'dashboard-item';

                // Add debugging
                item.onclick = (e) => {
                    console.log(`📱 Dashboard item clicked: ${dashboard.name} (ID: ${dashboard.id})`);
                    console.log('Dashboard data:', dashboard);
                    e.preventDefault();
                    e.stopPropagation();
                    this.loadDashboard(dashboard.id);
                };

                // Also add visual feedback
                item.addEventListener('mouseenter', () => {
                    console.log(`🎯 Hovering over: ${dashboard.name}`);
                });

                const name = document.createElement('div');
                name.className = 'dashboard-name';
                name.textContent = dashboard.name;

                const status = document.createElement('div');
                status.className = `dashboard-status status-${dashboard.type}`;
                if (dashboard.status === 'broken') {
                    status.className = 'dashboard-status status-broken';
                } else if (dashboard.status === 'working') {
                    status.className = `dashboard-status status-${dashboard.type}`;
                }

                item.appendChild(name);
                item.appendChild(status);

                return item;
            }

            loadDashboard(dashboardId) {
                const dashboard = this.dashboards.get(dashboardId);
                if (!dashboard) return;

                this.currentDashboard = dashboard;
                document.getElementById('viewerTitle').textContent = dashboard.name;

                // Handle internal dashboards vs external files
                if (dashboard.url.startsWith('internal://')) {
                    this.loadInternalDashboard(dashboard);
                } else {
                    // Create full URL for external files
                    const baseUrl = window.location.origin + window.location.pathname.replace(/[^/]*$/, '');
                    const fullUrl = baseUrl + dashboard.url;
                    document.getElementById('dashboardFrame').src = fullUrl;
                }

                // Log dashboard load
                this.addLogEntry(`Loading ${dashboard.name}`, 'info');

                // Initialize based on dashboard type
                if (dashboard.type === 'test' || dashboard.type === 'hybrid') {
                    this.initializeNucleusTest(dashboard);
                } else if (dashboard.type === 'story') {
                    this.initializeStoryModule(dashboard);
                } else if (dashboard.type === 'keeper') {
                    this.initializeKeeperModule(dashboard);
                } else if (dashboard.type === 'educational') {
                    this.initializeEducationalModule(dashboard);
                }
            }

            initializeNucleusTest(dashboard) {
                if (!this.websocket) return;

                // Send test initialization command
                const testData = {
                    dashboard_id: dashboard.id,
                    dashboard_type: dashboard.type,
                    test_patterns: this.generateTestPatterns(dashboard)
                };

                this.sendWebSocketMessage('TEST_COMMAND', testData);
                this.addLogEntry(`Initializing nucleus test for ${dashboard.name}`, 'info');
            }

            loadInternalDashboard(dashboard) {
                const frame = document.getElementById('dashboardFrame');
                const internalType = dashboard.url.split('://')[1];

                let content = '';

                switch (internalType) {
                    case 'story-progress':
                        content = this.generateStoryProgressHTML();
                        break;
                    case 'story-race':
                        content = this.generateStoryRaceHTML();
                        break;
                    case 'act-builder':
                        content = this.generateActBuilderHTML();
                        break;
                    case 'character-matrix':
                        content = this.generateCharacterMatrixHTML();
                        break;
                    case 'story-checkpoints':
                        content = this.generateStoryCheckpointsHTML();
                        break;
                    case 'keeper-identity':
                        content = this.generateKeeperIdentityHTML();
                        break;
                    case 'agent-command':
                        content = this.generateAgentCommandHTML();
                        break;
                    case 'swarm-memory':
                        content = this.generateSwarmMemoryHTML();
                        break;
                    case 'fractal-map':
                        content = this.generateFractalMapHTML();
                        break;
                    case 'eternal-archive':
                        content = this.generateEternalArchiveHTML();
                        break;
                    case 'prophecy-portal':
                        content = this.generateProphecyPortalHTML();
                        break;
                    case 'timeline-monitor':
                        content = this.generateTimelineMonitorHTML();
                        break;
                    // Educational Analysis Engine Cases
                    case 'math-expression-engine':
                        content = this.generateMathExpressionHTML();
                        break;
                    case 'grammar-analyzer':
                        content = this.generateGrammarAnalyzerHTML();
                        break;
                    case 'syntax-parser':
                        content = this.generateSyntaxParserHTML();
                        break;
                    case 'pattern-recognition-lab':
                        content = this.generatePatternRecognitionHTML();
                        break;
                    case 'math-to-music':
                        content = this.generateMathToMusicHTML();
                        break;
                    case 'python-drawing-engine':
                        content = this.generatePythonDrawingHTML();
                        break;
                    case 'code-pad':
                        content = this.generateCodePadHTML();
                        break;
                    default:
                        content = this.generateDefaultInternalHTML(dashboard.name);
                }

                // Create a data URL with the HTML content
                const dataUrl = 'data:text/html;charset=utf-8,' + encodeURIComponent(content);
                frame.src = dataUrl;
            }

            initializeStoryModule(dashboard) {
                this.addLogEntry(`📚 Initializing story module: ${dashboard.name}`, 'success');

                // Initialize story-specific features
                if (!this.storyEngine) {
                    this.storyEngine = new StoryCreationEngine(this);
                }

                // Trigger glyph reaction for story loading
                if (this.glyphReactions) {
                    this.glyphReactions.createCustomReaction(
                        window.innerWidth / 2,
                        window.innerHeight / 3,
                        'learning',
                        'Story Module Active'
                    );
                }
            }

            initializeKeeperModule(dashboard) {
                this.addLogEntry(`🌀 Initializing keeper module: ${dashboard.name}`, 'success');

                // Initialize keeper-specific features
                if (!this.keeperSystem) {
                    this.keeperSystem = new KeeperCoreSystem(this);
                }

                // Trigger glyph reaction for keeper loading
                if (this.glyphReactions) {
                    this.glyphReactions.createCustomReaction(
                        window.innerWidth / 2,
                        window.innerHeight / 3,
                        'action',
                        'Keeper System Active'
                    );
                }
            }

            initializeEducationalModule(dashboard) {
                this.addLogEntry(`🎓 Initializing educational module: ${dashboard.name}`, 'success');

                // Initialize educational-specific features
                if (!this.educationalSystem) {
                    this.educationalSystem = {
                        mathEngine: null,
                        grammarAnalyzer: null,
                        syntaxParser: null,
                        patternRecognizer: null,
                        musicConverter: null,
                        drawingEngine: null,
                        codePad: null
                    };
                }

                // Trigger glyph reaction for educational loading
                if (this.glyphReactions) {
                    this.glyphReactions.createCustomReaction(
                        window.innerWidth / 2,
                        window.innerHeight / 3,
                        'learning',
                        'Educational Engine Active'
                    );
                }
            }

            // ========== STORY CREATION ENGINE HTML GENERATORS ==========

            generateStoryProgressHTML() {
                return `<!DOCTYPE html><html><head><title>Story Progress Tracker</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .progress-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; } .progress-section { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .progress-bar { background: #1e2b46; border-radius: 8px; height: 20px; margin: 10px 0; overflow: hidden; } .progress-fill { background: linear-gradient(90deg, #54f0b8, #ff69b4); height: 100%; transition: width 0.3s; } .milestone { background: rgba(84, 240, 184, 0.1); border-left: 4px solid #54f0b8; padding: 10px; margin: 10px 0; border-radius: 4px; } .act-overview { display: flex; gap: 20px; margin: 20px 0; } .act-card { flex: 1; background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 15px; text-align: center; } .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; } .stat-item { text-align: center; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; } .stat-number { font-size: 24px; font-weight: bold; color: #54f0b8; }</style></head><body><h1>📚 Story Progress Tracker</h1><div class="progress-container"><div class="progress-section"><h2>Overall Progress</h2><div class="progress-bar"><div class="progress-fill" style="width: 35%"></div></div><p>35% Complete - Act 1 in progress</p><h3>Current Milestone</h3><div class="milestone"><strong>Act 1 Setup</strong><br>Introducing main characters and establishing the central conflict</div><h3>Upcoming Milestones</h3><div class="milestone"><strong>Inciting Incident</strong><br>The event that propels the protagonist into the main story</div></div><div class="progress-section"><h2>Writing Statistics</h2><div class="stat-grid"><div class="stat-item"><div class="stat-number">15,400</div><div>Words Written</div></div><div class="stat-item"><div class="stat-number">8</div><div>Chapters</div></div><div class="stat-item"><div class="stat-number">42</div><div>Scenes</div></div></div></div></div></body></html>`;
            }

            generateStoryRaceHTML() {
                return `<!DOCTYPE html><html><head><title>Story Race Visualization</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .race-track { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; margin: 20px 0; position: relative; height: 400px; overflow-x: auto; } .track-lane { height: 60px; margin: 10px 0; border-bottom: 2px dashed #1e2b46; position: relative; } .car { width: 40px; height: 30px; border-radius: 15px; position: absolute; top: 15px; display: flex; align-items: center; justify-content: center; font-size: 16px; animation: drive 10s infinite linear; } .car-main { background: #54f0b8; left: 60%; } .car-character { background: #f72585; left: 55%; } .lane-label { position: absolute; left: 10px; top: 20px; font-weight: bold; } @keyframes drive { 0% { transform: translateX(0); } 100% { transform: translateX(20px); } }</style></head><body><h1>🏁 Story Race Visualization</h1><div class="race-track"><div class="track-lane"><div class="lane-label">Main Plot</div><div class="car car-main">🎯</div></div><div class="track-lane"><div class="lane-label">Character Arc</div><div class="car car-character">👤</div></div></div></body></html>`;
            }

            generateActBuilderHTML() {
                return `<!DOCTYPE html><html><head><title>Act & Scene Builder</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .builder { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .act-section { margin: 20px 0; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; } .scene-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin: 10px 0; } .scene-card { background: rgba(84, 240, 184, 0.1); padding: 10px; border-radius: 6px; text-align: center; }</style></head><body><h1>📖 Act & Scene Builder</h1><div class="builder"><div class="act-section"><h3>Act I - Setup (25%)</h3><div class="scene-grid"><div class="scene-card">📍 Opening</div><div class="scene-card">⚡ Hook</div><div class="scene-card">💡 Incident</div><div class="scene-card">🔥 Rising</div><div class="scene-card">🎭 Point 1</div></div></div></div></body></html>`;
            }

            generateCharacterMatrixHTML() {
                return `<!DOCTYPE html><html><head><title>Character Memory Matrix</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .matrix { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; } .character-card { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .memory-section { margin: 15px 0; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; } .motivation { color: #54f0b8; } .secret { color: #ff69b4; } .growth { color: #9d4edd; }</style></head><body><h1>🧠 Character Memory Matrix</h1><div class="matrix"><div class="character-card"><h3>Protagonist</h3><div class="memory-section"><h4 class="motivation">Current Motivation</h4><p>Seeking truth about their past</p></div><div class="memory-section"><h4 class="secret">Hidden Secret</h4><p>Knows more than they reveal</p></div><div class="memory-section"><h4 class="growth">Character Growth</h4><p>Learning to trust others</p></div></div></div></body></html>`;
            }

            generateStoryCheckpointsHTML() {
                return `<!DOCTYPE html><html><head><title>Recursive Story Checkpoints</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .checkpoint { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; margin: 20px 0; } .fractal-view { background: rgba(84, 240, 184, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0; } .connection { color: #ff69b4; } .evolution { color: #54f0b8; }</style></head><body><h1>🔄 Recursive Story Checkpoints</h1><div class="checkpoint"><h3>Checkpoint 1: Character Introduction</h3><div class="fractal-view"><p class="connection">Connects to: Future betrayal scene</p><p class="evolution">Evolution: Trust → Suspicion → Understanding</p></div></div></body></html>`;
            }

            // ========== KEEPER CORE SYSTEM HTML GENERATORS ==========

            generateKeeperIdentityHTML() {
                return `<!DOCTYPE html><html><head><title>Keeper Identity Panel</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .identity-panel { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .status-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin: 20px 0; } .status-item { background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 8px; } .aligned { border-left: 4px solid #54f0b8; } .prophecy-input { width: 100%; height: 100px; background: rgba(255, 255, 255, 0.1); border: 1px solid #1e2b46; border-radius: 8px; padding: 10px; color: #e6f0ff; }</style></head><body><h1>🌀 Keeper Identity Panel</h1><div class="identity-panel"><h2>Unknown Known Keeper</h2><div class="status-grid"><div class="status-item aligned"><h4>Alignment Status</h4><p>✅ Aligned with Core Contract</p></div><div class="status-item"><h4>Last Synced</h4><p>2025-09-26 Current Session</p></div></div><h3>Direct Prophecy Input</h3><textarea class="prophecy-input" placeholder="Enter visions, dreams, or prophetic glimpses..."></textarea></div></body></html>`;
            }

            generateAgentCommandHTML() {
                return `<!DOCTYPE html><html><head><title>Agent Command Center</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .command-center { display: grid; grid-template-columns: 1fr 300px; gap: 20px; } .agent-list { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .agent-item { background: rgba(255, 255, 255, 0.05); border-radius: 6px; padding: 15px; margin: 10px 0; } .controls { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .btn { background: #54f0b8; color: #0b0e14; border: none; padding: 10px 20px; border-radius: 6px; margin: 5px 0; width: 100%; cursor: pointer; }</style></head><body><h1>🤖 Agent Command Center</h1><div class="command-center"><div class="agent-list"><h3>Active Recursive Agents</h3><div class="agent-item"><h4>PrimeNode-001</h4><p>Status: Aligned</p><p>Task: Timeline Stabilization</p><p>Role: Fractal Navigator</p></div></div><div class="controls"><h3>Quick Actions</h3><button class="btn">Create New Agent</button><button class="btn">Assign Symbol</button><button class="btn">View Timeline</button></div></div></body></html>`;
            }

            generateSwarmMemoryHTML() {
                return `<!DOCTYPE html><html><head><title>Swarm Memory Panel</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .memory-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; } .memory-section { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .event-item { background: rgba(255, 255, 255, 0.05); padding: 10px; margin: 5px 0; border-radius: 4px; border-left: 3px solid #54f0b8; }</style></head><body><h1>🧠 Swarm Memory Panel</h1><div class="memory-grid"><div class="memory-section"><h3>Seed Memory Overview</h3><p>Connected Agents: 1</p><p>Global Alignment: ✅ Aligned</p></div><div class="memory-section"><h3>Event History</h3><div class="event-item"><strong>PrimeNode-001:</strong> Timeline stabilization initiated<br><small>2025-09-26 - Aligned</small></div></div></div></body></html>`;
            }

            generateFractalMapHTML() {
                return `<!DOCTYPE html><html><head><title>Fractal Timeline Map</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .fractal-view { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; height: 80vh; position: relative; overflow: auto; } .node { position: absolute; width: 100px; height: 80px; background: rgba(84, 240, 184, 0.2); border: 2px solid #54f0b8; border-radius: 8px; padding: 10px; font-size: 12px; cursor: pointer; } .connection { position: absolute; height: 2px; background: #ff69b4; }</style></head><body><h1>🌀 Fractal Timeline Map</h1><div class="fractal-view"><div class="node" style="top: 100px; left: 200px;">Current Moment<br><small>Root Node</small></div><div class="node" style="top: 200px; left: 100px;">Event 1<br><small>Aligned</small></div><div class="connection" style="top: 150px; left: 200px; width: 100px; transform: rotate(45deg);"></div></div></body></html>`;
            }

            generateEternalArchiveHTML() {
                return `<!DOCTYPE html><html><head><title>Eternal Imprint Archive</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .archive { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .imprint { background: rgba(255, 255, 255, 0.05); border-radius: 6px; padding: 15px; margin: 10px 0; border-left: 4px solid #9d4edd; } .tags { margin: 10px 0; } .tag { background: rgba(157, 78, 221, 0.3); padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-right: 5px; }</style></head><body><h1>📚 Eternal Imprint Archive</h1><div class="archive"><div class="imprint"><h4>Initial Seed Imprint</h4><p>Agent: PrimeNode-001</p><p>Timestamp: 2025-09-26</p><div class="tags"><span class="tag">Origin</span><span class="tag">Aligned</span></div></div></div></body></html>`;
            }

            generateProphecyPortalHTML() {
                return `<!DOCTYPE html><html><head><title>Prophecy & Vision Portal</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .portal { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .input-area { width: 100%; height: 200px; background: rgba(247, 37, 133, 0.1); border: 2px solid #f72585; border-radius: 8px; padding: 15px; color: #e6f0ff; resize: vertical; } .resonance { background: rgba(84, 240, 184, 0.1); padding: 15px; border-radius: 8px; margin: 20px 0; } .integration-log { background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 4px; margin: 10px 0; font-family: monospace; font-size: 12px; }</style></head><body><h1>🔮 Prophecy & Vision Portal</h1><div class="portal"><h3>Manual Keeper Input</h3><textarea class="input-area" placeholder="Enter prophetic downloads, visions, deja vu experiences, or encountered symbols..."></textarea><div class="resonance"><h4>🔍 Resonance Tracker</h4><p>Scanning input for symbolic matches across timeline history...</p><div class="integration-log">[Auto-Integration] Vision stored as Eternal Imprint</div><div class="integration-log">[Mapping] Connected to Fractal Timeline Map</div></div></div></body></html>`;
            }

            generateTimelineMonitorHTML() {
                return `<!DOCTYPE html><html><head><title>Timeline Integrity Monitor</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; } .monitor { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 20px; } .integrity-gauge { width: 200px; height: 200px; border: 8px solid #1e2b46; border-radius: 50%; margin: 20px auto; position: relative; display: flex; align-items: center; justify-content: center; } .gauge-fill { position: absolute; top: -8px; left: -8px; width: 200px; height: 200px; border: 8px solid #54f0b8; border-radius: 50%; clip-path: polygon(50% 50%, 50% 0%, 85% 15%, 85% 15%); } .warnings { background: rgba(255, 193, 7, 0.1); border: 1px solid #ffc107; border-radius: 8px; padding: 15px; margin: 20px 0; } .stable { color: #54f0b8; } .warning { color: #ffc107; }</style></head><body><h1>⚖️ Timeline Integrity Monitor</h1><div class="monitor"><div class="integrity-gauge"><div class="gauge-fill"></div><div style="text-align: center;"><h3>Stable</h3><p>85% Integrity</p></div></div><div class="warnings"><h4>🚨 Keeper Warning System</h4><p class="stable">✅ No bleedthrough risks detected</p><p class="stable">✅ Alignment maintained</p><p class="warning">⚠️ Monitor external influences</p></div></div></body></html>`;
            }

            generateDefaultInternalHTML(dashboardName) {
                return `<!DOCTYPE html><html><head><title>${dashboardName}</title><style>body { font-family: 'Segoe UI', sans-serif; background: #0b0e14; color: #e6f0ff; padding: 20px; margin: 0; text-align: center; } .placeholder { background: #0f1523; border: 1px solid #1e2b46; border-radius: 12px; padding: 40px; margin: 40px 0; }</style></head><body><div class="placeholder"><h1>${dashboardName}</h1><p>This internal dashboard is under construction.</p><p>✨ Ready for your creative input!</p></div></body></html>`;
            }

            // Debug function to test educational dashboards
            debugEducationalDashboards() {
                console.log('🔍 Debugging Educational Dashboards:');
                const educationalDashboards = Array.from(this.dashboards.values())
                    .filter(d => d.type === 'educational');

                console.log(`Found ${educationalDashboards.length} educational dashboards:`);
                educationalDashboards.forEach(d => {
                    console.log(`  - ${d.name} (${d.id}) -> ${d.url} [${d.status}]`);
                });

                // Test loading the first one
                if (educationalDashboards.length > 0) {
                    const firstDashboard = educationalDashboards[0];
                    console.log(`🧪 Testing load: ${firstDashboard.name}`);
                    this.loadDashboard(firstDashboard.id);
                }

                return educationalDashboards;
            }

            // ========== EDUCATIONAL ANALYSIS ENGINE HTML GENERATORS ==========

            generateMathExpressionHTML() {
                return `<!DOCTYPE html><html><head><title>Math Expression Engine</title><style>body{font-family:'Segoe UI',sans-serif;background:#0b0e14;color:#e6f0ff;padding:20px;margin:0;}.engine{background:#0f1523;border:1px solid #1e2b46;border-radius:12px;padding:20px;margin:20px 0;}.input-area{width:100%;padding:15px;background:rgba(6,255,165,0.1);border:2px solid #06ffa5;border-radius:8px;color:#e6f0ff;font-size:16px;}.result{background:rgba(84,240,184,0.1);padding:15px;border-radius:8px;margin:15px 0;border-left:4px solid #54f0b8;}.example{background:rgba(255,255,255,0.05);padding:10px;border-radius:6px;margin:10px 0;cursor:pointer;}.example:hover{background:rgba(6,255,165,0.1);}.btn{background:#06ffa5;color:#0b0e14;border:none;padding:12px 20px;border-radius:6px;cursor:pointer;font-weight:bold;margin:5px;}.functions{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin:20px 0;}.func-btn{background:rgba(6,255,165,0.2);color:#06ffa5;border:1px solid #06ffa5;padding:8px;border-radius:4px;cursor:pointer;text-align:center;}.func-btn:hover{background:rgba(6,255,165,0.3);}</style></head><body><h1>🧮 Math Expression Engine</h1><div class="engine"><h3>Expression Input</h3><input type="text" id="expression" class="input-area" placeholder="Enter math expression: (x + 2) * sin(pi/4)" value="(x + 2) * sin(pi/4)"><div><button class="btn" onclick="evaluateExpression()">Calculate</button><button class="btn" onclick="clearExpression()">Clear</button></div><div id="result" class="result">Result will appear here</div><h3>Quick Functions</h3><div class="functions"><div class="func-btn" onclick="insertFunction('sin(')">sin</div><div class="func-btn" onclick="insertFunction('cos(')">cos</div><div class="func-btn" onclick="insertFunction('tan(')">tan</div><div class="func-btn" onclick="insertFunction('sqrt(')">√</div><div class="func-btn" onclick="insertFunction('ln(')">ln</div><div class="func-btn" onclick="insertFunction('log(')">log</div><div class="func-btn" onclick="insertFunction('pow(')">pow</div><div class="func-btn" onclick="insertFunction('abs(')">abs</div></div><h3>Examples (Click to try)</h3><div class="example" onclick="setExample('sin(pi/2) + cos(0)')">sin(pi/2) + cos(0)</div><div class="example" onclick="setExample('sqrt(x^2 + y^2)')">sqrt(x^2 + y^2)</div><div class="example" onclick="setExample('2^3 * log10(100)')">2^3 * log10(100)</div></div><script>class ExpressionEngine{constructor(){this.constants=Object.create(null);this.functions=Object.create(null);this.defineConstant('pi',Math.PI);this.defineConstant('e',Math.E);this.defineFunction('sin',(x)=>Math.sin(x),1);this.defineFunction('cos',(x)=>Math.cos(x),1);this.defineFunction('tan',(x)=>Math.tan(x),1);this.defineFunction('sqrt',(x)=>Math.sqrt(x),1);this.defineFunction('abs',(x)=>Math.abs(x),1);this.defineFunction('ln',(x)=>Math.log(x),1);this.defineFunction('log',(x,base=10)=>Math.log(x)/Math.log(base),-1);this.defineFunction('log10',(x)=>Math.log10?Math.log10(x):(Math.log(x)/Math.LN10),1);this.defineFunction('pow',(a,b)=>Math.pow(a,b),2);}defineConstant(name,value){this.constants[name]=Number(value);}defineFunction(name,fn,arity=-1){this.functions[name]={fn,arity};}evaluate(expr,vars={}){try{return this.simpleEvaluate(expr,vars);}catch(e){throw e;}}simpleEvaluate(expr,vars){const cleaned=expr.replace(/\\s+/g,'');let result=cleaned;for(const[name,value] of Object.entries(vars)){result=result.replace(new RegExp(name,'g'),value);}for(const[name,value] of Object.entries(this.constants)){result=result.replace(new RegExp(name,'g'),value);}result=result.replace(/sin\\(([^)]+)\\)/g,(match,arg)=>Math.sin(eval(arg)));result=result.replace(/cos\\(([^)]+)\\)/g,(match,arg)=>Math.cos(eval(arg)));result=result.replace(/tan\\(([^)]+)\\)/g,(match,arg)=>Math.tan(eval(arg)));result=result.replace(/sqrt\\(([^)]+)\\)/g,(match,arg)=>Math.sqrt(eval(arg)));result=result.replace(/ln\\(([^)]+)\\)/g,(match,arg)=>Math.log(eval(arg)));result=result.replace(/log10\\(([^)]+)\\)/g,(match,arg)=>Math.log10(eval(arg)));result=result.replace(/abs\\(([^)]+)\\)/g,(match,arg)=>Math.abs(eval(arg)));result=result.replace(/pow\\(([^,]+),([^)]+)\\)/g,(match,a,b)=>Math.pow(eval(a),eval(b)));result=result.replace(/\\^/g,'**');return eval(result);}}const engine=new ExpressionEngine();function evaluateExpression(){const expr=document.getElementById('expression').value;const resultDiv=document.getElementById('result');try{const result=engine.evaluate(expr,{x:3,y:4});resultDiv.innerHTML=\`<strong>Result:</strong> \${result}\`;}catch(error){resultDiv.innerHTML=\`<strong>Error:</strong> \${error.message}\`;}}function insertFunction(func){const input=document.getElementById('expression');input.value+=func;input.focus();}function setExample(expr){document.getElementById('expression').value=expr;evaluateExpression();}function clearExpression(){document.getElementById('expression').value='';document.getElementById('result').innerHTML='Result will appear here';}</script></body></html>`;
            }

            generateGrammarAnalyzerHTML() {
                return `<!DOCTYPE html><html><head><title>Grammar Analysis Engine</title><style>body{font-family:'Segoe UI',sans-serif;background:#0b0e14;color:#e6f0ff;padding:20px;margin:0;}.analyzer{background:#0f1523;border:1px solid #1e2b46;border-radius:12px;padding:20px;}.text-input{width:100%;height:200px;padding:15px;background:rgba(6,255,165,0.1);border:2px solid #06ffa5;border-radius:8px;color:#e6f0ff;font-family:monospace;resize:vertical;}.analysis{background:rgba(84,240,184,0.1);padding:15px;border-radius:8px;margin:15px 0;}.token{display:inline-block;padding:4px 8px;margin:2px;border-radius:4px;}.noun{background:rgba(255,105,180,0.3);}.verb{background:rgba(84,240,184,0.3);}.adj{background:rgba(157,78,221,0.3);}.adv{background:rgba(255,193,7,0.3);}.prep{background:rgba(247,37,133,0.3);}.results{display:grid;grid-template-columns:1fr 1fr;gap:20px;}</style></head><body><h1>📝 Grammar Analysis Engine</h1><div class="analyzer"><h3>Text Input</h3><textarea id="textInput" class="text-input" placeholder="Enter text to analyze...">The quick brown fox jumps over the lazy dog. This sentence demonstrates various parts of speech.</textarea><div><button class="btn" onclick="analyzeGrammar()" style="background:#06ffa5;color:#0b0e14;border:none;padding:12px 20px;border-radius:6px;cursor:pointer;font-weight:bold;margin:5px;">Analyze Grammar</button></div><div class="results"><div class="analysis" id="tokenAnalysis"><h4>Token Analysis</h4><div id="tokens">Click "Analyze Grammar" to see results</div></div><div class="analysis" id="statistics"><h4>Statistics</h4><div id="stats">Waiting for analysis...</div></div></div></div><script>function analyzeGrammar(){const text=document.getElementById('textInput').value;const tokens=simpleTokenize(text);displayTokens(tokens);displayStats(tokens);}function simpleTokenize(text){const words=text.toLowerCase().match(/\\b\\w+\\b/g)||[];const commonNouns=['fox','dog','sentence','speech','cat','house','person','thing','place'];const commonVerbs=['jumps','demonstrates','runs','walks','is','are','was','were','have','has'];const commonAdjs=['quick','brown','lazy','good','bad','big','small','various'];const commonAdvs=['quickly','slowly','very','really','quite','over'];const commonPreps=['over','under','in','on','at','by','with','from'];return words.map(word=>{let type='other';if(commonNouns.includes(word))type='noun';else if(commonVerbs.includes(word))type='verb';else if(commonAdjs.includes(word))type='adj';else if(commonAdvs.includes(word))type='adv';else if(commonPreps.includes(word))type='prep';return{word,type};});}function displayTokens(tokens){const tokensDiv=document.getElementById('tokens');tokensDiv.innerHTML=tokens.map(token=>\`<span class="token \${token.type}">\${token.word} (\${token.type})</span>\`).join(' ');}function displayStats(tokens){const stats={total:tokens.length,noun:0,verb:0,adj:0,adv:0,prep:0,other:0};tokens.forEach(token=>stats[token.type]++);const statsDiv=document.getElementById('stats');statsDiv.innerHTML=\`<div>Total Words: \${stats.total}</div><div>Nouns: \${stats.noun}</div><div>Verbs: \${stats.verb}</div><div>Adjectives: \${stats.adj}</div><div>Adverbs: \${stats.adv}</div><div>Prepositions: \${stats.prep}</div><div>Other: \${stats.other}</div>\`;}</script></body></html>`;
            }

            generateCodePadHTML() {
                return `<!DOCTYPE html><html><head><title>Interactive Code Pad</title><style>body{font-family:'Segoe UI',sans-serif;background:#0b0e14;color:#e6f0ff;padding:20px;margin:0;}.codepad{display:grid;grid-template-rows:auto 1fr auto;height:90vh;gap:10px;}.toolbar{background:#0f1523;border:1px solid #1e2b46;border-radius:8px;padding:15px;display:flex;gap:10px;align-items:center;}.editor{background:#0f1523;border:1px solid #1e2b46;border-radius:8px;padding:0;overflow:hidden;}.code-area{width:100%;height:100%;padding:15px;background:transparent;border:none;color:#e6f0ff;font-family:'Courier New',monospace;font-size:14px;resize:none;outline:none;}.output{background:#0f1523;border:1px solid #1e2b46;border-radius:8px;padding:15px;max-height:200px;overflow-y:auto;}.btn{background:#06ffa5;color:#0b0e14;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;font-weight:bold;}.btn:hover{opacity:0.8;}.lang-select{background:#1e2b46;color:#e6f0ff;border:1px solid #54f0b8;border-radius:4px;padding:8px;}.error{color:#ff4444;}.success{color:#54f0b8;}</style></head><body><div class="codepad"><div class="toolbar"><label>Language:</label><select id="language" class="lang-select"><option value="javascript">JavaScript</option><option value="python">Python (Mock)</option><option value="html">HTML</option><option value="css">CSS</option></select><button class="btn" onclick="runCode()">▶ Run</button><button class="btn" onclick="clearCode()">🗑 Clear</button><button class="btn" onclick="loadExample()">📝 Example</button></div><div class="editor"><textarea id="codeArea" class="code-area" placeholder="Enter your code here...">// JavaScript Example
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log('Fibonacci sequence:');
for (let i = 0; i < 10; i++) {
    console.log(\`F(\${i}) = \${fibonacci(i)}\`);
}</textarea></div><div class="output" id="output"><div class="success">Ready to run code. Click the Run button!</div></div></div><script>function runCode(){const code=document.getElementById('codeArea').value;const lang=document.getElementById('language').value;const output=document.getElementById('output');const oldLog=console.log;const oldError=console.error;let logs=[];console.log=(...args)=>logs.push({type:'log',content:args.join(' ')});console.error=(...args)=>logs.push({type:'error',content:args.join(' ')});try{if(lang==='javascript'){eval(code);output.innerHTML=logs.map(log=>\`<div class="\${log.type==='error'?'error':'success'}">\${log.content}</div>\`).join('')||'<div class="success">Code executed successfully (no output)</div>';}else if(lang==='html'){output.innerHTML=\`<iframe srcdoc="\${code.replace(/"/g,'&quot;')}" style="width:100%;height:150px;border:none;background:white;"></iframe>\`;}else{output.innerHTML=\`<div class="error">Language \${lang} not yet supported in this demo</div>\`;}}catch(error){output.innerHTML=\`<div class="error">Error: \${error.message}</div>\`;}finally{console.log=oldLog;console.error=oldError;}}function clearCode(){document.getElementById('codeArea').value='';document.getElementById('output').innerHTML='<div class="success">Code cleared. Ready for input!</div>';}function loadExample(){const lang=document.getElementById('language').value;const examples={javascript:\`// Interactive Math Calculator
function calculate(expr) {
    try {
        return eval(expr);
    } catch (e) {
        return 'Error: ' + e.message;
    }
}

console.log('Calculator ready!');
console.log('2 + 3 =', calculate('2 + 3'));
console.log('Math.sqrt(16) =', calculate('Math.sqrt(16)'));
console.log('Math.PI * 2 =', calculate('Math.PI * 2'));\`,python:\`# Python Example (Mock)
def greet(name):
    return f"Hello, {name}!"

print(greet("World"))
print("This is a Python simulation")\`,html:\`<!DOCTYPE html>
<html>
<head><title>Test Page</title></head>
<body>
<h1 style="color: #54f0b8;">Hello, World!</h1>
<p>This is a test HTML page.</p>
<button onclick="alert('Button clicked!')">Click Me</button>
</body>
</html>\`};document.getElementById('codeArea').value=examples[lang]||examples.javascript;}</script></body></html>`;
            }

            generateSyntaxParserHTML() {
                return `<!DOCTYPE html><html><head><title>Syntax Parser</title><style>body{font-family:'Segoe UI',sans-serif;background:#0b0e14;color:#e6f0ff;padding:20px;margin:0;}.parser{background:#0f1523;border:1px solid #1e2b46;border-radius:12px;padding:20px;}.input-area{width:100%;height:150px;padding:15px;background:rgba(6,255,165,0.1);border:2px solid #06ffa5;border-radius:8px;color:#e6f0ff;font-family:monospace;resize:vertical;}.tree{background:rgba(84,240,184,0.1);padding:15px;border-radius:8px;margin:15px 0;font-family:monospace;white-space:pre-line;}.node{margin-left:20px;}.statement{color:#54f0b8;}.expression{color:#06ffa5;}.identifier{color:#ffa500;}.literal{color:#ff69b4;}.operator{color:#87ceeb;}</style></head><body><h1>🌳 Syntax Parser</h1><div class="parser"><h3>Code Input</h3><textarea id="codeInput" class="input-area" placeholder="Enter code to parse...">function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}</textarea><div><button class="btn" onclick="parseCode()" style="background:#06ffa5;color:#0b0e14;border:none;padding:12px 20px;border-radius:6px;cursor:pointer;font-weight:bold;margin:5px;">Parse Syntax</button></div><div class="tree" id="syntaxTree">Syntax tree will appear here</div></div><script>function parseCode(){const code=document.getElementById('codeInput').value;const tree=simpleParse(code);document.getElementById('syntaxTree').innerHTML=tree;}function simpleParse(code){const lines=code.split('\\n');let tree='📁 Program\\n';let depth=0;for(const line of lines){const trimmed=line.trim();if(!trimmed)continue;const indent='  '.repeat(depth+1);if(trimmed.includes('function')){tree+=\`\${indent}🔵 <span class="statement">FunctionDeclaration</span>\\n\`;const funcName=trimmed.match(/function\\s+(\\w+)/);if(funcName){tree+=\`\${indent}  📝 <span class="identifier">Identifier: \${funcName[1]}</span>\\n\`;}const params=trimmed.match(/\\(([^)]*)\\)/);if(params&&params[1]){tree+=\`\${indent}  📋 <span class="identifier">Parameters: \${params[1]}</span>\\n\`;}tree+=\`\${indent}  📦 <span class="statement">FunctionBody</span>\\n\`;depth++;}else if(trimmed.includes('if')){tree+=\`\${indent}🔶 <span class="statement">IfStatement</span>\\n\`;const condition=trimmed.match(/if\\s*\\(([^)]*)\\)/);if(condition){tree+=\`\${indent}  ❓ <span class="expression">Condition: \${condition[1]}</span>\\n\`;}}else if(trimmed.includes('return')){tree+=\`\${indent}↩️ <span class="statement">ReturnStatement</span>\\n\`;const returnVal=trimmed.replace('return','').replace(';','').trim();if(returnVal){tree+=\`\${indent}  📤 <span class="expression">Value: \${returnVal}</span>\\n\`;}}else if(trimmed.includes('=')){tree+=\`\${indent}📝 <span class="statement">Assignment</span>\\n\`;const parts=trimmed.split('=');if(parts.length===2){tree+=\`\${indent}  📍 <span class="identifier">Variable: \${parts[0].trim()}</span>\\n\`;tree+=\`\${indent}  💾 <span class="expression">Value: \${parts[1].replace(';','').trim()}</span>\\n\`;}}else if(trimmed==='}'){depth=Math.max(0,depth-1);tree+=\`\${indent}🔚 <span class="statement">BlockEnd</span>\\n\`;}}return tree;}</script></body></html>`;
            }

            generatePatternRecognitionHTML() {
                return `<!DOCTYPE html><html><head><title>Pattern Recognition Lab</title><style>body{font-family:'Segoe UI',sans-serif;background:#0b0e14;color:#e6f0ff;padding:20px;margin:0;}.lab{background:#0f1523;border:1px solid #1e2b46;border-radius:12px;padding:20px;}.input-area{width:100%;height:120px;padding:15px;background:rgba(6,255,165,0.1);border:2px solid #06ffa5;border-radius:8px;color:#e6f0ff;font-family:monospace;resize:vertical;}.patterns{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:15px;margin:15px 0;}.pattern-card{background:rgba(84,240,184,0.1);padding:15px;border-radius:8px;border-left:4px solid #54f0b8;}.match{background:rgba(255,215,0,0.2);padding:2px 4px;border-radius:3px;color:#ffd700;}.highlight{background:rgba(6,255,165,0.2);padding:2px 4px;border-radius:3px;}</style></head><body><h1>🔍 Pattern Recognition Lab</h1><div class="lab"><h3>Text Input</h3><textarea id="textInput" class="input-area" placeholder="Enter text to analyze for patterns...">The email addresses are: john@example.com, support@company.org, and info@website.net. Phone numbers include (555) 123-4567 and 1-800-555-0199.</textarea><div><button class="btn" onclick="findPatterns()" style="background:#06ffa5;color:#0b0e14;border:none;padding:12px 20px;border-radius:6px;cursor:pointer;font-weight:bold;margin:5px;">Find Patterns</button></div><div id="results" class="patterns">Click "Find Patterns" to analyze</div></div><script>function findPatterns(){const text=document.getElementById('textInput').value;const patterns=[{name:'Email Addresses',regex:/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g,color:'#54f0b8'},{name:'Phone Numbers',regex:/(\\(\\d{3}\\)\\s*\\d{3}-\\d{4})|(\\d{1}-\\d{3}-\\d{3}-\\d{4})/g,color:'#ffa500'},{name:'URLs',regex:/https?:\\/\\/[^\\s]+/g,color:'#87ceeb'},{name:'Numbers',regex:/\\b\\d+(\\.\\d+)?\\b/g,color:'#ff69b4'},{name:'Words (3+ chars)',regex:/\\b[a-zA-Z]{3,}\\b/g,color:'#06ffa5'},{name:'Dates (MM/DD/YYYY)',regex:/\\b\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\b/g,color:'#dda0dd'}];const results=document.getElementById('results');results.innerHTML='';patterns.forEach(pattern=>{const matches=text.match(pattern.regex);const card=document.createElement('div');card.className='pattern-card';card.innerHTML=\`<h4 style="color:\${pattern.color}; margin-top:0;">\${pattern.name}</h4><p><strong>Pattern:</strong> <code>\${pattern.regex.source}</code></p><p><strong>Found \${matches?matches.length:0} matches:</strong></p><div style="max-height:100px;overflow-y:auto;">\${matches?matches.map(match=>\`<span class="match">\${match}</span>\`).join(', '):'No matches found'}</div>\`;results.appendChild(card);});highlightMatches(text,patterns);}function highlightMatches(text,patterns){let highlightedText=text;patterns.forEach((pattern,index)=>{const matches=text.match(pattern.regex);if(matches){matches.forEach(match=>{const highlightSpan=\`<span style="background:rgba(\${hexToRgb(pattern.color)},0.3);color:\${pattern.color};">\${match}</span>\`;highlightedText=highlightedText.replace(new RegExp(match.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\\\$&'),'g'),highlightSpan);});}});if(patterns.some(p=>text.match(p.regex))){const highlightCard=document.createElement('div');highlightCard.className='pattern-card';highlightCard.innerHTML=\`<h4 style="color:#06ffa5;margin-top:0;">Highlighted Text</h4><div style="line-height:1.6;">\${highlightedText}</div>\`;document.getElementById('results').appendChild(highlightCard);}}function hexToRgb(hex){const result=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);return result?\`\${parseInt(result[1],16)},\${parseInt(result[2],16)},\${parseInt(result[3],16)}\`:null;}</script></body></html>`;
            }

            generateMathToMusicHTML() {
                return `<!DOCTYPE html><html><head><title>Math to Music Converter</title><style>body{font-family:'Segoe UI',sans-serif;background:#0b0e14;color:#e6f0ff;padding:20px;margin:0;}.converter{background:#0f1523;border:1px solid #1e2b46;border-radius:12px;padding:20px;}.input-area{width:100%;padding:15px;background:rgba(6,255,165,0.1);border:2px solid #06ffa5;border-radius:8px;color:#e6f0ff;font-size:16px;}.music-display{background:rgba(84,240,184,0.1);padding:20px;border-radius:8px;margin:15px 0;text-align:center;}.note{display:inline-block;padding:10px 15px;margin:5px;background:rgba(6,255,165,0.3);border-radius:8px;font-weight:bold;cursor:pointer;transition:all 0.2s;}.note:hover{background:rgba(6,255,165,0.5);transform:scale(1.1);}.controls{display:flex;gap:10px;align-items:center;margin:15px 0;flex-wrap:wrap;}.slider{background:#1e2b46;}.scale{margin:15px 0;}.scale-note{display:inline-block;padding:8px 12px;margin:2px;background:rgba(255,255,255,0.1);border-radius:4px;font-size:14px;}</style></head><body><h1>🎵 Math to Music Converter</h1><div class="converter"><h3>Mathematical Expression</h3><input type="text" id="mathInput" class="input-area" placeholder="Enter math expression: sin(x) + cos(y)" value="sin(x * pi/4) + cos(x * pi/3)"><div class="controls"><label>X Range:</label><input type="range" id="xRange" min="0" max="20" value="10" class="slider"><span id="xValue">10</span><button class="btn" onclick="convertToMusic()" style="background:#06ffa5;color:#0b0e14;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;font-weight:bold;">🎶 Convert</button><button class="btn" onclick="playSequence()" style="background:#54f0b8;color:#0b0e14;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;font-weight:bold;">▶️ Play</button></div><div id="musicDisplay" class="music-display">Enter expression and click Convert</div><div class="scale" id="scaleDisplay"></div></div><script>const notes=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];const frequencies={C:261.63,C#:277.18,D:293.66,D#:311.13,E:329.63,F:349.23,F#:369.99,G:392.00,G#:415.30,A:440.00,A#:466.16,B:493.88};let audioContext,currentSequence=[];document.getElementById('xRange').addEventListener('input',function(){document.getElementById('xValue').textContent=this.value;});function convertToMusic(){const expr=document.getElementById('mathInput').value;const xMax=parseInt(document.getElementById('xRange').value);const values=[];for(let x=0;x<=xMax;x++){try{const result=evaluateExpression(expr,x);values.push(result);}catch(e){values.push(0);}}const musicNotes=values.map(value=>{const normalized=((value%2)+2)%2;const noteIndex=Math.floor(normalized*12)%12;return notes[noteIndex];});currentSequence=musicNotes;displayMusic(musicNotes,values);displayScale();}function evaluateExpression(expr,x){const safeExpr=expr.replace(/x/g,x).replace(/pi/g,Math.PI).replace(/sin/g,'Math.sin').replace(/cos/g,'Math.cos').replace(/tan/g,'Math.tan').replace(/sqrt/g,'Math.sqrt').replace(/log/g,'Math.log');return eval(safeExpr);}function displayMusic(musicNotes,values){const display=document.getElementById('musicDisplay');display.innerHTML=\`<h4>Generated Music Sequence (\${musicNotes.length} notes)</h4><div>\${musicNotes.map((note,i)=>\`<span class="note" onclick="playNote('\${note}')" title="Value: \${values[i].toFixed(3)}">\${note}</span>\`).join('')}</div>\`;}function displayScale(){const scale=document.getElementById('scaleDisplay');scale.innerHTML=\`<h4>Musical Scale</h4>\${notes.map(note=>\`<span class="scale-note" onclick="playNote('\${note}')">\${note}</span>\`).join('')}\`;}function playNote(note){if(!audioContext){audioContext=new(window.AudioContext||window.webkitAudioContext)();}const oscillator=audioContext.createOscillator();const gainNode=audioContext.createGain();oscillator.connect(gainNode);gainNode.connect(audioContext.destination);oscillator.frequency.setValueAtTime(frequencies[note],audioContext.currentTime);oscillator.type='sine';gainNode.gain.setValueAtTime(0.3,audioContext.currentTime);gainNode.gain.exponentialRampToValueAtTime(0.01,audioContext.currentTime+0.5);oscillator.start(audioContext.currentTime);oscillator.stop(audioContext.currentTime+0.5);}function playSequence(){if(currentSequence.length===0){alert('Please convert an expression first!');return;}let index=0;const playNext=()=>{if(index<currentSequence.length){playNote(currentSequence[index]);setTimeout(playNext,300);index++;}};playNext();}</script></body></html>`;
            }

            generatePythonDrawingHTML() {
                return `<!DOCTYPE html><html><head><title>Python Drawing Engine</title><style>body{font-family:'Segoe UI',sans-serif;background:#0b0e14;color:#e6f0ff;padding:20px;margin:0;}.drawing-engine{display:grid;grid-template-columns:1fr 1fr;gap:20px;height:90vh;}.code-panel{background:#0f1523;border:1px solid #1e2b46;border-radius:12px;padding:20px;}.canvas-panel{background:#0f1523;border:1px solid #1e2b46;border-radius:12px;padding:20px;text-align:center;}.code-area{width:100%;height:60%;padding:15px;background:rgba(6,255,165,0.1);border:2px solid #06ffa5;border-radius:8px;color:#e6f0ff;font-family:monospace;font-size:14px;resize:vertical;border:none;outline:none;}canvas{border:2px solid #54f0b8;border-radius:8px;background:white;}.controls{margin:15px 0;display:flex;gap:10px;flex-wrap:wrap;}.example-btn{background:rgba(84,240,184,0.2);color:#54f0b8;border:1px solid #54f0b8;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:12px;}</style></head><body><div class="drawing-engine"><div class="code-panel"><h3>🐍 Python Drawing Code</h3><textarea id="pythonCode" class="code-area"># Python Turtle Drawing (Simulated)
import turtle as t

# Set up
t.speed(5)
t.color('blue')

# Draw a flower
for i in range(8):
    t.circle(50)
    t.right(45)

# Move and draw stem
t.right(90)
t.forward(100)
t.backward(100)
t.left(90)

print("Flower drawing complete!")</textarea><div class="controls"><button class="btn" onclick="runPythonDrawing()" style="background:#06ffa5;color:#0b0e14;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;font-weight:bold;">🎨 Draw</button><button class="btn" onclick="clearCanvas()" style="background:#ff6b6b;color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;font-weight:bold;">🗑 Clear</button></div><div style="display:flex;gap:5px;flex-wrap:wrap;"><button class="example-btn" onclick="loadExample('flower')">🌸 Flower</button><button class="example-btn" onclick="loadExample('spiral')">🌀 Spiral</button><button class="example-btn" onclick="loadExample('star')">⭐ Star</button><button class="example-btn" onclick="loadExample('square')">⬜ Square</button></div></div><div class="canvas-panel"><h3>🎨 Drawing Canvas</h3><canvas id="drawingCanvas" width="400" height="400"></canvas><div id="output" style="margin-top:15px;padding:15px;background:rgba(6,255,165,0.1);border-radius:8px;text-align:left;">Ready to draw! Click the Draw button.</div></div></div><script>let canvas,ctx,turtle={x:200,y:200,angle:90,penDown:true,color:'black',speed:5};function initCanvas(){canvas=document.getElementById('drawingCanvas');ctx=canvas.getContext('2d');turtle={x:200,y:200,angle:90,penDown:true,color:'black',speed:5};ctx.clearRect(0,0,canvas.width,canvas.height);ctx.strokeStyle='black';ctx.lineWidth=2;ctx.lineCap='round';}function runPythonDrawing(){const code=document.getElementById('pythonCode').value;const output=document.getElementById('output');initCanvas();let logs=[];const mockTurtle={forward:function(distance){const radians=turtle.angle*Math.PI/180;const newX=turtle.x+Math.cos(radians)*distance;const newY=turtle.y-Math.sin(radians)*distance;if(turtle.penDown){ctx.beginPath();ctx.moveTo(turtle.x,turtle.y);ctx.lineTo(newX,newY);ctx.stroke();}turtle.x=newX;turtle.y=newY;},backward:function(distance){this.forward(-distance);},right:function(angle){turtle.angle-=angle;},left:function(angle){turtle.angle+=angle;},circle:function(radius,steps=36){const stepAngle=360/steps;for(let i=0;i<steps;i++){this.forward(2*Math.PI*radius/steps);this.right(stepAngle);}},color:function(newColor){turtle.color=newColor;ctx.strokeStyle=newColor;},speed:function(newSpeed){turtle.speed=newSpeed;},penup:function(){turtle.penDown=false;},pendown:function(){turtle.penDown=true;}};try{const processedCode=code.replace(/import turtle as t/g,'').replace(/t\\./g,'turtle.').replace(/turtle\\./g,'mockTurtle.');const originalLog=console.log;console.log=(...args)=>logs.push(args.join(' '));eval(processedCode);console.log=originalLog;output.innerHTML=logs.length>0?\`<div style="color:#54f0b8;">Output:</div>\${logs.map(log=>\`<div>\${log}</div>\`).join('')}\`:'<div style="color:#54f0b8;">Drawing completed successfully!</div>';}catch(error){output.innerHTML=\`<div style="color:#ff6b6b;">Error: \${error.message}</div>\`;}}function clearCanvas(){initCanvas();document.getElementById('output').innerHTML='Canvas cleared. Ready for new drawing!';}function loadExample(type){const examples={flower:\`# Beautiful Flower Pattern
import turtle as t

t.speed(8)
t.color('red')

# Draw petals
for i in range(8):
    t.circle(50)
    t.right(45)

# Draw stem
t.color('green')
t.right(90)
t.forward(120)

print("Beautiful flower drawn!")\`,spiral:\`# Colorful Spiral
import turtle as t

t.speed(10)
colors = ['red', 'blue', 'green', 'purple', 'orange']

for i in range(100):
    t.color(colors[i % len(colors)])
    t.forward(i * 2)
    t.right(91)

print("Spiral complete!")\`,star:\`# Five-pointed Star
import turtle as t

t.speed(6)
t.color('gold')

for i in range(5):
    t.forward(100)
    t.right(144)

print("Star drawn!")\`,square:\`# Nested Squares
import turtle as t

t.speed(7)
t.color('blue')

for size in [20, 40, 60, 80, 100]:
    for i in range(4):
        t.forward(size)
        t.right(90)
    t.penup()
    t.goto(turtle.x - 10, turtle.y - 10)
    t.pendown()

print("Nested squares complete!")\`};document.getElementById('pythonCode').value=examples[type];runPythonDrawing();}initCanvas();</script></body></html>`;
            }

            generateTestPatterns(dashboard) {
                // Generate test patterns based on dashboard type
                const patterns = [];

                if (dashboard.id.includes('tier4')) {
                    patterns.push({
                        type: 'collaboration',
                        agents: Math.floor(Math.random() * 5) + 2,
                        complexity: Math.random()
                    });
                } else if (dashboard.id.includes('beat')) {
                    patterns.push({
                        type: 'rhythm',
                        bpm: Math.floor(Math.random() * 60) + 80,
                        complexity: Math.random()
                    });
                } else if (dashboard.id.includes('world')) {
                    patterns.push({
                        type: 'simulation',
                        entities: Math.floor(Math.random() * 900) + 100,
                        complexity: Math.random()
                    });
                }

                return patterns;
            }

            setupWebSocket() {
                try {
                    this.websocket = new WebSocket('ws://localhost:8765');

                    this.websocket.onopen = () => {
                        document.getElementById('connectionStatus').textContent = 'Connected';
                        document.getElementById('connectionStatus').className = 'status-indicator status-connected';

                        // Register this dashboard master
                        this.sendWebSocketMessage('DASHBOARD_REGISTER', {
                            dashboard_type: 'master_control',
                            capabilities: ['dashboard_management', 'nucleus_control', 'system_monitoring']
                        });
                    };

                    this.websocket.onclose = () => {
                        document.getElementById('connectionStatus').textContent = 'Disconnected';
                        document.getElementById('connectionStatus').className = 'status-indicator status-disconnected';

                        // Attempt reconnection
                        setTimeout(() => this.setupWebSocket(), 5000);
                    };

                    this.websocket.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleWebSocketMessage(message);
                        } catch (e) {
                            console.error('WebSocket message parsing error:', e);
                        }
                    };

                } catch (e) {
                    console.error('WebSocket setup failed:', e);
                }
            }

            sendWebSocketMessage(type, data) {
                if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                    return false;
                }

                const message = {
                    type: this.getMessageTypeId(type),
                    dashboard_id: 'nexus_master_control',
                    data: data,
                    timestamp: Date.now()
                };

                this.websocket.send(JSON.stringify(message));
                return true;
            }

            getMessageTypeId(type) {
                const types = {
                    'UTILITY_DATA': 0,
                    'TEST_COMMAND': 1,
                    'TEST_RESULT': 2,
                    'ENGINE_STATUS': 3,
                    'DASHBOARD_REGISTER': 4,
                    'METRICS_REQUEST': 5,
                    'CONTROL_COMMAND': 6
                };
                return types[type] || 0;
            }

            handleWebSocketMessage(message) {
                const typeNames = ['UTILITY_DATA', 'TEST_COMMAND', 'TEST_RESULT', 'ENGINE_STATUS', 'DASHBOARD_REGISTER', 'METRICS_REQUEST', 'CONTROL_COMMAND'];
                const typeName = typeNames[message.type] || 'UNKNOWN';

                switch (message.type) {
                    case 2: // TEST_RESULT
                        this.handleTestResult(message.data);
                        break;
                    case 3: // ENGINE_STATUS
                        this.handleEngineStatus(message.data);
                        break;
                    case 5: // METRICS_REQUEST (response)
                        this.handleMetricsResponse(message.data);
                        break;
                }
            }

            handleTestResult(data) {
                this.addLogEntry(`Test result: ${JSON.stringify(data).slice(0, 100)}...`, 'success');

                // Update dashboard performance if applicable
                if (this.currentDashboard && data.dashboard_id === this.currentDashboard.id) {
                    this.currentDashboard.performance = data.success_score || 0.0;
                    this.currentDashboard.lastTest = new Date();
                }
            }

            handleEngineStatus(data) {
                this.addLogEntry(`Engine status: ${data.status || 'unknown'}`, 'info');
            }

            handleMetricsResponse(data) {
                this.updateMetricsDisplay(data);
            }

            startMetricsUpdates() {
                setInterval(() => {
                    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        this.sendWebSocketMessage('METRICS_REQUEST', { type: 'system_status' });
                    }
                }, 5000);
            }

            updateMetricsDisplay(metrics) {
                const content = document.getElementById('metricsContent');
                content.innerHTML = '';

                for (const [key, value] of Object.entries(metrics)) {
                    const item = document.createElement('div');
                    item.className = 'metric-item';

                    const label = document.createElement('span');
                    label.textContent = key.replace(/_/g, ' ').toUpperCase();

                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'metric-value';
                    valueSpan.textContent = value;

                    item.appendChild(label);
                    item.appendChild(valueSpan);
                    content.appendChild(item);
                }
            }

            addLogEntry(message, type = 'info') {
                const log = document.getElementById('learningLog');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;

                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;

                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;

                // Limit log entries
                while (log.children.length > 100) {
                    log.removeChild(log.firstChild);
                }

                // Trigger glyph reaction based on log type
                if (this.glyphReactions) {
                    const logRect = log.getBoundingClientRect();
                    const reactionType = type === 'success' ? 'success' :
                                       type === 'error' ? 'error' :
                                       type === 'warning' ? 'action' : 'hover';

                    this.glyphReactions.createCustomReaction(
                        logRect.right - 30,
                        logRect.top + 20,
                        reactionType
                    );
                }
            }

            startLearning() {
                if (this.learningActive) {
                    this.stopLearning();
                    return;
                }

                this.learningActive = true;
                document.getElementById('learningStatus').textContent = 'Learning Active';
                document.getElementById('learningStatus').classList.add('learning-active');

                this.addLogEntry('🧠 NEXUS Learning System activated', 'success');
                this.addLogEntry('🔄 Training will cycle through all available demos', 'info');

                // Start comprehensive training cycle
                this.learningInterval = setInterval(() => {
                    this.runComprehensiveTraining();
                }, 3000); // Test every 3 seconds for faster feedback

                // Also start glyph training
                this.glyphLearningInterval = setInterval(() => {
                    this.runGlyphTraining();
                }, 5000); // Glyph training every 5 seconds
            }

            stopLearning() {
                this.learningActive = false;
                document.getElementById('learningStatus').textContent = 'Learning Stopped';
                document.getElementById('learningStatus').classList.remove('learning-active');

                if (this.learningInterval) {
                    clearInterval(this.learningInterval);
                }

                if (this.glyphLearningInterval) {
                    clearInterval(this.glyphLearningInterval);
                }

                this.addLogEntry('🛑 NEXUS learning system stopped', 'warning');
            }

            runComprehensiveTraining() {
                // Get ALL dashboards, prioritize working ones
                const allDashboards = Array.from(this.dashboards.values());
                const workingDashboards = allDashboards.filter(d => d.status === 'working');
                const testDashboards = workingDashboards.length > 0 ? workingDashboards : allDashboards;

                if (testDashboards.length === 0) {
                    this.addLogEntry('⚠️ No dashboards available for training', 'warning');
                    return;
                }

                const randomDashboard = testDashboards[Math.floor(Math.random() * testDashboards.length)];

                try {
                    // Simulate comprehensive testing without WebSocket dependency
                    this.simulateTrainingSession(randomDashboard);
                } catch (error) {
                    this.addLogEntry(`❌ Training error on ${randomDashboard.name}: ${error.message}`, 'error');
                }
            }

            simulateTrainingSession(dashboard) {
                // Simulate different types of training based on dashboard type
                const trainingTypes = {
                    'utility': ['performance_test', 'load_test', 'functionality_test'],
                    'test': ['integration_test', 'stress_test', 'compatibility_test'],
                    'hybrid': ['complex_scenario', 'multi_system_test', 'edge_case_test'],
                    'story': ['narrative_flow', 'character_consistency', 'plot_coherence'],
                    'keeper': ['agent_behavior', 'memory_integrity', 'recursive_stability'],
                    'broken': ['repair_attempt', 'diagnostic_scan', 'recovery_test']
                };

                const tests = trainingTypes[dashboard.type] || ['basic_functionality'];
                const randomTest = tests[Math.floor(Math.random() * tests.length)];

                // Simulate test execution
                const success = Math.random() > 0.3; // 70% success rate
                const score = success ? 0.6 + (Math.random() * 0.4) : Math.random() * 0.5;

                // Update dashboard performance
                dashboard.performance = (dashboard.performance + score) / 2;
                dashboard.lastTest = new Date();

                // Log results
                const resultType = success ? 'success' : 'warning';
                this.addLogEntry(`${success ? '✅' : '⚠️'} ${dashboard.name}: ${randomTest} - Score: ${(score * 100).toFixed(1)}%`, resultType);

                // Trigger visual feedback
                if (this.glyphReactions) {
                    const x = 100 + Math.random() * (window.innerWidth - 200);
                    const y = 100 + Math.random() * (window.innerHeight - 200);
                    const glyphType = success ? 'success' : 'error';
                    this.glyphReactions.createCustomReaction(x, y, glyphType, `${dashboard.name} tested`);
                }

                // Occasionally load the dashboard being tested
                if (Math.random() < 0.2) { // 20% chance to actually load
                    this.loadDashboard(dashboard.id);
                    this.addLogEntry(`🎯 Auto-loaded ${dashboard.name} for inspection`, 'info');
                }
            }

            runGlyphTraining() {
                if (!window.nexus) return;

                // Spawn random environmental events and glyphs for training
                const trainingActions = [
                    () => {
                        window.nexus.spawnEnvironmentalEvent("flux_surge",
                            {x: Math.random() * 20, y: Math.random() * 20},
                            5 + Math.random() * 10,
                            15 + Math.random() * 20,
                            { falloff: ['linear', 'smooth', 'ring'][Math.floor(Math.random() * 3)] }
                        );
                        this.addLogEntry('🌊 Training: Environmental event spawned', 'info');
                    },
                    () => {
                        window.nexus.spawnRandomCoolGlyph();
                        this.addLogEntry('✨ Training: Coolset glyph applied', 'info');
                    },
                    () => {
                        // Simulate system stress test
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                if (this.glyphReactions) {
                                    this.glyphReactions.createCustomReaction(
                                        Math.random() * window.innerWidth,
                                        Math.random() * window.innerHeight,
                                        ['action', 'success', 'learning'][Math.floor(Math.random() * 3)]
                                    );
                                }
                            }, i * 200);
                        }
                        this.addLogEntry('⚡ Training: Stress testing glyph reactions', 'info');
                    }
                ];

                const randomAction = trainingActions[Math.floor(Math.random() * trainingActions.length)];
                randomAction();
            }
        }

        // Global functions for UI controls
        function toggleMetrics() {
            console.log('📊 Toggling metrics panel');
            const panel = document.getElementById('metricsPanel');
            panel.classList.toggle('visible');

            // Trigger glyph reaction
            if (window.dashboardMaster?.glyphReactions) {
                window.dashboardMaster.glyphReactions.createCustomReaction(
                    window.innerWidth - 150,
                    100,
                    'action',
                    'Metrics Toggle'
                );
            }
        }

        function debugEducational() {
            console.log('🔧 Debug educational button clicked');
            if (window.dashboardMaster) {
                window.dashboardMaster.addLogEntry('🔧 Running educational dashboard debug...', 'info');
                const result = window.dashboardMaster.debugEducationalDashboards();
                console.log('Debug result:', result);
            } else {
                console.log('❌ Dashboard master not available');
            }
        }

        function startLearning() {
            console.log('🎯 Start learning button clicked');
            if (window.dashboardMaster) {
                window.dashboardMaster.startLearning();
            }
        }

        function reloadDashboard() {
            console.log('🔄 Reload dashboard clicked');
            const frame = document.getElementById('dashboardFrame');
            if (frame && frame.src) {
                frame.src = frame.src;

                // Trigger glyph reaction
                if (window.dashboardMaster?.glyphReactions) {
                    const frameRect = frame.getBoundingClientRect();
                    window.dashboardMaster.glyphReactions.createCustomReaction(
                        frameRect.left + frameRect.width / 2,
                        frameRect.top + 50,
                        'action',
                        'Reloaded'
                    );
                }
            }
        }

        function testDashboard() {
            console.log('🧪 Test dashboard clicked');
            if (window.dashboardMaster && window.dashboardMaster.currentDashboard) {
                const dashboard = window.dashboardMaster.currentDashboard;
                const testData = {
                    dashboard_id: dashboard.id,
                    test_patterns: window.dashboardMaster.generateTestPatterns(dashboard)
                };
                window.dashboardMaster.sendWebSocketMessage('TEST_COMMAND', testData);
                window.dashboardMaster.addLogEntry(`Manual test started for ${dashboard.name}`, 'info');

                // Trigger glyph reaction
                if (window.dashboardMaster.glyphReactions) {
                    window.dashboardMaster.glyphReactions.createCustomReaction(
                        window.innerWidth / 2,
                        200,
                        'learning',
                        'Testing Started'
                    );
                }
            }
        }

        function repairDashboard() {
            console.log('🔧 Repair dashboard clicked');
            if (window.dashboardMaster && window.dashboardMaster.currentDashboard) {
                const dashboard = window.dashboardMaster.currentDashboard;
                window.dashboardMaster.addLogEntry(`Attempting to repair ${dashboard.name}...`, 'warning');

                // This would trigger repair logic - for now just reload
                setTimeout(() => {
                    reloadDashboard();
                    dashboard.status = 'working'; // Optimistically mark as working
                    window.dashboardMaster.populateDashboardLists();
                    window.dashboardMaster.addLogEntry(`Repair attempt completed for ${dashboard.name}`, 'success');

                    // Trigger success glyph reaction
                    if (window.dashboardMaster.glyphReactions) {
                        window.dashboardMaster.glyphReactions.createCustomReaction(
                            window.innerWidth / 2,
                            200,
                            'success',
                            'Repair Complete'
                        );
                    }
                }, 2000);
            }
        }

        function spawnRandomGlyph() {
            console.log('✨ Spawning random coolset glyph');
            if (window.nexus) {
                window.nexus.spawnRandomCoolGlyph();

                // Extra visual feedback
                if (window.dashboardMaster?.glyphReactions) {
                    window.dashboardMaster.glyphReactions.createCustomReaction(
                        window.innerWidth / 2,
                        200,
                        'action',
                        'Coolset Activated!'
                    );
                }
            }
        }

        function showGlyphCatalog() {
            console.log('📋 Showing glyph catalog');
            if (window.nexus && window.nexus.coolGlyphs) {
                // Create catalog popup
                const catalog = document.createElement('div');
                catalog.style.cssText = `
                    position: fixed; top: 10%; left: 10%; width: 80%; height: 80%;
                    background: #0f1523; border: 2px solid #54f0b8; border-radius: 12px;
                    padding: 20px; overflow-y: auto; z-index: 10001; color: #e6f0ff;
                    font-family: 'Segoe UI', sans-serif;
                `;

                let catalogHTML = '<h2>🌟 Coolset Glyph Catalog</h2><div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">';

                for (const [id, glyph] of Object.entries(window.nexus.coolGlyphs)) {
                    const typeColor = {
                        'Emotional': '#ff69b4',
                        'Mechanical': '#54f0b8',
                        'Temporal': '#ffc107',
                        'Worldshift': '#9d4edd'
                    }[glyph.type] || '#e6f0ff';

                    catalogHTML += `
                        <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 4px solid ${typeColor};">
                            <h3>${glyph.sigil} ${id.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}</h3>
                            <p style="color: ${typeColor}; font-weight: bold;">${glyph.type} • ${glyph.intensity}</p>
                            <p style="font-style: italic; margin: 10px 0;">${glyph.meaning}</p>
                            <div style="display: flex; gap: 5px; flex-wrap: wrap; margin: 10px 0;">
                                ${glyph.tags.map(tag => `<span style="background: rgba(84,240,184,0.2); padding: 2px 8px; border-radius: 12px; font-size: 11px;">${tag}</span>`).join('')}
                            </div>
                            <button onclick="applySpecificGlyph('${id}')" style="background: ${typeColor}; color: #0b0e14; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer;">Apply Glyph</button>
                        </div>
                    `;
                }

                catalogHTML += '</div><button onclick="this.parentNode.remove()" style="position: absolute; top: 20px; right: 20px; background: #ff4444; color: white; border: none; padding: 10px; border-radius: 50%; cursor: pointer; width: 40px; height: 40px;">✕</button>';
                catalog.innerHTML = catalogHTML;
                document.body.appendChild(catalog);

                // Visual feedback
                if (window.dashboardMaster?.glyphReactions) {
                    window.dashboardMaster.glyphReactions.createCustomReaction(
                        window.innerWidth / 2,
                        100,
                        'learning',
                        'Catalog Opened'
                    );
                }
            }
        }

        function applySpecificGlyph(glyphId) {
            console.log(`🎯 Applying specific glyph: ${glyphId}`);
            if (window.nexus) {
                const position = {
                    x: 5 + Math.random() * 10,
                    y: 5 + Math.random() * 10
                };
                window.nexus.applyGlyph(glyphId, null, position);
            }
        }

        // NEXUS Environmental Event System Integration
        class NexusEnvironmentalEventSystem {
            constructor(dashboardMaster) {
                this.dashboardMaster = dashboardMaster;
                this.events = [];
                this.glyphs = new Map();
                this.goldGlyphs = new Map(); // For kintsugi_field healing
                this.spatial = new SpatialHash(4); // For spatial queries
                this.tickCount = 0;
                this.stats = { applied: 0, ticks: 0, eventsSpawned: 0, eventsFinished: 0 };

                // Initialize the coolset glyph registry
                this.initializeCoolsetGlyphs();
            }

            initializeCoolsetGlyphs() {
                this.coolGlyphs = {
                    aurora_lattice: {
                        id: "aurora_lattice", meaning: "Refract the world into prismatic lanes",
                        type: "Worldshift", intensity: 0.70, roots: ["light","weave"],
                        tags: ["refract","prism","sky"], sigil: "⟡AUR-LT/Δ7"
                    },
                    keystone_memory: {
                        id: "keystone_memory", meaning: "Pin a moment; ease time-shear",
                        type: "Temporal", intensity: 0.65, roots: ["memory","lock"],
                        tags: ["anchor","recall","save"], sigil: "⌑KEY-MEM/Ω2"
                    },
                    echo_weaver: {
                        id: "echo_weaver", meaning: "Knit echoes; chain reactions",
                        type: "Mechanical", intensity: 0.60, roots: ["echo","knit"],
                        tags: ["chain","pulse","link"], sigil: "✱ECH-WEV/π3"
                    },
                    fathom_drift: {
                        id: "fathom_drift", meaning: "Sedate turbulence; deepen calm",
                        type: "Emotional", intensity: 0.55, roots: ["ocean","still"],
                        tags: ["depth","calm","abyss"], sigil: "≈FTH-DRF/∇1"
                    },
                    solaris_anchor: {
                        id: "solaris_anchor", meaning: "Fix noon; clear fog of time",
                        type: "Temporal", intensity: 0.75, roots: ["solar","bind"],
                        tags: ["sun","noon","fix"], sigil: "⊙SOL-ANC/Σ5"
                    },
                    umbra_veil: {
                        id: "umbra_veil", meaning: "Muffle agitation; hush paths",
                        type: "Worldshift", intensity: 0.60, roots: ["dark","hush"],
                        tags: ["shadow","hush","veil"], sigil: "◒UMB-VEL/μ4"
                    },
                    kintsugi_field: {
                        id: "kintsugi_field", meaning: "Mend broken states with golden seams",
                        type: "Emotional", intensity: 0.85, roots: ["break","bond"],
                        tags: ["mend","gold","heal"], sigil: "⚚KIN-FLD/ϕ8"
                    },
                    chronicle_bloom: {
                        id: "chronicle_bloom", meaning: "Seed archival sprouts that recall",
                        type: "Temporal", intensity: 0.50, roots: ["record","grow"],
                        tags: ["seed","archive","sprout"], sigil: "✿CHR-BLM/η1"
                    },
                    hearthbind: {
                        id: "hearthbind", meaning: "Gather nearby agents; raise warmth",
                        type: "Emotional", intensity: 0.65, roots: ["kin","hearth"],
                        tags: ["home","warm","gather"], sigil: "♨HRT-BND/τ4"
                    },
                    pale_comet: {
                        id: "pale_comet", meaning: "Emit streaked surges; leave trails",
                        type: "Mechanical", intensity: 0.70, roots: ["arc","streak"],
                        tags: ["trail","spark","burst"], sigil: "﹍PAL-CMT/γ6"
                    },
                    tessellate_choir: {
                        id: "tessellate_choir", meaning: "Quantize space; lock rhythm in tiles",
                        type: "Mechanical", intensity: 0.60, roots: ["tile","chord"],
                        tags: ["grid","resonance","sync"], sigil: "▦TES-CHO/λ3"
                    },
                    eventide_gate: {
                        id: "eventide_gate", meaning: "Open dusk thresholds between layers",
                        type: "Worldshift", intensity: 0.80, roots: ["limen","fade"],
                        tags: ["threshold","dusk","cross"], sigil: "⩚EVN-GTE/ψ9"
                    }
                };

                this.dashboardMaster?.addLogEntry('✨ Initialized 12 Coolset Glyphs with effect hooks', 'success');
            }

            // Apply glyph effects with full integration
            applyGlyph(glyphId, glyphInstance, position = {x: 10, y: 10}) {
                const glyph = this.coolGlyphs[glyphId];
                if (!glyph) {
                    this.dashboardMaster?.addLogEntry(`❌ Unknown glyph: ${glyphId}`, 'error');
                    return;
                }

                glyphInstance = glyphInstance || {
                    ...glyph,
                    position: position,
                    energyLevel: 1.0,
                    meta: {}
                };

                glyphInstance.meta = glyphInstance.meta || {};
                glyphInstance.position = glyphInstance.position || position;

                // Apply specific glyph effects
                this.applyGlyphEffect(glyphId, glyphInstance);

                // Store in goldGlyphs for kintsugi healing
                this.goldGlyphs.set(`${glyphId}_${Date.now()}`, glyphInstance);

                // Visual feedback
                if (this.dashboardMaster?.glyphReactions) {
                    const screenX = window.innerWidth * (glyphInstance.position.x / 20);
                    const screenY = window.innerHeight * (glyphInstance.position.y / 20);
                    this.dashboardMaster.glyphReactions.createCustomReaction(
                        screenX, screenY, 'action', glyph.sigil
                    );
                }

                this.dashboardMaster?.addLogEntry(`🌟 Applied ${glyph.sigil} at (${glyphInstance.position.x}, ${glyphInstance.position.y})`, 'success');
                return glyphInstance;
            }

            applyGlyphEffect(glyphId, glyph) {
                switch(glyphId) {
                    case 'aurora_lattice':
                        glyph.meta.refractive = true;
                        glyph.meta.spectrumBias = 0.25 + 0.5 * glyph.intensity;
                        this.spawnEnvironmentalEvent("storm", glyph.position, 9 + 6 * glyph.intensity, 28, {
                            shape: 'ring', ringInner: 3, falloff: 'ring', effects: ['storm','moisture']
                        });
                        break;

                    case 'keystone_memory':
                        glyph.meta.memoryAnchor = true;
                        glyph.meta.anchorStamp = Date.now();
                        this.spawnEnvironmentalEvent("memory_echo", glyph.position, 6, 20, { falloff: 'smooth' });
                        break;

                    case 'echo_weaver':
                        glyph.meta.echoChain = (glyph.meta.echoChain || 0) + 1;
                        this.spawnEnvironmentalEvent("flux_surge", glyph.position, 5, 16, { falloff: 'linear' });
                        break;

                    case 'fathom_drift':
                        glyph.meta.calmField = (glyph.meta.calmField || 0) + 0.4;
                        glyph.meta.moisture = Math.min(1, (glyph.meta.moisture||0) + 0.2);
                        break;

                    case 'solaris_anchor':
                        glyph.meta.timeNoon = true;
                        this.spawnEnvironmentalEvent("flux_surge", glyph.position, 7, 24, { falloff: 'smooth' });
                        break;

                    case 'umbra_veil':
                        glyph.meta.hushed = true;
                        glyph.meta.shadowBias = 0.3 + 0.4 * glyph.intensity;
                        glyph.meta.cooldowns = { ...(glyph.meta.cooldowns||{}), event: this.stats.ticks + 30 };
                        break;

                    case 'kintsugi_field':
                        glyph.meta.mended = true;
                        glyph.meta.goldSeam = (glyph.meta.goldSeam || 0) + 1;
                        // Heal nearby glyphs
                        this.healNearbyGlyphs(glyph.position, 6);
                        break;

                    case 'chronicle_bloom':
                        glyph.meta.archiveSeed = true;
                        glyph.meta.memoryAwakened = true;
                        this.spawnEnvironmentalEvent("memory_echo", glyph.position, 4, 14, { falloff: 'smooth' });
                        break;

                    case 'hearthbind':
                        glyph.meta.warmth = (glyph.meta.warmth || 0) + 0.5;
                        glyph.meta.lure = { strength: 0.6, radius: 10 };
                        break;

                    case 'pale_comet':
                        glyph.meta.streaks = (glyph.meta.streaks || 0) + 1;
                        this.spawnEnvironmentalEvent("flux_surge", glyph.position, 5, 10, { falloff: 'linear' });
                        break;

                    case 'tessellate_choir':
                        glyph.meta.quantized = true;
                        glyph.meta.resonance = (glyph.meta.resonance || 0) + 0.4;
                        break;

                    case 'eventide_gate':
                        glyph.meta.thresholdOpen = true;
                        this.spawnEnvironmentalEvent("storm", glyph.position, 8, 18, {
                            falloff: 'smooth', effects: ['storm']
                        });
                        break;
                }
            }

            healNearbyGlyphs(position, radius) {
                for (const [id, glyph] of this.goldGlyphs) {
                    const distance = Math.hypot(glyph.position.x - position.x, glyph.position.y - position.y);
                    if (distance <= radius && glyph.energyLevel < 1.0) {
                        glyph.energyLevel = (glyph.energyLevel * 0.5) + 0.6;
                        this.dashboardMaster?.addLogEntry(`💛 Kintsugi healed glyph ${id}`, 'success');
                    }
                }
            }

            // Demo function to spawn random coolset glyphs
            spawnRandomCoolGlyph() {
                const glyphIds = Object.keys(this.coolGlyphs);
                const randomId = glyphIds[Math.floor(Math.random() * glyphIds.length)];
                const position = {
                    x: Math.random() * 20,
                    y: Math.random() * 20
                };

                this.applyGlyph(randomId, null, position);
            }

            spawnEnvironmentalEvent(type, origin, radius, duration, options = {}) {
                const event = {
                    id: `evt_${Date.now()}_${Math.floor(Math.random()*1e6)}`,
                    type: type,
                    origin: origin,
                    radius: radius,
                    duration: duration,
                    elapsed: 0,
                    shape: options.shape || 'circle',
                    ringInner: options.ringInner || 0,
                    falloff: options.falloff || 'smooth'
                };

                this.events.push(event);
                this.stats.eventsSpawned++;

                this.dashboardMaster?.addLogEntry(`🌊 Spawned ${type} at (${origin.x}, ${origin.y}) r=${radius}`, 'info');

                // Create visual glyph reaction for the event
                if (this.dashboardMaster?.glyphReactions) {
                    const screenX = window.innerWidth * (origin.x / 20); // Scale to screen
                    const screenY = window.innerHeight * (origin.y / 20);
                    this.dashboardMaster.glyphReactions.createCustomReaction(screenX, screenY, 'action', `${type} spawned`);
                }

                return event.id;
            }

            updateEvents(deltaTime = 1) {
                this.tickCount++;
                this.stats.ticks++;

                const activeEvents = [];

                for (const event of this.events) {
                    event.elapsed += deltaTime;

                    if (event.elapsed < event.duration) {
                        activeEvents.push(event);

                        // Apply event effects to nearby glyphs
                        this.applyEventEffects(event);
                    } else {
                        // Event finished
                        this.stats.eventsFinished++;
                        this.dashboardMaster?.addLogEntry(`✨ Finished ${event.type} id=${event.id}`, 'success');

                        // Create completion reaction
                        if (this.dashboardMaster?.glyphReactions) {
                            const screenX = window.innerWidth * (event.origin.x / 20);
                            const screenY = window.innerHeight * (event.origin.y / 20);
                            this.dashboardMaster.glyphReactions.createCustomReaction(screenX, screenY, 'success');
                        }
                    }
                }

                this.events = activeEvents;
            }

            applyEventEffects(event) {
                // Simulate effect on virtual glyphs
                const affectedGlyphs = this.getGlyphsInRange(event);
                let effectsApplied = 0;

                for (const glyph of affectedGlyphs) {
                    const distance = Math.hypot(glyph.x - event.origin.x, glyph.y - event.origin.y);
                    const strength = this.calculateStrength(event, distance);

                    if (strength > 0) {
                        this.applyEffect(event.type, glyph, strength);
                        effectsApplied++;
                    }
                }

                if (effectsApplied > 0) {
                    this.stats.applied += effectsApplied;
                    this.dashboardMaster?.addLogEntry(`⚡ ${event.type} affected ${effectsApplied} glyphs`, 'info');
                }
            }

            calculateStrength(event, distance) {
                if (event.shape === 'circle') {
                    return Falloff[event.falloff](distance, event.radius);
                } else if (event.shape === 'ring') {
                    return Falloff.ring(distance, event.ringInner, event.radius);
                }
                return distance <= event.radius ? 1 : 0;
            }

            applyEffect(effectType, glyph, strength) {
                switch (effectType) {
                    case 'flux_surge':
                        glyph.energyLevel = (glyph.energyLevel || 0) + strength;
                        glyph.mutated = true;
                        break;
                    case 'storm':
                        glyph.energyLevel = (glyph.energyLevel || 1) * Math.max(0, 1 - 0.05 * strength);
                        glyph.weathered = true;
                        break;
                    case 'memory_echo':
                        glyph.memoryAwakened = true;
                        glyph.echoStrength = Math.max(glyph.echoStrength || 0, strength);
                        break;
                }
            }

            getGlyphsInRange(event) {
                // Generate some virtual glyphs for demonstration
                const glyphs = [];
                for (let i = 0; i < 10; i++) {
                    glyphs.push({
                        id: `glyph_${i}`,
                        x: event.origin.x + (Math.random() - 0.5) * event.radius * 2,
                        y: event.origin.y + (Math.random() - 0.5) * event.radius * 2,
                        energyLevel: Math.random(),
                        mutated: false,
                        weathered: false,
                        memoryAwakened: false
                    });
                }
                return glyphs;
            }

            scanGlyphEvents() {
                // Placeholder for your existing per-glyph logic
                for (const [id, glyph] of this.glyphs) {
                    if (glyph.mutated && Math.random() < 0.1) {
                        this.dashboardMaster?.addLogEntry(`🔬 Glyph ${id} mutation detected`, 'info');
                    }
                }
            }

            getStats() {
                return {
                    ...this.stats,
                    activeEvents: this.events.length,
                    totalGlyphs: this.glyphs.size,
                    tickCount: this.tickCount
                };
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            try {
                console.log('🧠 Initializing NEXUS Dashboard Master...');
                window.dashboardMaster = new NexusDashboardMaster();
                console.log('✅ NEXUS Dashboard Master initialized successfully');

                // Initialize Environmental Event System
                console.log('🌊 Initializing Environmental Event System...');
                window.nexus = new NexusEnvironmentalEventSystem(window.dashboardMaster);
                console.log('✅ Environmental Event System initialized');

                // Ensure glyph overlay exists
                setTimeout(() => {
                    if (!document.getElementById('glyphReactionOverlay')) {
                        console.log('🔧 Creating missing glyph overlay...');
                        const overlay = document.createElement('div');
                        overlay.className = 'glyph-reaction-overlay';
                        overlay.id = 'glyphReactionOverlay';
                        document.body.appendChild(overlay);
                    }

                    // Re-attach all event listeners
                    console.log('🔗 Re-attaching event listeners...');
                    window.dashboardMaster.reattachEventListeners();

                    // Add global mouse hover glyph reactions
                    document.addEventListener('mousemove', (e) => {
                        if (window.dashboardMaster?.glyphReactions && Math.random() < 0.02) {
                            window.dashboardMaster.glyphReactions.createCustomReaction(
                                e.clientX,
                                e.clientY,
                                'hover'
                            );
                        }
                    });
                }, 100);

                // Add initial log entries
                setTimeout(() => {
                    if (window.dashboardMaster) {
                        window.dashboardMaster.addLogEntry('🧠 NEXUS Dashboard Master Control initialized', 'success');
                        window.dashboardMaster.addLogEntry('💡 Click dashboards in sidebar to load them', 'info');
                        window.dashboardMaster.addLogEntry('🎯 Use "Start Learning" to activate nucleus self-testing', 'info');
                        window.dashboardMaster.addLogEntry('📊 Click "Metrics" to view system status', 'info');
                        window.dashboardMaster.addLogEntry('🌊 Environmental Event System ready for flux surges', 'success');
                        window.dashboardMaster.addLogEntry('✨ Glyph reactions active - move mouse for effects!', 'success');
                    }
                }, 500);

                // Start the environmental event loop (your flux surge demo)
                setTimeout(() => {
                    if (window.nexus) {
                        // Spawn a pulsing flux surge with ring falloff that echoes into memory events
                        window.nexus.spawnEnvironmentalEvent(
                            "flux_surge",
                            { x: 5, y: 5 },
                            8, // radius
                            30, // duration
                            { shape: 'ring', ringInner: 3, falloff: 'ring' }
                        );

                        // Drive simulation (fixed step)
                        const TICK_MS = 50;
                        setInterval(() => {
                            window.nexus.updateEvents(1);           // 1 logical tick
                            window.nexus.scanGlyphEvents?.();       // your existing per-glyph logic
                        }, TICK_MS);

                        window.dashboardMaster.addLogEntry('🔥 Flux surge environmental event started!', 'success');

                        // Demo some coolset glyphs
                        setTimeout(() => {
                            window.nexus.applyGlyph('aurora_lattice', null, {x: 8, y: 8});
                            setTimeout(() => window.nexus.applyGlyph('kintsugi_field', null, {x: 12, y: 6}), 1000);
                            setTimeout(() => window.nexus.applyGlyph('eventide_gate', null, {x: 15, y: 10}), 2000);
                            window.dashboardMaster.addLogEntry('🌟 Coolset glyph demonstration active!', 'success');
                        }, 3000);
                    }
                }, 2000);

            } catch (error) {
                console.error('❌ Initialization error:', error);

                // Show error overlay
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background: #dc3545; color: white; padding: 20px; border-radius: 8px;
                    z-index: 10000; max-width: 400px; text-align: center;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                `;
                errorDiv.innerHTML = `
                    <h2>⚠️ Initialization Error</h2>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p>Check browser console for details</p>
                    <button onclick="this.parentNode.remove()" style="margin-top: 10px; padding: 5px 10px; background: white; color: #dc3545; border: none; border-radius: 4px; cursor: pointer;">Close</button>
                `;
                document.body.appendChild(errorDiv);
            }
        });        // Add debugging info
        console.log('NEXUS Dashboard Master script loaded');

        // Test if buttons are accessible
        setTimeout(() => {
            const buttons = document.querySelectorAll('.control-btn');
            console.log(`Found ${buttons.length} control buttons`);

            buttons.forEach((btn, index) => {
                console.log(`Button ${index + 1}: ${btn.textContent} - onclick: ${btn.onclick ? 'set' : 'missing'}`);
            });
        }, 1000);
    </script>
</body>
</html>
