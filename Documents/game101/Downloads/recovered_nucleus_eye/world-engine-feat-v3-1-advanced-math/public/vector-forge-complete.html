<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vector Forge ‚Äî Complete Creative Development Suite</title>

  <!-- External Dependencies -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/three@0.160.0/build/three.module.js" type="module"></script>
  <script src="https://unpkg.com/lucide@0.263.1/dist/umd/lucide.js"></script>

  <!-- Import Maps -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <!-- Nexus Connector Integration -->
  <script src="nexus-widget-connector.js" data-widget-id="vector-forge" data-auto-connect="true" data-show-ui="false"></script>

  <style>
    :root {
      --primary-bg: #0a0a0f;
      --secondary-bg: #1a1a2e;
      --accent-bg: #16213e;
      --primary-text: #eee6ff;
      --accent-text: #667eea;
      --border-color: #2d3748;
      --success-color: #4CAF50;
      --warning-color: #ff9800;
      --error-color: #f44336;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--primary-bg);
      color: var(--primary-text);
      font-family: 'Segoe UI', system-ui, sans-serif;
      overflow: hidden;
    }

    /* Main Layout Grid */
    .forge-container {
      display: grid;
      grid-template-areas:
        "toolbar toolbar toolbar toolbar"
        "toolpanel viewport viewport rightpanel"
        "videofooter videofooter videofooter videofooter";
      grid-template-columns: 300px 1fr 1fr 250px;
      grid-template-rows: 60px 1fr 120px;
      height: 100vh;
      gap: 2px;
      background: var(--border-color);
    }

    /* Toolbar */
    .forge-toolbar {
      grid-area: toolbar;
      background: var(--secondary-bg);
      display: flex;
      align-items: center;
      padding: 0 20px;
      border-bottom: 1px solid var(--border-color);
      z-index: 100;
    }

    /* Tool Panel */
    .forge-toolpanel {
      grid-area: toolpanel;
      background: var(--secondary-bg);
      overflow-y: auto;
      border-right: 1px solid var(--border-color);
    }

    /* Main Viewport */
    .forge-viewport {
      grid-area: viewport;
      background: var(--primary-bg);
      position: relative;
      overflow: hidden;
    }

    /* Right Panel */
    .forge-rightpanel {
      grid-area: rightpanel;
      background: var(--secondary-bg);
      overflow-y: auto;
      border-left: 1px solid var(--border-color);
    }

    /* Video Footer */
    .forge-videofooter {
      grid-area: videofooter;
      background: var(--accent-bg);
      border-top: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      padding: 10px 20px;
    }

    /* Common UI Elements */
    .panel {
      background: rgba(26, 26, 46, 0.9);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin: 10px;
      overflow: hidden;
    }

    .panel-header {
      background: var(--accent-bg);
      padding: 10px 15px;
      border-bottom: 1px solid var(--border-color);
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .panel-content {
      padding: 15px;
    }

    .btn {
      background: var(--accent-bg);
      color: var(--primary-text);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 12px;
      margin: 2px;
    }

    .btn:hover {
      background: var(--accent-text);
      transform: translateY(-1px);
    }

    .btn.active {
      background: var(--accent-text);
      border-color: var(--accent-text);
    }

    .input {
      background: var(--primary-bg);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--primary-text);
      padding: 6px 10px;
      width: 100%;
      margin: 4px 0;
      font-size: 12px;
    }

    .slider {
      width: 100%;
      margin: 8px 0;
    }

    /* Canvas and 3D Elements */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #viewport-3d {
      position: absolute;
      inset: 0;
      z-index: 1;
    }

    #viewport-overlay {
      position: absolute;
      inset: 0;
      z-index: 2;
      pointer-events: none;
    }

    /* Status and Info Displays */
    .status-bar {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-family: monospace;
      z-index: 10;
    }

    .stats-display {
      background: rgba(0, 0, 0, 0.8);
      padding: 8px;
      border-radius: 4px;
      font-size: 11px;
      font-family: monospace;
      margin: 5px 0;
    }

    /* Video Controls */
    .video-controls {
      display: flex;
      align-items: center;
      gap: 15px;
      flex: 1;
    }

    .video-timeline {
      flex: 1;
      height: 4px;
      background: var(--border-color);
      border-radius: 2px;
      position: relative;
      cursor: pointer;
    }

    .video-progress {
      height: 100%;
      background: var(--accent-text);
      border-radius: 2px;
      width: 0%;
      transition: width 0.1s;
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      .forge-container {
        grid-template-areas:
          "toolbar toolbar toolbar"
          "viewport viewport rightpanel"
          "videofooter videofooter videofooter";
        grid-template-columns: 1fr 1fr 250px;
      }

      .forge-toolpanel {
        position: absolute;
        left: -300px;
        transition: left 0.3s ease;
        z-index: 50;
        width: 300px;
        height: calc(100vh - 180px);
      }

      .forge-toolpanel.visible {
        left: 0;
      }
    }

    /* Animation Keyframes */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .pulse {
      animation: pulse 2s infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .spin {
      animation: spin 1s linear infinite;
    }
  </style>
</head>

<body>
  <div class="forge-container">

    <!-- Toolbar -->
    <div class="forge-toolbar">
      <div style="display: flex; align-items: center; gap: 15px; flex: 1;">
        <h1 style="margin: 0; font-size: 18px; font-weight: 700; color: var(--accent-text);">
          üî• Vector Forge
        </h1>

        <div class="btn-group" style="display: flex; gap: 5px;">
          <button class="btn" id="btn-new">New</button>
          <button class="btn" id="btn-open">Open</button>
          <button class="btn" id="btn-save">Save</button>
          <button class="btn" id="btn-export">Export</button>
        </div>

        <div class="separator" style="width: 1px; height: 30px; background: var(--border-color);"></div>

        <div class="tool-modes" style="display: flex; gap: 5px;">
          <button class="btn active" id="mode-design">Design</button>
          <button class="btn" id="mode-3d">3D</button>
          <button class="btn" id="mode-code">Code</button>
          <button class="btn" id="mode-ai">AI</button>
        </div>

        <div style="flex: 1;"></div>

        <div class="nexus-status" style="display: flex; align-items: center; gap: 8px;">
          <div class="status-indicator pulse" style="width: 8px; height: 8px; background: var(--success-color); border-radius: 50%;"></div>
          <span style="font-size: 12px;">Nexus Connected</span>
        </div>

        <button class="btn" id="btn-toggle-panels">‚ò∞ Panels</button>
      </div>
    </div>

    <!-- Left Tool Panel -->
    <div class="forge-toolpanel" id="toolPanel">

      <!-- Entity Tools -->
      <div class="panel">
        <div class="panel-header">
          <span>üéØ Entities</span>
          <button class="btn" style="padding: 2px 6px;" id="btn-entities-collapse">‚àí</button>
        </div>
        <div class="panel-content" id="entities-content">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px;">
            <button class="btn" id="btn-add-cube">Cube</button>
            <button class="btn" id="btn-add-sphere">Sphere</button>
            <button class="btn" id="btn-add-cylinder">Cylinder</button>
            <button class="btn" id="btn-add-plane">Plane</button>
          </div>
          <button class="btn" id="btn-add-light" style="width: 100%;">Add Light</button>
          <button class="btn" id="btn-add-camera" style="width: 100%;">Add Camera</button>
          <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
            <button class="btn" id="btn-clear-scene" style="width: 100%; background: var(--error-color);">Clear Scene</button>
          </div>
        </div>
      </div>

      <!-- Transform Tools -->
      <div class="panel">
        <div class="panel-header">
          <span>üìê Transform</span>
          <button class="btn" style="padding: 2px 6px;" id="btn-transform-collapse">‚àí</button>
        </div>
        <div class="panel-content" id="transform-content">
          <div style="margin-bottom: 10px;">
            <label style="font-size: 11px; color: var(--accent-text);">Position</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px;">
              <input type="number" class="input" id="pos-x" placeholder="X" step="0.1">
              <input type="number" class="input" id="pos-y" placeholder="Y" step="0.1">
              <input type="number" class="input" id="pos-z" placeholder="Z" step="0.1">
            </div>
          </div>
          <div style="margin-bottom: 10px;">
            <label style="font-size: 11px; color: var(--accent-text);">Rotation</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px;">
              <input type="number" class="input" id="rot-x" placeholder="X" step="0.1">
              <input type="number" class="input" id="rot-y" placeholder="Y" step="0.1">
              <input type="number" class="input" id="rot-z" placeholder="Z" step="0.1">
            </div>
          </div>
          <div>
            <label style="font-size: 11px; color: var(--accent-text);">Scale</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px;">
              <input type="number" class="input" id="scale-x" placeholder="X" step="0.1" value="1">
              <input type="number" class="input" id="scale-y" placeholder="Y" step="0.1" value="1">
              <input type="number" class="input" id="scale-z" placeholder="Z" step="0.1" value="1">
            </div>
          </div>
        </div>
      </div>

      <!-- Material Tools -->
      <div class="panel">
        <div class="panel-header">
          <span>üé® Materials</span>
          <button class="btn" style="padding: 2px 6px;" id="btn-materials-collapse">‚àí</button>
        </div>
        <div class="panel-content" id="materials-content">
          <div style="margin-bottom: 10px;">
            <label style="font-size: 11px; color: var(--accent-text);">Color</label>
            <input type="color" class="input" id="material-color" value="#667eea">
          </div>
          <div style="margin-bottom: 10px;">
            <label style="font-size: 11px; color: var(--accent-text);">Roughness</label>
            <input type="range" class="slider" id="material-roughness" min="0" max="1" step="0.01" value="0.5">
            <span id="roughness-value" style="font-size: 11px;">0.5</span>
          </div>
          <div style="margin-bottom: 10px;">
            <label style="font-size: 11px; color: var(--accent-text);">Metalness</label>
            <input type="range" class="slider" id="material-metalness" min="0" max="1" step="0.01" value="0.0">
            <span id="metalness-value" style="font-size: 11px;">0.0</span>
          </div>
          <div style="margin-bottom: 10px;">
            <label style="font-size: 11px; color: var(--accent-text);">Emissive</label>
            <input type="range" class="slider" id="material-emissive" min="0" max="1" step="0.01" value="0.0">
            <span id="emissive-value" style="font-size: 11px;">0.0</span>
          </div>
          <button class="btn" id="btn-apply-material" style="width: 100%;">Apply Material</button>
        </div>
      </div>

      <!-- Audio Tools -->
      <div class="panel">
        <div class="panel-header">
          <span>üîä Audio</span>
          <button class="btn" style="padding: 2px 6px;" id="btn-audio-collapse">‚àí</button>
        </div>
        <div class="panel-content" id="audio-content">
          <button class="btn" id="btn-load-audio" style="width: 100%; margin-bottom: 5px;">Load Audio</button>
          <button class="btn" id="btn-record-audio" style="width: 100%; margin-bottom: 10px;">Record Audio</button>
          <div style="margin-bottom: 10px;">
            <label style="font-size: 11px; color: var(--accent-text);">Volume</label>
            <input type="range" class="slider" id="audio-volume" min="0" max="1" step="0.01" value="0.5">
            <span id="volume-value" style="font-size: 11px;">50%</span>
          </div>
          <div class="stats-display">
            <div>Status: <span id="audio-status">Ready</span></div>
            <div>Duration: <span id="audio-duration">--:--</span></div>
          </div>
        </div>
      </div>

    </div>

    <!-- Main Viewport -->
    <div class="forge-viewport">
      <canvas id="viewport-3d"></canvas>
      <canvas id="viewport-overlay"></canvas>

      <div class="status-bar">
        <div>FPS: <span id="fps-counter">--</span></div>
        <div>Objects: <span id="object-counter">0</span></div>
        <div>Mode: <span id="current-mode">Design</span></div>
      </div>
    </div>

    <!-- Right Properties Panel -->
    <div class="forge-rightpanel" id="rightPanel">

      <!-- Scene Hierarchy -->
      <div class="panel">
        <div class="panel-header">
          <span>üå≥ Scene</span>
          <button class="btn" style="padding: 2px 6px;" id="btn-scene-collapse">‚àí</button>
        </div>
        <div class="panel-content" id="scene-content">
          <div id="scene-hierarchy" style="font-size: 12px;">
            <div style="padding: 5px; background: var(--primary-bg); border-radius: 4px; margin: 2px 0;">
              üì∑ Main Camera
            </div>
            <div style="padding: 5px; background: var(--primary-bg); border-radius: 4px; margin: 2px 0;">
              üí° Ambient Light
            </div>
          </div>
        </div>
      </div>

      <!-- Properties -->
      <div class="panel">
        <div class="panel-header">
          <span>‚öôÔ∏è Properties</span>
          <button class="btn" style="padding: 2px 6px;" id="btn-properties-collapse">‚àí</button>
        </div>
        <div class="panel-content" id="properties-content">
          <div id="object-properties">
            <div style="text-align: center; padding: 20px; color: var(--border-color);">
              Select an object to view properties
            </div>
          </div>
        </div>
      </div>

      <!-- AI Assistant -->
      <div class="panel">
        <div class="panel-header">
          <span>ü§ñ AI Assistant</span>
          <button class="btn" style="padding: 2px 6px;" id="btn-ai-collapse">‚àí</button>
        </div>
        <div class="panel-content" id="ai-content">
          <textarea class="input" id="ai-query" placeholder="Ask AI about 3D modeling, code generation, or creative ideas..." style="height: 60px; resize: vertical;"></textarea>
          <button class="btn" id="btn-ask-ai" style="width: 100%; margin-top: 5px;">Ask AI</button>
          <div id="ai-response" style="margin-top: 10px; padding: 10px; background: var(--primary-bg); border-radius: 4px; display: none; font-size: 11px; max-height: 200px; overflow-y: auto;"></div>
        </div>
      </div>

      <!-- Performance Monitor -->
      <div class="panel">
        <div class="panel-header">
          <span>üìä Performance</span>
          <button class="btn" style="padding: 2px 6px;" id="btn-performance-collapse">‚àí</button>
        </div>
        <div class="panel-content" id="performance-content">
          <div class="stats-display">
            <div>Memory: <span id="memory-usage">0 MB</span></div>
            <div>Draw Calls: <span id="draw-calls">0</span></div>
            <div>Triangles: <span id="triangle-count">0</span></div>
            <div>Render Time: <span id="render-time">0ms</span></div>
          </div>
        </div>
      </div>

    </div>

    <!-- Video Footer Bar -->
    <div class="forge-videofooter">
      <div class="video-controls">
        <button class="btn" id="btn-record-screen">üî¥ Record</button>
        <button class="btn" id="btn-screenshot">üì∏ Capture</button>

        <div style="flex: 1; margin: 0 15px;">
          <div class="video-timeline" id="timeline">
            <div class="video-progress" id="progress"></div>
          </div>
        </div>

        <span id="time-display" style="font-size: 12px; font-family: monospace;">00:00 / 00:00</span>

        <button class="btn" id="btn-play-pause">‚ñ∂Ô∏è</button>
        <button class="btn" id="btn-stop">‚èπÔ∏è</button>

        <div style="display: flex; align-items: center; margin-left: 15px;">
          <span style="font-size: 11px; margin-right: 5px;">Vol:</span>
          <input type="range" id="master-volume" min="0" max="100" value="50" style="width: 80px;">
          <span id="volume-display" style="font-size: 11px; margin-left: 5px;">50%</span>
        </div>
      </div>
    </div>

  </div>

  <!-- File input for loading -->
  <input type="file" id="file-input" style="display: none;" accept=".obj,.fbx,.gltf,.glb,image/*,audio/*">

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/examples/loaders/GLTFLoader.js';
    import { OBJLoader } from 'three/examples/loaders/OBJLoader.js';

    //=======================================================================
    // VECTOR FORGE CORE ENGINE
    //=======================================================================

    class VectorForge {
      constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.selectedObject = null;
        this.objects = [];
        this.lights = [];

        // Performance tracking
        this.stats = {
          fps: 0,
          frameTime: 0,
          drawCalls: 0,
          triangles: 0,
          memory: 0
        };

        // Audio context
        this.audioContext = null;
        this.audioSources = [];
        this.mediaRecorder = null;
        this.recordedChunks = [];

        // Video recording
        this.screenRecorder = null;
        this.isRecording = false;

        // Nexus integration
        this.nexusConnected = false;
        this.nexusConnector = null;

        this.init();
      }

      async init() {
        this.setupScene();
        this.setupRenderer();
        this.setupControls();
        this.setupLighting();
        this.setupAudio();
        this.setupEventListeners();
        this.setupNexusIntegration();
        this.startRenderLoop();

        console.log('üî• Vector Forge initialized');
      }

      setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0a0a0f);

        this.camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        this.camera.position.set(5, 5, 5);
        this.camera.lookAt(0, 0, 0);
      }

      setupRenderer() {
        const canvas = document.getElementById('viewport-3d');
        this.renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          alpha: true
        });

        this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
      }

      setupControls() {
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.maxDistance = 100;
        this.controls.minDistance = 1;
      }

      setupLighting() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        ambientLight.name = 'Ambient Light';
        this.scene.add(ambientLight);
        this.lights.push(ambientLight);

        // Directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.name = 'Main Light';
        this.scene.add(directionalLight);
        this.lights.push(directionalLight);

        // Add ground plane
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshLambertMaterial({
          color: 0x1a1a2e,
          transparent: true,
          opacity: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.name = 'Ground';
        this.scene.add(ground);
        this.objects.push(ground);
      }

      async setupAudio() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          document.getElementById('audio-status').textContent = 'Ready';
        } catch (error) {
          console.warn('Audio context setup failed:', error);
          document.getElementById('audio-status').textContent = 'Error';
        }
      }

      setupNexusIntegration() {
        // Wait for Nexus connector to be available
        const checkNexus = () => {
          if (window.nexusConnector) {
            this.nexusConnector = window.nexusConnector;
            this.setupNexusHandlers();
          } else {
            setTimeout(checkNexus, 1000);
          }
        };
        checkNexus();
      }

      setupNexusHandlers() {
        const connector = this.nexusConnector;

        connector.on('connected', () => {
          this.nexusConnected = true;
          console.log('üîó Nexus Bridge connected to Vector Forge');
        });

        connector.on('queryResponse', (response) => {
          this.handleAIResponse(response);
        });

        connector.on('commandResponse', (response) => {
          this.handleNexusCommand(response);
        });
      }

      setupEventListeners() {
        // File operations
        document.getElementById('btn-new').addEventListener('click', () => this.newScene());
        document.getElementById('btn-open').addEventListener('click', () => this.openFile());
        document.getElementById('btn-save').addEventListener('click', () => this.saveScene());
        document.getElementById('btn-export').addEventListener('click', () => this.exportScene());

        // Entity creation
        document.getElementById('btn-add-cube').addEventListener('click', () => this.addCube());
        document.getElementById('btn-add-sphere').addEventListener('click', () => this.addSphere());
        document.getElementById('btn-add-cylinder').addEventListener('click', () => this.addCylinder());
        document.getElementById('btn-add-plane').addEventListener('click', () => this.addPlane());
        document.getElementById('btn-add-light').addEventListener('click', () => this.addLight());
        document.getElementById('btn-add-camera').addEventListener('click', () => this.addCamera());
        document.getElementById('btn-clear-scene').addEventListener('click', () => this.clearScene());

        // Material controls
        document.getElementById('material-roughness').addEventListener('input', (e) => {
          document.getElementById('roughness-value').textContent = e.target.value;
          this.updateSelectedMaterial();
        });

        document.getElementById('material-metalness').addEventListener('input', (e) => {
          document.getElementById('metalness-value').textContent = e.target.value;
          this.updateSelectedMaterial();
        });

        document.getElementById('material-emissive').addEventListener('input', (e) => {
          document.getElementById('emissive-value').textContent = e.target.value;
          this.updateSelectedMaterial();
        });

        document.getElementById('btn-apply-material').addEventListener('click', () => this.applyMaterial());

        // Transform controls
        ['pos-x', 'pos-y', 'pos-z', 'rot-x', 'rot-y', 'rot-z', 'scale-x', 'scale-y', 'scale-z'].forEach(id => {
          document.getElementById(id).addEventListener('input', () => this.updateSelectedTransform());
        });

        // Audio controls
        document.getElementById('btn-load-audio').addEventListener('click', () => this.loadAudio());
        document.getElementById('btn-record-audio').addEventListener('click', () => this.toggleAudioRecording());
        document.getElementById('audio-volume').addEventListener('input', (e) => {
          document.getElementById('volume-value').textContent = Math.round(e.target.value * 100) + '%';
        });

        // Video controls
        document.getElementById('btn-record-screen').addEventListener('click', () => this.toggleScreenRecording());
        document.getElementById('btn-screenshot').addEventListener('click', () => this.takeScreenshot());
        document.getElementById('btn-play-pause').addEventListener('click', () => this.togglePlayback());
        document.getElementById('btn-stop').addEventListener('click', () => this.stopPlayback());

        // AI Assistant
        document.getElementById('btn-ask-ai').addEventListener('click', () => this.askAI());
        document.getElementById('ai-query').addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.askAI();
          }
        });

        // Panel toggles
        document.getElementById('btn-toggle-panels').addEventListener('click', () => this.togglePanels());

        // Mode switches
        document.getElementById('mode-design').addEventListener('click', () => this.setMode('design'));
        document.getElementById('mode-3d').addEventListener('click', () => this.setMode('3d'));
        document.getElementById('mode-code').addEventListener('click', () => this.setMode('code'));
        document.getElementById('mode-ai').addEventListener('click', () => this.setMode('ai'));

        // Volume control
        document.getElementById('master-volume').addEventListener('input', (e) => {
          document.getElementById('volume-display').textContent = e.target.value + '%';
        });

        // Window resize
        window.addEventListener('resize', () => this.handleResize());

        // Object selection
        this.renderer.domElement.addEventListener('click', (event) => this.handleObjectSelection(event));
      }

      // Entity Creation Methods
      addCube() {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({ color: 0x667eea });
        const cube = new THREE.Mesh(geometry, material);

        cube.position.set(
          Math.random() * 4 - 2,
          0.5,
          Math.random() * 4 - 2
        );
        cube.castShadow = true;
        cube.receiveShadow = true;
        cube.name = `Cube_${this.objects.length}`;

        this.scene.add(cube);
        this.objects.push(cube);
        this.updateSceneHierarchy();
        this.updateStats();
      }

      addSphere() {
        const geometry = new THREE.SphereGeometry(0.5, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
        const sphere = new THREE.Mesh(geometry, material);

        sphere.position.set(
          Math.random() * 4 - 2,
          0.5,
          Math.random() * 4 - 2
        );
        sphere.castShadow = true;
        sphere.receiveShadow = true;
        sphere.name = `Sphere_${this.objects.length}`;

        this.scene.add(sphere);
        this.objects.push(sphere);
        this.updateSceneHierarchy();
        this.updateStats();
      }

      addCylinder() {
        const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
        const material = new THREE.MeshStandardMaterial({ color: 0xff9800 });
        const cylinder = new THREE.Mesh(geometry, material);

        cylinder.position.set(
          Math.random() * 4 - 2,
          0.5,
          Math.random() * 4 - 2
        );
        cylinder.castShadow = true;
        cylinder.receiveShadow = true;
        cylinder.name = `Cylinder_${this.objects.length}`;

        this.scene.add(cylinder);
        this.objects.push(cylinder);
        this.updateSceneHierarchy();
        this.updateStats();
      }

      addPlane() {
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshStandardMaterial({
          color: 0xf44336,
          side: THREE.DoubleSide
        });
        const plane = new THREE.Mesh(geometry, material);

        plane.position.set(
          Math.random() * 4 - 2,
          1,
          Math.random() * 4 - 2
        );
        plane.rotation.x = Math.random() * Math.PI;
        plane.castShadow = true;
        plane.receiveShadow = true;
        plane.name = `Plane_${this.objects.length}`;

        this.scene.add(plane);
        this.objects.push(plane);
        this.updateSceneHierarchy();
        this.updateStats();
      }

      addLight() {
        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(
          Math.random() * 10 - 5,
          5,
          Math.random() * 10 - 5
        );
        light.castShadow = true;
        light.name = `PointLight_${this.lights.length}`;

        // Add light helper
        const helper = new THREE.PointLightHelper(light, 0.5);
        light.add(helper);

        this.scene.add(light);
        this.lights.push(light);
        this.updateSceneHierarchy();
      }

      addCamera() {
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.set(
          Math.random() * 10 - 5,
          3,
          Math.random() * 10 - 5
        );
        camera.name = `Camera_${this.scene.children.filter(child => child.isCamera).length}`;

        // Add camera helper
        const helper = new THREE.CameraHelper(camera);
        camera.add(helper);

        this.scene.add(camera);
        this.updateSceneHierarchy();
      }

      clearScene() {
        // Remove all user-created objects
        const toRemove = [];
        this.scene.traverse((child) => {
          if (child.name && !['Ambient Light', 'Main Light', 'Ground'].includes(child.name)) {
            toRemove.push(child);
          }
        });

        toRemove.forEach(obj => {
          this.scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(mat => mat.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });

        this.objects = this.objects.filter(obj => ['Ground'].includes(obj.name));
        this.lights = this.lights.filter(light => ['Ambient Light', 'Main Light'].includes(light.name));
        this.selectedObject = null;

        this.updateSceneHierarchy();
        this.updateStats();
      }

      // Material and Transform Updates
      updateSelectedMaterial() {
        if (!this.selectedObject || !this.selectedObject.material) return;

        const material = this.selectedObject.material;
        material.roughness = parseFloat(document.getElementById('material-roughness').value);
        material.metalness = parseFloat(document.getElementById('material-metalness').value);

        const emissiveIntensity = parseFloat(document.getElementById('material-emissive').value);
        material.emissive.setHex(emissiveIntensity > 0 ? 0x667eea : 0x000000);
        material.emissiveIntensity = emissiveIntensity;
      }

      applyMaterial() {
        if (!this.selectedObject || !this.selectedObject.material) return;

        const color = document.getElementById('material-color').value;
        this.selectedObject.material.color.setHex(color.replace('#', '0x'));
        this.updateSelectedMaterial();
      }

      updateSelectedTransform() {
        if (!this.selectedObject) return;

        const posX = parseFloat(document.getElementById('pos-x').value) || 0;
        const posY = parseFloat(document.getElementById('pos-y').value) || 0;
        const posZ = parseFloat(document.getElementById('pos-z').value) || 0;

        const rotX = parseFloat(document.getElementById('rot-x').value) || 0;
        const rotY = parseFloat(document.getElementById('rot-y').value) || 0;
        const rotZ = parseFloat(document.getElementById('rot-z').value) || 0;

        const scaleX = parseFloat(document.getElementById('scale-x').value) || 1;
        const scaleY = parseFloat(document.getElementById('scale-y').value) || 1;
        const scaleZ = parseFloat(document.getElementById('scale-z').value) || 1;

        this.selectedObject.position.set(posX, posY, posZ);
        this.selectedObject.rotation.set(rotX, rotY, rotZ);
        this.selectedObject.scale.set(scaleX, scaleY, scaleZ);
      }

      // Audio Methods
      async loadAudio() {
        const input = document.getElementById('file-input');
        input.accept = 'audio/*';
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              const arrayBuffer = await file.arrayBuffer();
              const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);

              const source = this.audioContext.createBufferSource();
              source.buffer = audioBuffer;
              source.connect(this.audioContext.destination);

              this.audioSources.push(source);
              document.getElementById('audio-status').textContent = 'Loaded';
              document.getElementById('audio-duration').textContent = this.formatTime(audioBuffer.duration);

              console.log('Audio loaded:', file.name);
            } catch (error) {
              console.error('Audio loading failed:', error);
              document.getElementById('audio-status').textContent = 'Error';
            }
          }
        };
        input.click();
      }

      async toggleAudioRecording() {
        const btn = document.getElementById('btn-record-audio');

        if (!this.mediaRecorder) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            this.mediaRecorder = new MediaRecorder(stream);

            this.mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                this.recordedChunks.push(event.data);
              }
            };

            this.mediaRecorder.onstop = () => {
              const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });
              const url = URL.createObjectURL(blob);

              const a = document.createElement('a');
              a.href = url;
              a.download = `recording_${Date.now()}.wav`;
              a.click();

              this.recordedChunks = [];
            };

            this.mediaRecorder.start();
            btn.textContent = 'Stop Recording';
            document.getElementById('audio-status').textContent = 'Recording';
          } catch (error) {
            console.error('Audio recording failed:', error);
          }
        } else {
          this.mediaRecorder.stop();
          this.mediaRecorder = null;
          btn.textContent = 'Record Audio';
          document.getElementById('audio-status').textContent = 'Ready';
        }
      }

      // Video Methods
      async toggleScreenRecording() {
        const btn = document.getElementById('btn-record-screen');

        if (!this.isRecording) {
          try {
            const stream = await navigator.mediaDevices.getDisplayMedia({
              video: { mediaSource: 'screen' }
            });

            this.screenRecorder = new MediaRecorder(stream);
            this.recordedChunks = [];

            this.screenRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                this.recordedChunks.push(event.data);
              }
            };

            this.screenRecorder.onstop = () => {
              const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
              const url = URL.createObjectURL(blob);

              const a = document.createElement('a');
              a.href = url;
              a.download = `screen_recording_${Date.now()}.webm`;
              a.click();

              this.recordedChunks = [];
            };

            this.screenRecorder.start();
            this.isRecording = true;
            btn.textContent = '‚èπÔ∏è Stop Recording';
            btn.style.background = 'var(--error-color)';
          } catch (error) {
            console.error('Screen recording failed:', error);
          }
        } else {
          this.screenRecorder.stop();
          this.isRecording = false;
          btn.textContent = 'üî¥ Record';
          btn.style.background = 'var(--accent-bg)';
        }
      }

      takeScreenshot() {
        const canvas = this.renderer.domElement;
        const link = document.createElement('a');
        link.download = `screenshot_${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();
      }

      togglePlayback() {
        // Placeholder for timeline playback
        console.log('Toggle playback');
      }

      stopPlayback() {
        // Placeholder for stopping playback
        console.log('Stop playback');
      }

      // AI Integration
      askAI() {
        const query = document.getElementById('ai-query').value.trim();
        if (!query || !this.nexusConnector) {
          console.warn('No query or Nexus not connected');
          return;
        }

        const contextualQuery = `Vector Forge 3D Scene Context: ${this.objects.length} objects, current mode: ${document.getElementById('current-mode').textContent}. User question: ${query}`;

        this.nexusConnector.query(contextualQuery, (response) => {
          this.handleAIResponse(response);
        });

        document.getElementById('ai-query').value = '';
      }

      handleAIResponse(response) {
        const responseDiv = document.getElementById('ai-response');
        responseDiv.innerHTML = `<strong>AI:</strong> ${response.answer || response.message || 'No response'}`;
        responseDiv.style.display = 'block';
      }

      handleNexusCommand(response) {
        console.log('Nexus command response:', response);
      }

      // File Operations
      newScene() {
        this.clearScene();
        console.log('New scene created');
      }

      openFile() {
        const input = document.getElementById('file-input');
        input.accept = '.obj,.fbx,.gltf,.glb';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            this.loadModel(file);
          }
        };
        input.click();
      }

      async loadModel(file) {
        const loader = file.name.endsWith('.gltf') || file.name.endsWith('.glb') ?
          new GLTFLoader() : new OBJLoader();

        try {
          const url = URL.createObjectURL(file);
          const model = await new Promise((resolve, reject) => {
            loader.load(url, resolve, undefined, reject);
          });

          const object = model.scene || model;
          object.name = file.name;

          this.scene.add(object);
          this.objects.push(object);
          this.updateSceneHierarchy();
          this.updateStats();

          URL.revokeObjectURL(url);
          console.log('Model loaded:', file.name);
        } catch (error) {
          console.error('Model loading failed:', error);
        }
      }

      saveScene() {
        const sceneData = {
          objects: this.objects.map(obj => ({
            name: obj.name,
            position: obj.position.toArray(),
            rotation: obj.rotation.toArray(),
            scale: obj.scale.toArray(),
            type: obj.type
          })),
          lights: this.lights.map(light => ({
            name: light.name,
            position: light.position.toArray(),
            color: light.color.getHex(),
            intensity: light.intensity
          }))
        };

        const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `scene_${Date.now()}.json`;
        a.click();

        URL.revokeObjectURL(url);
      }

      exportScene() {
        // Export as GLTF
        import('three/examples/exporters/GLTFExporter.js').then(({ GLTFExporter }) => {
          const exporter = new GLTFExporter();
          exporter.parse(this.scene, (gltf) => {
            const blob = new Blob([JSON.stringify(gltf)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `scene_export_${Date.now()}.gltf`;
            a.click();

            URL.revokeObjectURL(url);
          });
        });
      }

      // UI Updates
      updateSceneHierarchy() {
        const hierarchy = document.getElementById('scene-hierarchy');
        hierarchy.innerHTML = '';

        this.scene.children.forEach(child => {
          if (child.name) {
            const div = document.createElement('div');
            div.style.cssText = 'padding: 5px; background: var(--primary-bg); border-radius: 4px; margin: 2px 0; cursor: pointer;';
            div.textContent = this.getObjectIcon(child) + ' ' + child.name;
            div.onclick = () => this.selectObject(child);
            hierarchy.appendChild(div);
          }
        });
      }

      getObjectIcon(object) {
        if (object.isCamera) return 'üì∑';
        if (object.isLight) return 'üí°';
        if (object.isMesh) {
          if (object.geometry.type === 'BoxGeometry') return 'üßä';
          if (object.geometry.type === 'SphereGeometry') return 'üîµ';
          if (object.geometry.type === 'CylinderGeometry') return 'ü•´';
          if (object.geometry.type === 'PlaneGeometry') return 'üìÑ';
          return 'üî∑';
        }
        return 'üì¶';
      }

      selectObject(object) {
        this.selectedObject = object;

        // Update transform inputs
        document.getElementById('pos-x').value = object.position.x.toFixed(2);
        document.getElementById('pos-y').value = object.position.y.toFixed(2);
        document.getElementById('pos-z').value = object.position.z.toFixed(2);
        document.getElementById('rot-x').value = object.rotation.x.toFixed(2);
        document.getElementById('rot-y').value = object.rotation.y.toFixed(2);
        document.getElementById('rot-z').value = object.rotation.z.toFixed(2);
        document.getElementById('scale-x').value = object.scale.x.toFixed(2);
        document.getElementById('scale-y').value = object.scale.y.toFixed(2);
        document.getElementById('scale-z').value = object.scale.z.toFixed(2);

        // Update material inputs if object has material
        if (object.material) {
          document.getElementById('material-color').value = '#' + object.material.color.getHexString();
          if (object.material.roughness !== undefined) {
            document.getElementById('material-roughness').value = object.material.roughness;
            document.getElementById('roughness-value').textContent = object.material.roughness;
          }
          if (object.material.metalness !== undefined) {
            document.getElementById('material-metalness').value = object.material.metalness;
            document.getElementById('metalness-value').textContent = object.material.metalness;
          }
        }

        console.log('Selected:', object.name);
      }

      handleObjectSelection(event) {
        const rect = this.renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
          ((event.clientX - rect.left) / rect.width) * 2 - 1,
          -((event.clientY - rect.top) / rect.height) * 2 + 1
        );

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.camera);

        const intersects = raycaster.intersectObjects(this.scene.children, true);
        if (intersects.length > 0) {
          this.selectObject(intersects[0].object);
        }
      }

      updateStats() {
        document.getElementById('object-counter').textContent = this.objects.length;

        let triangles = 0;
        this.scene.traverse((child) => {
          if (child.geometry) {
            if (child.geometry.index) {
              triangles += child.geometry.index.count / 3;
            } else {
              triangles += child.geometry.attributes.position.count / 3;
            }
          }
        });

        document.getElementById('triangle-count').textContent = Math.floor(triangles);
        document.getElementById('draw-calls').textContent = this.renderer.info.render.calls;

        // Estimate memory usage (rough calculation)
        const memory = (triangles * 36 + this.objects.length * 1024) / (1024 * 1024);
        document.getElementById('memory-usage').textContent = memory.toFixed(1) + ' MB';
      }

      setMode(mode) {
        document.querySelectorAll('[id^="mode-"]').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`mode-${mode}`).classList.add('active');
        document.getElementById('current-mode').textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
      }

      togglePanels() {
        const toolPanel = document.getElementById('toolPanel');
        const rightPanel = document.getElementById('rightPanel');

        toolPanel.classList.toggle('visible');
        rightPanel.classList.toggle('visible');
      }

      formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }

      handleResize() {
        const canvas = this.renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
      }

      startRenderLoop() {
        const animate = () => {
          requestAnimationFrame(animate);

          // Update controls
          this.controls.update();

          // Update stats
          this.stats.frameTime = performance.now();

          // Render scene
          this.renderer.render(this.scene, this.camera);

          // Update FPS counter
          this.stats.fps = Math.round(1000 / (performance.now() - this.stats.frameTime));
          document.getElementById('fps-counter').textContent = this.stats.fps;

          // Update render time
          document.getElementById('render-time').textContent = (performance.now() - this.stats.frameTime).toFixed(1) + 'ms';
        };

        animate();
      }
    }

    // Initialize Vector Forge
    const forge = new VectorForge();
    window.vectorForge = forge;

  </script>
</body>
</html>