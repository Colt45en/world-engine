<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Engine Studio - Integrated Workspace</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <style>
        :root {
            --bg: #0b0f14;
            --fg: #e6f0ff;
            --panel: #121824;
            --border: #2a3548;
            --accent: #7cdcff;
            --success: #18c08f;
            --warning: #e5c558;
            --error: #ff4d4f;
        }

        /* Comprehensive CSS reset to completely override user agent stylesheet */
        *, *::before, *::after {
            box-sizing: border-box !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        html, body {
            margin: 0 !important;
            padding: 0 !important;
            border: 0 !important;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif !important;
            background: var(--bg) !important;
            color: var(--fg) !important;
            overflow: hidden !important;
            width: 100% !important;
            height: 100% !important;
        }

        .studio-layout {
            display: grid;
            grid-template-areas:
                "header"
                "visual"
                "status";
            grid-template-rows: auto 1fr auto;
            grid-template-columns: 1fr;
            height: 100vh;
            gap: 8px;
            padding: 8px;
            overflow: hidden;
            position: relative; /* create a local stacking context */
        }

        .studio-header {
            grid-area: header;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .desktop-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .desktop-btn {
            padding: 6px 12px;
            background: var(--border);
            border: 1px solid var(--accent);
            border-radius: 4px;
            color: var(--fg);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .desktop-btn:hover {
            background: var(--accent);
            color: var(--bg);
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 12px 16px;
            color: var(--fg);
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .studio-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent);
        }

        .studio-controls {
            display: flex;
            gap: 8px;
        }

        .pipeline-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .pipeline-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .studio-btn {
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--fg);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .studio-btn:hover {
            background: var(--border);
        }

        /* LEXICON ENGINE UI FIXES */
        /* Fix overflow and visual feedback issues */

        /* Ensure proper z-index layering */
        .lexicon-engine-container {
            position: relative;
            z-index: 1;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 8px;
            max-height: calc(100vh - 200px); /* Prevent overflow behind buttons */
            overflow-y: auto;
        }

        /* Visual feedback for buttons */
        .math-btn, .action-btn, .desktop-btn {
            transition: all 0.2s ease;
            position: relative;
            z-index: 10; /* Ensure buttons stay on top */
        }

        .math-btn:hover, .action-btn:hover, .desktop-btn:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 4px 12px rgba(124, 220, 255, 0.3) !important;
            background: var(--accent) !important;
            color: var(--bg) !important;
        }

        .math-btn:active, .action-btn:active, .desktop-btn:active {
            transform: translateY(0) !important;
            box-shadow: 0 2px 6px rgba(124, 220, 255, 0.2) !important;
        }

        /* Mathematical Operations Panel Styles */
        .math-operations-panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 8px;
            padding: 16px;
            position: relative;
            z-index: 2;
        }

        .math-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .math-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .math-dimensions {
            background: var(--accent);
            color: var(--bg);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .math-operations-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            align-items: start;
        }

        .math-operation-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .math-operation-group label {
            font-size: 0.8rem;
            color: var(--accent);
            font-weight: 500;
            margin-bottom: 4px;
        }

        .math-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .math-state-display {
            grid-column: 1 / -1;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 12px;
            font-family: 'Courier New', monospace;
        }

        .math-current-state {
            font-size: 0.9rem;
            color: var(--success);
            margin-bottom: 8px;
            word-break: break-all;
        }

        .math-stability {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
        }

        .stability-indicator {
            font-size: 0.7rem;
        }

        .math-tests-section {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            padding-top: 8px;
            border-top: 1px solid var(--border);
        }

        .math-test-results {
            flex: 1;
            min-width: 100%;
            margin-top: 8px;
            padding: 8px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .math-test-results.show {
            display: block;
        }

        .math-test-results .test-pass {
            color: var(--success);
        }

        .math-test-results .test-fail {
            color: var(--error);
        }

        .math-test-results .test-info {
            color: var(--accent);
        }

        /* Add visual processing indicator */
        .processing-indicator {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            background: var(--panel);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(8px);
        }

        .processing-indicator.active {
            display: block;
            animation: pulse 1.5s infinite;
        }

        .processing-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top: 3px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Fix content area scrolling */
        .visual-workspace {
            position: relative;
            overflow-y: auto;
            max-height: calc(100vh - 160px);
            padding-right: 8px;
        }

        .visual-workspace::-webkit-scrollbar {
            width: 6px;
        }

        .visual-workspace::-webkit-scrollbar-track {
            background: var(--panel);
            border-radius: 3px;
        }

        .visual-workspace::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .visual-workspace::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Button feedback effects */
        @keyframes buttonPress {
            0% { transform: scale(1); }
            50% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }

        .button-pressed {
            animation: buttonPress 0.3s ease;
            background: var(--success) !important;
            border-color: var(--success) !important;
            color: white !important;
        }

        /* Visual feedback for processing */
        .processing-text {
            color: var(--accent);
            animation: pulse 1s infinite;
        }

        .result-highlight {
            background: rgba(124, 220, 255, 0.1);
            border: 1px solid var(--accent);
            border-left: 3px solid var(--accent);
            padding: 12px;
            margin: 4px 0;
            border-radius: 6px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideOut {
            0% {
                opacity: 1;
                transform: translateX(0);
            }
            100% {
                opacity: 0;
                transform: translateX(20px);
            }
        }
        /* END LEXICON ENGINE UI FIXES */

        /* Chat Toggle Button */
        .chat-toggle-btn {
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .chat-toggle-btn:hover {
            background: #5bb0ff;
            transform: translateY(-2px);
        }

        .chat-toggle-btn.active {
            background: var(--success);
        }

        /* Chat Popup Overlay */
        .chat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .chat-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .chat-popup {
            background: var(--panel);
            border: 2px solid var(--accent);
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            height: 70%;
            max-height: 500px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
            position: relative;
        }

        @keyframes slideIn {
            from {
                transform: scale(0.9) translateY(-20px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        .chat-header {
            background: var(--accent);
            color: white;
            padding: 12px 16px;
            border-radius: 10px 10px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
        }

        .chat-close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .chat-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .chat-content {
            flex: 1;
            padding: 16px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .studio-engine {
            grid-area: engine;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            position: relative;
        }

        .studio-visual {
            grid-area: visual;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden; /* Contain all content */
            min-height: 0; /* Allow proper shrinking in grid */
        }

        #ai-bot-controls {
            border-top: 1px solid var(--border);
            padding-top: 8px;
            margin-top: 8px;
        }

        #ai-bot-controls button {
            width: 100%;
            padding: 8px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 4px;
        }

        #ai-bot-controls button:last-child {
            background: var(--secondary);
            margin-bottom: 0;
        }

        #ai-bot-controls button:hover {
            opacity: 0.8;
        }

        /* Modern Chat Interface Styles */
        #chat-interface {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }

        .chat-messages {
            flex: 1;
            background: rgba(18, 24, 36, 0.5);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            overflow-y: auto;
            max-height: 200px;
            font-size: 13px;
            line-height: 1.4;
        }

        .welcome-message {
            color: var(--accent);
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 12px;
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            word-wrap: break-word;
        }

        .chat-message.user {
            background: rgba(74, 158, 255, 0.1);
            border-left: 3px solid var(--accent);
        }

        .chat-message.assistant {
            background: rgba(24, 192, 143, 0.1);
            border-left: 3px solid var(--success);
        }

        .chat-message.system {
            background: rgba(229, 197, 88, 0.1);
            border-left: 3px solid var(--warning);
            font-size: 12px;
        }

        .chat-input-container {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        #chat-input {
            flex: 1;
            padding: 8px 12px;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 13px;
        }

        #chat-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(74, 158, 255, 0.2);
        }

        .send-btn {
            padding: 8px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .send-btn:hover {
            background: #5bb0ff;
            transform: translateY(-1px);
        }

        .send-btn:active {
            transform: translateY(0);
        }

        /* System Health Dashboard */
        .system-health {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(18, 24, 36, 0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
        }

        .health-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .health-indicators {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .health-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .health-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--secondary);
            transition: all 0.3s ease;
        }

        .health-dot.active { background: var(--success); }
        .health-dot.warning { background: var(--warning); }
        .health-dot.error { background: var(--error); }

        .health-status {
            margin-left: auto;
            font-size: 11px;
            color: var(--secondary);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            flex: 1;
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .action-btn.primary {
            background: var(--accent);
            color: white;
        }

        .action-btn.secondary {
            background: var(--secondary);
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .action-btn:active {
            transform: translateY(0);
        }

        .btn-icon {
            font-size: 14px;
        }

        .btn-text {
            font-size: 11px;
        }

        /* Modern Recorder Interface Styles */
        .recorder-interface {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .recorder-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(18, 24, 36, 0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 13px;
        }

        .status-indicator {
            font-size: 12px;
            animation: none;
        }

        .status-indicator.recording {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .recorder-controls {
            display: flex;
            gap: 8px;
        }

        .recorder-btn {
            flex: 1;
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .recorder-btn.start {
            background: var(--success);
            color: white;
        }

        .recorder-btn.stop {
            background: var(--error);
            color: white;
        }

        .recorder-btn:disabled {
            background: var(--secondary);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .recorder-btn:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .recorder-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .info-label {
            color: var(--secondary);
        }

        #rec-duration {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: var(--accent);
        }

        .studio-visual > .engine-frame {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 4px;
            z-index: 1; /* just above canvas background */
            display: block;
        }

        .studio-recorder {
            grid-area: recorder;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }

        .studio-status {
            grid-area: status;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: #888;
        }

        .studio-visual > .section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--accent);
            border-bottom: 1px solid var(--border);
            padding-bottom: 8px;
            position: relative;
            z-index: 20; /* above everything for readability */
            background: var(--panel);
            pointer-events: none; /* don't interfere with interactions */
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border);
        }

        .status-dot.connected { background: var(--success); }
        .status-dot.error { background: var(--error); }
        .status-dot.warning { background: var(--warning); }

        /* Responsive design */
        @media (max-width: 1400px) {
            .studio-layout {
                grid-template-areas:
                    "header"
                    "visual"
                    "status";
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
                height: 100vh;
                overflow-y: auto;
            }

            .studio-visual {
                min-height: 400px;
                max-height: none;
                overflow-y: auto;
            }

            .studio-engine {
                min-height: 400px;
                overflow-y: auto;
            }
        }        /* Chat UI integration */
        #chat-ui {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Recorder UI integration */
        #recorder-ui {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-style: italic;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Audio Engine Styles */
        .audio-engine-overlay {
            z-index: 1100; /* Above other overlays */
        }

        .audio-engine-popup {
            width: 95%;
            max-width: 1000px;
            height: 80%;
            max-height: 700px;
        }

        .audio-engine-content {
            flex-direction: row;
            gap: 16px;
        }

        .audio-controls-panel {
            width: 300px;
            background: rgba(18, 24, 36, 0.5);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .audio-control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .audio-control-group .recorder-btn {
            width: 100%;
        }

        .audio-status-group {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
        }

        .semantic-state-display {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
        }

        .state-bars {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .state-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .state-bar label,
        .state-bar .state-label {
            width: 80px;
            font-weight: 500;
            color: var(--accent);
        }

        .bar-container {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--success));
            border-radius: 6px;
            transition: width 0.3s ease;
            position: absolute;
            left: 0;
            top: 0;
        }

        .state-bar span {
            width: 50px;
            text-align: right;
            font-family: monospace;
            color: var(--fg);
        }

        .audio-events {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
        }

        #audio-events-log {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px;
            font-size: 12px;
            max-height: 120px;
            overflow-y: auto;
        }

        .audio-events-empty {
            color: #888;
            text-align: center;
        }

        .audio-visualization-panel {
            flex: 1;
            background: rgba(18, 24, 36, 0.5);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }

        #audio-viz-canvas {
            width: 100%;
            height: 100%;
            background: #000;
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        /* Audio Engine Toggle Button */
        .audio-engine-toggle-btn {
            background: linear-gradient(135deg, #ff6b00, #ff8533);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .audio-engine-toggle-btn:hover {
            background: linear-gradient(135deg, #ff8533, #ffa366);
            transform: translateY(-2px);
        }

        .audio-engine-toggle-btn.active {
            background: var(--warning);
        }

        /* Idea Formation Visual Tracking */
        .studio-visual > .idea-formation-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* background layer inside .studio-visual */
            display: block;
            pointer-events: none;
            mix-blend-mode: screen;
        }

        .studio-visual > .idea-tracker {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(11, 15, 20, 0.9);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            z-index: 10; /* above canvas and iframe */
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .idea-formation-title {
            font-size: 11px;
            color: var(--accent);
            margin-bottom: 8px;
            font-weight: 600;
        }

        /* Enhanced 3D Visual Elements from Original Systems */
        .idea-flow-visual {
            width: 100%;
            height: 80px;
            background: radial-gradient(circle at center, rgba(124, 220, 255, 0.1) 0%, transparent 70%);
            border: 1px solid rgba(124, 220, 255, 0.2);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            perspective: 400px; /* Add 3D perspective */
        }

        .idea-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--accent);
            border-radius: 50%;
            opacity: 0.8;
            animation: ideaFlow3D 4s infinite linear;
            box-shadow: 0 0 8px currentColor; /* Add glow effect */
        }

        /* Enhanced 3D particle flow from RhythmCoder */
        @keyframes ideaFlow3D {
            0% {
                transform: translateY(0) translateX(0) translateZ(0) scale(0.3) rotateX(0deg);
                opacity: 0;
            }
            20% {
                opacity: 1;
                transform: translateY(10px) translateX(5px) translateZ(10px) scale(0.6) rotateX(45deg);
            }
            50% {
                transform: translateY(30px) translateX(15px) translateZ(20px) scale(1.2) rotateX(90deg);
            }
            80% {
                opacity: 1;
                transform: translateY(50px) translateX(-10px) translateZ(15px) scale(0.9) rotateX(135deg);
            }
            100% {
                transform: translateY(70px) translateX(0) translateZ(0) scale(0.1) rotateX(180deg);
                opacity: 0;
            }
        }

        /* Circular node system from FlowState IDE */
        .concept-nodes {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 8px;
            height: 60px;
            perspective: 600px;
        }

        .concept-node {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--border);
            position: absolute;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .concept-node:nth-child(1) {
            transform: translateX(-40px) translateY(-20px) translateZ(10px);
        }
        .concept-node:nth-child(2) {
            transform: translateX(-20px) translateY(10px) translateZ(-5px);
        }
        .concept-node:nth-child(3) {
            transform: translateX(20px) translateY(10px) translateZ(15px);
        }
        .concept-node:nth-child(4) {
            transform: translateX(40px) translateY(-20px) translateZ(-10px);
        }

        .concept-node.active {
            background: var(--accent);
            box-shadow: 0 0 15px rgba(124, 220, 255, 0.8), 0 4px 12px rgba(0, 0, 0, 0.4);
            transform: scale(1.5) translateZ(25px);
        }

        /* 3D connection lines */
        .concept-connection {
            position: absolute;
            height: 2px;
            background: linear-gradient(to right,
                transparent,
                rgba(124, 220, 255, 0.6),
                rgba(124, 220, 255, 0.8),
                rgba(124, 220, 255, 0.6),
                transparent);
            top: 50%;
            width: 30px;
            opacity: 0;
            transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
        }

        .concept-connection.active {
            opacity: 1;
            animation: connectionPulse 2s ease-in-out infinite;
        }

        @keyframes connectionPulse {
            0%, 100% {
                transform: scaleX(1) translateZ(0);
                filter: brightness(1);
            }
            50% {
                transform: scaleX(1.2) translateZ(5px);
                filter: brightness(1.5);
            }
        }

        /* Enhanced 3D landscape with elevation */
        .idea-landscape {
            width: 100%;
            height: 120px;
            background: linear-gradient(180deg,
                rgba(15, 18, 22, 0.9) 0%,
                rgba(124, 220, 255, 0.05) 30%,
                rgba(124, 220, 255, 0.15) 100%);
            border: 1px solid rgba(124, 220, 255, 0.3);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            perspective: 800px;
            transform-style: preserve-3d;
        }

        .idea-elevation {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 70%;
            background: linear-gradient(45deg,
                rgba(124, 220, 255, 0.1) 0%,
                rgba(124, 220, 255, 0.25) 15%,
                rgba(24, 192, 143, 0.15) 30%,
                rgba(124, 220, 255, 0.2) 45%,
                rgba(87, 203, 255, 0.18) 60%,
                rgba(124, 220, 255, 0.12) 75%,
                rgba(124, 220, 255, 0.05) 100%);
            clip-path: polygon(
                0 100%,
                8% 75%,
                15% 85%,
                25% 60%,
                35% 70%,
                45% 45%,
                55% 55%,
                65% 35%,
                75% 50%,
                85% 25%,
                95% 40%,
                100% 20%,
                100% 100%);
            transform: rotateX(15deg) translateZ(10px);
            animation: elevationShift 8s ease-in-out infinite;
        }

        @keyframes elevationShift {
            0%, 100% {
                transform: rotateX(15deg) translateZ(10px) scaleY(1);
            }
            50% {
                transform: rotateX(10deg) translateZ(15px) scaleY(1.1);
            }
        }

        /* Floating code patterns from RhythmCoder */
        .floating-pattern {
            position: absolute;
            border-radius: 50%;
            opacity: 0.4;
            mix-blend-mode: screen;
            transform-origin: center;
            animation: float3D 20s infinite ease-in-out;
            pointer-events: none;
        }

        @keyframes float3D {
            0%, 100% {
                transform: translate3d(0, 0, 0) rotate(0deg) scale(1);
            }
            25% {
                transform: translate3d(15px, -20px, 10px) rotate(90deg) scale(1.1);
            }
            50% {
                transform: translate3d(-10px, -35px, 20px) rotate(180deg) scale(0.9);
            }
            75% {
                transform: translate3d(-25px, -15px, 5px) rotate(270deg) scale(1.05);
            }
        }

        /* Cognitive processing indicators */
        .cognitive-stage-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            opacity: 0;
            animation: cognitiveProcess 3s ease-in-out infinite;
        }

        @keyframes cognitiveProcess {
            0%, 100% { opacity: 0; transform: scale(0.5) translateZ(0); }
            20% { opacity: 0.3; transform: scale(0.7) translateZ(2px); }
            40% { opacity: 0.6; transform: scale(1) translateZ(5px); }
            60% { opacity: 0.9; transform: scale(1.2) translateZ(8px); }
            80% { opacity: 0.6; transform: scale(1) translateZ(5px); }
        }        /* Looking Down Visual Effect */
        .studio-visual > .perspective-viewer {
            position: absolute;
            top: 160px;
            right: 20px;
            width: 250px;
            height: 180px;
            background: rgba(11, 15, 20, 0.95);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            z-index: 10; /* above canvas and iframe */
            backdrop-filter: blur(15px);
            transform: perspective(800px) rotateX(15deg);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            pointer-events: auto;
        }

        .perspective-title {
            font-size: 12px;
            color: var(--accent);
            margin-bottom: 12px;
            font-weight: 600;
            text-align: center;
        }

        .idea-landscape {
            width: 100%;
            height: 120px;
            background: linear-gradient(180deg, transparent 0%, rgba(124, 220, 255, 0.05) 50%, rgba(124, 220, 255, 0.15) 100%);
            border: 1px solid rgba(124, 220, 255, 0.3);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .idea-elevation {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 60%;
            background: linear-gradient(45deg,
                rgba(124, 220, 255, 0.1) 0%,
                rgba(124, 220, 255, 0.2) 25%,
                rgba(24, 192, 143, 0.1) 50%,
                rgba(124, 220, 255, 0.15) 75%,
                rgba(124, 220, 255, 0.05) 100%);
            clip-path: polygon(0 100%, 20% 60%, 40% 80%, 60% 40%, 80% 70%, 100% 30%, 100% 100%);
        }

        .thought-ripples {
            position: absolute;
            top: 20px;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translateX(-50%);
        }

        .ripple {
            position: absolute;
            border: 1px solid var(--accent);
            border-radius: 50%;
            opacity: 0;
            animation: rippleEffect 2s infinite ease-out;
        }

        .ripple:nth-child(1) { animation-delay: 0s; }
        .ripple:nth-child(2) { animation-delay: 0.5s; }
        .ripple:nth-child(3) { animation-delay: 1s; }

        @keyframes rippleEffect {
            0% {
                width: 4px;
                height: 4px;
                top: 18px;
                left: 18px;
                opacity: 1;
            }
            100% {
                width: 40px;
                height: 40px;
                top: 0;
                left: 0;
                opacity: 0;
            }
        }

        /* Enhanced 3D Cognitive Processing Animations */
        .pulsing {
            animation: cognitivepulse 2s ease-in-out infinite;
        }

        @keyframes cognitivepulse {
            0%, 100% {
                transform: translateZ(0px) scale(1);
                box-shadow: 0 0 5px var(--accent);
            }
            50% {
                transform: translateZ(20px) scale(1.1);
                box-shadow: 0 0 20px var(--accent);
            }
        }

        /* Enhanced 3D Depth Layers */
        .depth-layer {
            border-radius: 50%;
            mix-blend-mode: screen;
            animation: depthFloat 8s ease-in-out infinite;
        }

        @keyframes depthFloat {
            0%, 100% { transform: translateZ(0px) scale(1) rotateY(0deg); }
            25% { transform: translateZ(-5px) scale(1.02) rotateY(90deg); }
            50% { transform: translateZ(-10px) scale(1.05) rotateY(180deg); }
            75% { transform: translateZ(-5px) scale(1.02) rotateY(270deg); }
        }

        /* Enhanced Floating Patterns from RhythmCoder */
        .floating-pattern {
            border-radius: 50%;
            position: absolute;
            animation: floatingPatternMove 25s linear infinite;
            box-shadow: 0 0 10px currentColor;
            mix-blend-mode: screen;
        }

        @keyframes floatingPatternMove {
            0% {
                transform: translateZ(0px) rotateX(0deg) rotateY(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.8;
                transform: translateZ(10px) rotateX(45deg) rotateY(45deg);
            }
            50% {
                transform: translateZ(20px) rotateX(180deg) rotateY(180deg);
                opacity: 1;
            }
            90% {
                opacity: 0.6;
                transform: translateZ(10px) rotateX(315deg) rotateY(315deg);
            }
            100% {
                transform: translateZ(0px) rotateX(360deg) rotateY(360deg);
                opacity: 0;
            }
        }

        /* Enhanced Concept Node 3D Effects */
        .concept-node.active {
            animation: nodeActivation 3s ease-out forwards;
        }

        @keyframes nodeActivation {
            0% {
                transform: translateZ(0px) scale(1);
                box-shadow: 0 0 5px var(--accent);
            }
            30% {
                transform: translateZ(15px) scale(1.3);
                box-shadow: 0 0 20px var(--accent);
            }
            100% {
                transform: translateZ(8px) scale(1.1);
                box-shadow: 0 0 15px var(--accent);
            }
        }

        /* Enhanced Connection Lines with 3D Depth */
        .node-connection.active {
            animation: connectionPulse 2s ease-in-out infinite;
        }

        @keyframes connectionPulse {
            0%, 100% {
                box-shadow: 0 0 2px var(--accent);
                transform: translateZ(0px);
            }
            50% {
                box-shadow: 0 0 10px var(--accent);
                transform: translateZ(5px);
            }
        }

        /* Query Interface Styles */
        .query-mode-selector {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
            padding: 4px;
            background: rgba(18, 24, 36, 0.5);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .query-mode-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: var(--secondary);
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s ease;
            min-width: 60px;
        }

        .query-mode-btn:hover {
            background: rgba(100, 255, 218, 0.1);
            color: var(--accent);
        }

        .query-mode-btn.active {
            background: var(--accent);
            color: var(--dark);
            box-shadow: 0 0 8px rgba(100, 255, 218, 0.3);
        }

        .math-buttons {
            display: none;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
            padding: 6px;
            background: rgba(18, 24, 36, 0.3);
            border-radius: 6px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }

        .math-buttons.show {
            display: flex;
        }

        .math-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            background: rgba(100, 255, 218, 0.1);
            color: var(--accent);
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .math-btn:hover {
            background: var(--accent);
            color: var(--dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(100, 255, 218, 0.4);
        }

        .math-btn.active {
            background: var(--accent);
            color: var(--dark);
            box-shadow: 0 0 6px rgba(100, 255, 218, 0.6);
        }

        /* Multimodal Particle Animation */
        @keyframes modalityFloat {
            0% {
                transform: translateY(0px) scale(0.5);
                opacity: 0;
            }
            20% {
                opacity: 1;
                transform: translateY(-10px) scale(1);
            }
            80% {
                transform: translateY(-40px) scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: translateY(-60px) scale(0.8);
                opacity: 0;
            }
        }

        .multimodal-particle {
            z-index: 1000;
            pointer-events: none;
            text-shadow: 0 0 4px currentColor;
        }

        /* Download Button Styles */
        .download-btn {
            background: linear-gradient(45deg, var(--accent), #45b7d1);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: 8px;
            font-weight: 500;
        }

        .download-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(100, 255, 218, 0.3);
            background: linear-gradient(45deg, #45b7d1, var(--accent));
        }

        .download-btn:active {
            transform: translateY(0);
        }

        /* Multimodal Control Panel */
        .multimodal-panel {
            background: rgba(18, 24, 36, 0.4);
            border: 1px solid rgba(100, 255, 218, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            display: none;
        }

        .multimodal-panel.show {
            display: block;
        }

        .modality-selector {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .modality-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            background: rgba(100, 255, 218, 0.1);
            color: var(--accent);
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .modality-btn:hover {
            background: rgba(100, 255, 218, 0.2);
            transform: translateY(-1px);
        }

        .modality-btn.active {
            background: var(--accent);
            color: var(--dark);
            box-shadow: 0 0 4px rgba(100, 255, 218, 0.4);
        }

        .scale-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            font-size: 11px;
        }

        .scale-control {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .scale-label {
            color: var(--secondary);
            font-size: 9px;
            display: flex;
            justify-content: space-between;
        }

        .scale-slider {
            width: 100%;
            height: 4px;
            background: rgba(100, 255, 218, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .scale-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 4px rgba(100, 255, 218, 0.5);
        }

        .similarity-display {
            margin-top: 8px;
            font-size: 10px;
        }

        .similarity-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            color: var(--secondary);
        }

        .similarity-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="studio-layout">

        <!-- Header -->
        <div class="studio-header">
            <div class="studio-title">🌍 World Engine Studio</div>
            <div class="studio-controls">
                <button id="chat-toggle" class="chat-toggle-btn">
                    💬 <span>AI Chat</span>
                </button>
                <button id="recorder-toggle" class="chat-toggle-btn">
                    🎙️ <span>Recorder</span>
                </button>
                <button id="audio-engine-toggle" class="chat-toggle-btn">
                    🎵 <span>Audio Engine</span>
                </button>
                <button class="pipeline-btn" onclick="StudioBridge.getInstance().openPipelineCanvas()">
                    🌱 Pipeline Canvas
                </button>
                <button class="studio-btn" onclick="StudioBridge.getInstance().showHelp()">Help</button>
                <button class="studio-btn" onclick="StudioBridge.getInstance().exportData()">Export</button>
                <button class="studio-btn" onclick="StudioBridge.getInstance().reset()">Reset</button>
            </div>
            <div class="desktop-controls">
                <div class="status-indicator" title="LLEX System Active"></div>
                <button id="math-panel-toggle" class="desktop-btn" onclick="toggleMathPanel()">
                    🧮 Math Engine
                </button>
                <button id="save-session-btn" class="desktop-btn">
                    💾 Save Session
                </button>
                <button id="export-llex-btn" class="desktop-btn">
                    📤 Export LLEX
                </button>
                <button id="import-llex-btn" class="desktop-btn">
                    📥 Import LLEX
                </button>
                <button id="notification-btn" class="desktop-btn">
                    🔔 Notify
                </button>
            </div>
        </div>

        <!-- Chat Popup Overlay -->
        <div id="chat-overlay" class="chat-overlay">
            <div class="chat-popup">
                <div class="chat-header">
                    <span>💬 AI Command Center</span>
                    <button id="chat-close" class="chat-close-btn">✕</button>
                </div>
                <div class="chat-content">
                    <!-- Modern Chat Interface -->
                    <div id="chat-interface">
                        <div id="chat-messages" class="chat-messages">
                            <div class="welcome-message">
                                🌍 <strong>World Engine Studio</strong><br>
                                <small>Type commands or chat with AI • /help for commands</small>
                            </div>
                        </div>

                        <div class="chat-input-container">
                            <!-- Query Mode Selector -->
                            <div class="query-mode-selector">
                                <button class="query-mode-btn active" data-mode="semantic">💬 Text</button>
                                <button class="query-mode-btn" data-mode="dsl">🔬 DSL</button>
                                <button class="query-mode-btn" data-mode="json">📋 JSON</button>
                                <button class="query-mode-btn" data-mode="math">🧮 Math</button>
                                <button class="query-mode-btn" data-mode="multimodal">🎭 Modal</button>
                            </div>

                            <!-- Multimodal Control Panel -->
                            <div class="multimodal-panel" id="multimodalPanel">
                                <div class="modality-selector">
                                    <button class="modality-btn active" data-modality="text">📝 Text</button>
                                    <button class="modality-btn" data-modality="image">🖼️ Image</button>
                                    <button class="modality-btn" data-modality="audio">🎵 Audio</button>
                                    <button class="modality-btn" data-modality="video">🎬 Video</button>
                                </div>

                                <div class="scale-controls">
                                    <div class="scale-control">
                                        <div class="scale-label">
                                            <span>Spatial (s)</span>
                                            <span id="spatialValue">0.50</span>
                                        </div>
                                        <input type="range" class="scale-slider" id="spatialSlider" min="0" max="1" step="0.01" value="0.5">
                                    </div>

                                    <div class="scale-control">
                                        <div class="scale-label">
                                            <span>Temporal (τ)</span>
                                            <span id="temporalValue">0.50</span>
                                        </div>
                                        <input type="range" class="scale-slider" id="temporalSlider" min="0" max="1" step="0.01" value="0.5">
                                    </div>

                                    <div class="scale-control">
                                        <div class="scale-label">
                                            <span>Rate (r)</span>
                                            <span id="rateValue">0.50</span>
                                        </div>
                                        <input type="range" class="scale-slider" id="rateSlider" min="0" max="1" step="0.01" value="0.5">
                                    </div>
                                </div>

                                <div class="similarity-display" id="similarityDisplay">
                                    <div class="similarity-item">
                                        <span>🎬 Video:</span>
                                        <span class="similarity-value" id="videoSim">0.000</span>
                                    </div>
                                    <div class="similarity-item">
                                        <span>🖼️ Image:</span>
                                        <span class="similarity-value" id="imageSim">0.000</span>
                                    </div>
                                    <div class="similarity-item">
                                        <span>🎵 Audio:</span>
                                        <span class="similarity-value" id="audioSim">0.000</span>
                                    </div>
                                    <div class="similarity-item">
                                        <span>📝 Text:</span>
                                        <span class="similarity-value" id="textSim">0.000</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Mathematical Operation Buttons (hidden by default) -->
                            <div class="math-buttons" id="mathButtons">
                                <button class="math-btn" data-op="ALIGN">ALIGN</button>
                                <button class="math-btn" data-op="PROJ">PROJ</button>
                                <button class="math-btn" data-op="REFINE">REFINE</button>
                                <button class="math-btn" data-op="GRAPH">GRAPH</button>
                                <button class="math-btn" data-op="POLY">POLY</button>
                                <button class="math-btn" data-op="IRONY">IRONY</button>
                                <button class="math-btn" data-op="DIRECTION">DIRECTION</button>
                                <button class="math-btn" data-op="RECOMPUTE">RECOMPUTE</button>
                            </div>

                            <input type="text" id="chat-input" placeholder="Type message or /command..." maxlength="500">
                            <button id="send-btn" class="send-btn">Send</button>
                        </div>
                    </div>

                    <!-- System Health Dashboard -->
                    <div class="system-health">
                        <div class="health-title">System Status</div>
                        <div class="health-indicators">
                            <div class="status-item">
                                <div class="status-dot" id="audio-engine-health"></div>
                                <span>Audio</span>
                                <div class="health-status" id="audio-status-text">Ready</div>
                            </div>
                            <div class="health-item">
                                <div class="health-dot" id="engine-health"></div>
                                <span>Engine</span>
                                <div class="health-status" id="engine-status-text">Ready</div>
                            </div>
                            <div class="health-item">
                                <div class="health-dot" id="pipeline-health"></div>
                                <span>Pipeline</span>
                                <div class="health-status" id="pipeline-status-text">Standby</div>
                            </div>
                            <div class="health-item">
                                <div class="health-dot" id="recorder-health"></div>
                                <span>Recorder</span>
                                <div class="health-status" id="recorder-status-text">Ready</div>
                            </div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="action-buttons">
                        <button id="pipeline-btn" class="action-btn primary">
                            <span class="btn-icon">🧠</span>
                            <span class="btn-text">Process Pipeline</span>
                        </button>
                        <button id="canvas-btn" class="action-btn secondary">
                            <span class="btn-icon">🎨</span>
                            <span class="btn-text">Open Canvas</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Audio Engine Popup Overlay -->
        <div id="audio-engine-overlay" class="chat-overlay audio-engine-overlay">
            <div class="chat-popup audio-engine-popup">
                <div class="chat-header">
                    <span>🎵 Audio Semantic Engine</span>
                    <button id="audio-engine-close" class="chat-close-btn">✕</button>
                </div>
                <div class="chat-content audio-engine-content">
                    <!-- Audio Controls Panel -->
                    <div class="audio-controls-panel">
                        <div class="section-title">🎛️ Audio Controls</div>

                        <!-- Start/Stop Controls -->
                        <div class="audio-control-group">
                            <button id="audio-start-btn" class="recorder-btn start">
                                <span>🎙️</span>
                                <span>Start Audio Analysis</span>
                            </button>
                            <button id="audio-stop-btn" class="recorder-btn stop" disabled>
                                <span>⏹️</span>
                                <span>Stop Analysis</span>
                            </button>
                        </div>

                        <!-- Status Display -->
                        <div class="audio-status-group">
                            <div class="info-item">
                                <span class="info-label">Status:</span>
                                <span id="audio-status-text">Ready</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Tempo:</span>
                                <span id="audio-tempo">120 BPM</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Active Ops:</span>
                                <span id="audio-operators">None</span>
                            </div>
                        </div>

                        <!-- Semantic State Display -->
                        <div class="semantic-state-display">
                            <div class="section-title">🧠 Semantic State</div>
                            <div class="state-bars">
                                <div class="state-bar">
                                    <span class="state-label">Polarity</span>
                                    <div class="bar-container">
                                        <div class="bar-fill" id="polarity-bar"></div>
                                    </div>
                                    <span id="polarity-value">0.000</span>
                                </div>
                                <div class="state-bar">
                                    <span class="state-label">Intensity</span>
                                    <div class="bar-container">
                                        <div class="bar-fill" id="intensity-bar"></div>
                                    </div>
                                    <span id="intensity-value">0.500</span>
                                </div>
                                <div class="state-bar">
                                    <span class="state-label">Granularity</span>
                                    <div class="bar-container">
                                        <div class="bar-fill" id="granularity-bar"></div>
                                    </div>
                                    <span id="granularity-value">0.400</span>
                                </div>
                                <div class="state-bar">
                                    <span class="state-label">Confidence</span>
                                    <div class="bar-container">
                                        <div class="bar-fill" id="confidence-bar"></div>
                                    </div>
                                    <span id="confidence-value">0.600</span>
                                </div>
                            </div>
                        </div>

                        <!-- Event Log -->
                        <div class="audio-events">
                            <div class="section-title">⚡ Events</div>
                            <div id="audio-events-log">
                                <div class="audio-events-empty">No events yet</div>
                            </div>
                        </div>
                    </div>

                    <!-- Visualization Canvas -->
                    <div class="audio-visualization-panel">
                        <div class="section-title">📊 Audio Visualization</div>
                        <canvas id="audio-viz-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Visual/Engine Panel -->
        <div class="studio-visual">
            <!-- Idea Formation Visual Tracking -->
            <canvas class="idea-formation-canvas" id="ideaCanvas"></canvas>

            <!-- Real-time Idea Tracker -->
            <div class="idea-tracker" id="ideaTracker">
                <div class="idea-formation-title">💭 Idea Formation</div>
                <div class="cognitive-stage-indicator"></div>
                <div class="idea-flow-visual" id="ideaFlowVisual">
                    <!-- Dynamic particles and floating patterns will be added here -->
                </div>
                <div class="concept-nodes">
                    <div class="concept-node" id="node1"></div>
                    <div class="concept-connection" id="conn1"></div>
                    <div class="concept-node" id="node2"></div>
                    <div class="concept-connection" id="conn2"></div>
                    <div class="concept-node" id="node3"></div>
                    <div class="concept-connection" id="conn3"></div>
                    <div class="concept-node" id="node4"></div>
                </div>
            </div>

            <!-- Looking Down Perspective Viewer -->
            <div class="perspective-viewer" id="perspectiveViewer">
                <div class="perspective-title">🏔️ Idea Landscape</div>
                <div class="idea-landscape">
                    <div class="idea-elevation"></div>
                    <div class="thought-ripples">
                        <div class="ripple"></div>
                        <div class="ripple"></div>
                        <div class="ripple"></div>
                    </div>
                </div>
            </div>

            <!-- Mathematical Operations Panel -->
            <div class="math-operations-panel" id="mathOperationsPanel" style="display: none;">
                <div class="section-title">🧮 Unified Math Engine V3</div>
                <div class="math-controls">
                    <div class="math-status">
                        <div class="status-indicator" id="math-status-indicator">🟢</div>
                        <span id="math-status-text">Ready</span>
                        <span class="math-dimensions" id="mathDimensions">3D</span>
                    </div>

                    <div class="math-operations-grid">
                        <div class="math-operation-group">
                            <label>State Operations</label>
                            <div class="math-buttons">
                                <button class="math-btn" onclick="executeMathOperation('MV')">Move</button>
                                <button class="math-btn" onclick="executeMathOperation('SC')">Scale</button>
                                <button class="math-btn" onclick="executeMathOperation('RB')">Rebuild</button>
                                <button class="math-btn" onclick="executeMathOperation('NG')">Negate</button>
                            </div>
                        </div>

                        <div class="math-operation-group">
                            <label>Dimension Scaling</label>
                            <div class="math-buttons">
                                <button class="math-btn" onclick="executeDimensionOperation('upscale', 4)">Upscale to 4D</button>
                                <button class="math-btn" onclick="executeDimensionOperation('downscale', [0,2])">Downscale</button>
                                <button class="math-btn" onclick="previewMathComposition()">Preview Ops</button>
                                <button class="math-btn" onclick="undoMathOperation()">Undo</button>
                            </div>
                        </div>

                        <div class="math-state-display">
                            <div class="math-current-state" id="mathCurrentState">
                                SU(x=[0.000,0.000,0.000], κ=1.000, ℓ=0, d=3)
                            </div>
                            <div class="math-stability" id="mathStability">
                                <span class="stability-indicator">🟢</span>
                                <span>Stable</span>
                            </div>
                        </div>
                    </div>

                    <div class="math-tests-section">
                        <button class="math-btn" onclick="runMathTests()">🔬 Run Tests</button>
                        <button class="math-btn" onclick="runMathDemo()">🚀 Demo</button>
                        <button class="math-btn" onclick="showMathState()">📊 State</button>
                        <div class="math-test-results" id="mathTestResults"></div>
                    </div>
                </div>
            </div>

            <div class="section-title">🌍 World Engine</div>
            <iframe id="engine-frame" class="engine-frame" src="worldengine.html" title="World Engine Lexicon Processor"></iframe>
        </div>

        <!-- Recorder Popup Overlay -->
        <div id="recorder-overlay" class="chat-overlay">
            <div class="chat-popup">
                <div class="chat-header">
                    <span>🎙️ Recording Studio</span>
                    <button id="recorder-close" class="chat-close-btn">✕</button>
                </div>
                <div class="chat-content">
                    <!-- Recording Interface -->
                    <div class="recorder-interface">
                        <div class="recorder-status">
                            <div class="status-indicator" id="rec-status-indicator">🔴</div>
                            <span id="rec-status-text">Ready to Record</span>
                        </div>

                        <div class="recorder-controls">
                            <button id="record-btn" class="recorder-btn start">
                                <span class="rec-icon">🎙️</span>
                                <span class="rec-text">Start Recording</span>
                            </button>
                            <button id="stop-btn" class="recorder-btn stop" disabled>
                                <span class="rec-icon">⏹️</span>
                                <span class="rec-text">Stop</span>
                            </button>
                        </div>

                        <div class="recorder-info">
                            <div class="info-item">
                                <span class="info-label">Duration:</span>
                                <span id="rec-duration">00:00</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Status:</span>
                                <span id="rec-mode">Standby</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Combined Controllers UI Containers -->
        <div id="recorder-ui" style="display: none;"></div>
        <div id="chat-ui" style="display: none;"></div>
        <div id="ai-bot-ui" style="display: none;"></div>

        <!-- Status Bar -->
        <div class="studio-status">
            <div class="status-item">
                <div class="status-dot" id="engine-status"></div>
                <span>Engine: <span id="engine-text">Loading...</span></span>
            </div>
            <div class="status-item">
                <div class="status-dot" id="audio-engine-status"></div>
                <span>Audio: <span id="audio-engine-text">Ready</span></span>
            </div>
            <div class="status-item">
                <div class="status-dot" id="recorder-status"></div>
                <span>Recorder: <span id="recorder-text">Ready</span></span>
            </div>
            <div class="status-item">
                <div class="status-dot" id="bridge-status"></div>
                <span>Bridge: <span id="bridge-text">Connecting...</span></span>
            </div>
            <div class="status-item">
                <span id="session-info">Session: New</span>
            </div>
        </div>
    </div>

    <!-- Load all the bridge components -->
    <script src="world-engine-unified.js"></script>
    <script src="world-engine-types-lattice.js"></script>
    <script src="studio-bridge.js"></script>
    <script src="controllers.combined.js"></script>
    <script src="studio-integration-test.js"></script>

    <script>
        // Studio Manager - Coordinates all components with combined controllers
        class StudioManager {
            constructor() {
                this.orchestrator = null;
                this.sessionId = Utils.generateId();
                this.init();
            }

            async init() {
                try {
                    Utils.log('Starting World Engine Studio with Combined Controllers...');
                    this.updateStatus('bridge', 'connected', 'Connected');

                    // Initialize Combined Controllers Orchestrator
                    if (window.WorldEngineControllers) {
                        this.orchestrator = new window.WorldEngineControllers.WorldEngineOrchestrator({
                            engineFrameSelector: '#engine-frame',
                            ai: {
                                apiEndpoint: '/api/ai-bot',
                                autoLearn: true,
                                showConfidence: true,
                                feedbackEnabled: true
                            },
                            chat: {
                                autoLinkClips: true,
                                transcriptCommands: true,
                                commandPrefix: '/'
                            },
                            rec: {
                                transcription: false,
                                autoMarkRuns: true,
                                chunkSize: 200
                            }
                        });

                        // Expose individual controllers for backward compatibility
                        this.chat = this.orchestrator.chat;
                        this.recorder = this.orchestrator.recorder;
                        this.aiBot = this.orchestrator.ai;
                        this.engine = this.orchestrator.engine;

                        Utils.log('✅ Combined Controllers Orchestrator initialized');
                        this.updateStatus('recorder', 'connected', 'Ready');
                    } else {
                        throw new Error('WorldEngineControllers not available');
                    }

                    // Initialize Unified World Engine
                    if (window.UnifiedWorldEngine) {
                        this.unifiedEngine = await window.UnifiedWorldEngine.UnifiedWorldEngineFactory.createFull(3);
                        Utils.log('✅ Unified World Engine initialized with full features');
                        this.updateStatus('math', 'connected', 'Ready');

                        // Run initial mathematical health check
                        const healthCheck = await this.unifiedEngine.mathEngine.runMathematicalTests();
                        Utils.log(`Math Engine Health: ${healthCheck.overall_health.health_status} (${(healthCheck.overall_health.overall_score * 100).toFixed(1)}%)`, 'info');

                        // Store reference globally for math functions
                        window.studioManager = this;

                        // Show math panel by default
                        const mathPanel = document.getElementById('mathOperationsPanel');
                        if (mathPanel) {
                            const showByDefault = localStorage.getItem('mathPanelVisible') !== 'false';
                            mathPanel.style.display = showByDefault ? 'block' : 'none';
                        }
                    } else {
                        Utils.log('❌ Unified World Engine not available', 'warn');
                        this.updateStatus('math', 'warning', 'Not Available');
                    }

                    // Handle engine iframe loading for EngineController
                    const engineFrame = document.getElementById('engine-frame');
                    if (engineFrame) {
                        Utils.log(`Engine iframe src: ${engineFrame.src}`, 'debug');

                        // Set timeout for engine readiness
                        setTimeout(() => {
                            if (!this.engine?.isReady) {
                                Utils.log('Engine initialization timeout, continuing in degraded mode', 'warn');
                                this.updateStatus('engine', 'warning', 'Degraded');
                            } else {
                                this.updateStatus('engine', 'connected', 'Ready');
                            }
                        }, 5000);
                    }

                    // Initialize bridge listeners
                    this.setupBridgeListeners();

                    Utils.log('Studio initialization completed with Combined Controllers');
                    this.updateSessionInfo();
                    sendBus({ type: 'studio.ready', sessionId: this.sessionId, orchestrator: true });

                } catch (error) {
                    Utils.log(`Studio initialization error: ${error.message}`, 'error');
                    this.updateStatus('bridge', 'error', 'Failed');
                }
            }
                };
            }

            initializeComponents() {
                // This method is now split into init() and initializeEngine()
                Utils.log('Components initialized via new flow');
            }

            setupBridgeListeners() {
                onBus((msg) => {
                    // Log all messages in debug mode
                    if (window.location.search.includes('debug=true')) {
                        Utils.log(`Bridge: ${JSON.stringify(msg)}`, 'debug');
                    }

                    // Handle studio-level messages
                    switch (msg.type) {
                        case 'eng.ready':
                            this.updateStatus('engine', 'connected', 'Ready');
                            break;
                        case 'eng.error':
                            this.updateStatus('engine', 'error', 'Error');
                            break;
                        case 'rec.ready':
                            this.updateStatus('recorder', 'warning', 'Recording');
                            break;
                        case 'rec.clip':
                            this.updateStatus('recorder', 'connected', 'Ready');
                            break;
                        case 'rec.error':
                            this.updateStatus('recorder', 'error', 'Error');
                            break;
                    }
                });
            }

            updateStatus(component, state, text) {
                const dot = document.getElementById(`${component}-status`);
                const textEl = document.getElementById(`${component}-text`);

                if (dot) {
                    dot.className = `status-dot ${state}`;
                }
                if (textEl) {
                    textEl.textContent = text;
                }
            }

            updateSessionInfo() {
                const info = document.getElementById('session-info');
                if (info) {
                    const time = new Date().toLocaleTimeString();
                    info.textContent = `Session: ${this.sessionId.slice(-6)} (${time})`;
                }
            }

            showHelp() {
                if (this.chat) {
                    this.chat.announce(`
🌍 World Engine Studio Help:

Components:
• Chat Controller - Send commands and manage workflow
• World Engine - Lexicon analysis and processing
• Recorder - Audio/video capture with timeline markers

Quick Start:
1. Type text or commands in the chat panel
2. Use /rec start to begin recording
3. Use /run <text> to analyze content
4. Use /rec stop to save recording
5. Recordings auto-link to analysis runs

Commands: Type /help in chat for full list
                    `.trim(), 'system');
                }
            }

            async exportData() {
                try {
                    const data = {
                        sessionId: this.sessionId,
                        timestamp: Date.now(),
                        commandHistory: this.chat?.getHistory() || [],
                        lastRun: await Store.load('wordEngine.lastRun'),
                        // Could export clips and runs here
                    };

                    const blob = new Blob([JSON.stringify(data, null, 2)], {
                        type: 'application/json'
                    });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `world-engine-session-${this.sessionId}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    if (this.chat) {
                        this.chat.announce('Session data exported', 'system');
                    }

                } catch (error) {
                    Utils.log(`Export error: ${error.message}`, 'error');
                }
            }

            reset() {
                if (confirm('Reset studio session? This will clear history and stop any recordings.')) {
                    // Stop any active recording
                    if (this.recorder) {
                        sendBus({ type: 'rec.stop' });
                    }

                    // Clear chat
                    if (this.chat) {
                        this.chat.clearMessages();
                        this.chat.announce('Studio session reset', 'system');
                    }

                    // Reset session
                    this.sessionId = Utils.generateId();
                    this.updateSessionInfo();

                    Utils.log('Studio session reset');
                }
            }

            openPipelineCanvas() {
                // Open the Meta-Librarian Pipeline Canvas in a new window
                const canvasWindow = window.open('/api/pipeline/canvas', 'pipelineCanvas', 'width=1200,height=800,menubar=no,toolbar=no,location=no,status=no,scrollbars=no,resizable=yes');
                if (canvasWindow) {
                    canvasWindow.focus();
                    Utils.log('Opened Meta-Librarian Pipeline Canvas');
                } else {
                    alert('Please allow popups to open the Pipeline Canvas');
                }
            }

            async triggerPipelineProcess() {
                try {
                    const lastMessage = this.chat?.getLastMessage() || 'Process text through Meta-Librarian Pipeline';

                    if (this.chat) {
                        this.chat.announce('🧠 Triggering Meta-Librarian Pipeline...', 'system');
                    }

                    const response = await fetch('/api/pipeline/process', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            text: lastMessage,
                            session_id: this.sessionId
                        })
                    });

                    const result = await response.json();

                    if (this.chat) {
                        this.chat.announce(`✅ Pipeline Result: ${result.zones?.ACTIONABLE_OUTPUT || 'Processing complete'}`, 'assistant');
                    }

                    Utils.log('Pipeline processing triggered successfully');

                } catch (error) {
                    Utils.log(`Pipeline processing error: ${error.message}`, 'error');
                    if (this.chat) {
                        this.chat.announce(`❌ Pipeline error: ${error.message}`, 'error');
                    }
                }
            }

            getStatus() {
                const orchestratorStats = this.orchestrator ? this.orchestrator.getStats() : {};
                return {
                    sessionId: this.sessionId,
                    orchestrator: !!this.orchestrator,
                    controllers: orchestratorStats,
                    unifiedEngine: !!this.unifiedEngine,
                    mathEngine: this.unifiedEngine ? {
                        dimensions: this.unifiedEngine.mathEngine.dimensions,
                        morphemeCount: this.unifiedEngine.mathEngine.morphemes.size
                    } : null
                };
            }
        }

        // Initialize Studio when page loads
        let Studio;

        document.addEventListener('DOMContentLoaded', () => {
            Studio = new StudioManager();

            // Make Studio globally available for console debugging
            window.Studio = Studio;

            Utils.log('World Engine Studio loaded');
        });

        // Chat Toggle System
        class ChatToggle {
            constructor() {
                this.isOpen = false;
                this.init();
            }

            init() {
                this.toggleBtn = document.getElementById('chat-toggle');
                this.overlay = document.getElementById('chat-overlay');
                this.closeBtn = document.getElementById('chat-close');

                this.toggleBtn.addEventListener('click', () => this.toggle());
                this.closeBtn.addEventListener('click', () => this.close());

                // Close on overlay click (but not popup click)
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) this.close();
                });

                // ESC key closes chat
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen) this.close();
                });
            }

            toggle() {
                if (this.isOpen) {
                    this.close();
                } else {
                    this.open();
                }
            }

            open() {
                this.isOpen = true;
                this.overlay.classList.add('active');
                this.toggleBtn.classList.add('active');
                this.toggleBtn.querySelector('span').textContent = 'Close Chat';

                // Focus chat input after animation
                setTimeout(() => {
                    const chatInput = document.getElementById('chat-input');
                    if (chatInput) chatInput.focus();
                }, 300);
            }

            close() {
                this.isOpen = false;
                this.overlay.classList.remove('active');
                this.toggleBtn.classList.remove('active');
                this.toggleBtn.querySelector('span').textContent = 'AI Chat';
            }
        }

        // Recorder Toggle System
        class RecorderToggle {
            constructor() {
                this.isOpen = false;
                this.init();
            }

            init() {
                this.toggleBtn = document.getElementById('recorder-toggle');
                this.overlay = document.getElementById('recorder-overlay');
                this.closeBtn = document.getElementById('recorder-close');

                this.toggleBtn.addEventListener('click', () => this.toggle());
                this.closeBtn.addEventListener('click', () => this.close());

                // Close on overlay click (but not popup click)
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) this.close();
                });

                // ESC key closes recorder (but only if chat isn't open)
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen && !document.getElementById('chat-overlay').classList.contains('active')) {
                        this.close();
                    }
                });
            }

            toggle() {
                if (this.isOpen) {
                    this.close();
                } else {
                    this.open();
                }
            }

            open() {
                this.isOpen = true;
                this.overlay.classList.add('active');
                this.toggleBtn.classList.add('active');
                this.toggleBtn.querySelector('span').textContent = 'Close Recorder';
            }

            close() {
                this.isOpen = false;
                this.overlay.classList.remove('active');
                this.toggleBtn.classList.remove('active');
                this.toggleBtn.querySelector('span').textContent = 'Recorder';
            }
        }

        // Modern Recorder System
        class ModernRecorder {
            constructor() {
                this.isRecording = false;
                this.startTime = null;
                this.timer = null;
                this.init();
            }

            init() {
                this.recordBtn = document.getElementById('record-btn');
                this.stopBtn = document.getElementById('stop-btn');
                this.statusIndicator = document.getElementById('rec-status-indicator');
                this.statusText = document.getElementById('rec-status-text');
                this.durationEl = document.getElementById('rec-duration');
                this.modeEl = document.getElementById('rec-mode');

                this.recordBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
            }

            startRecording() {
                if (this.isRecording) return;

                this.isRecording = true;
                this.startTime = Date.now();

                // Update UI
                this.recordBtn.disabled = true;
                this.stopBtn.disabled = false;
                this.statusIndicator.classList.add('recording');
                this.statusText.textContent = 'Recording in progress...';
                this.modeEl.textContent = 'Recording';

                // Start timer
                this.timer = setInterval(() => this.updateDuration(), 1000);
                this.updateDuration();

                console.log('🎙️ Recording started');
            }

            stopRecording() {
                if (!this.isRecording) return;

                this.isRecording = false;

                // Update UI
                this.recordBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.statusIndicator.classList.remove('recording');
                this.statusText.textContent = 'Recording stopped';
                this.modeEl.textContent = 'Standby';

                // Stop timer
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }

                const duration = this.formatDuration((Date.now() - this.startTime) / 1000);
                console.log(`🎙️ Recording stopped - Duration: ${duration}`);

                // Reset after a moment
                setTimeout(() => {
                    this.statusText.textContent = 'Ready to Record';
                    this.durationEl.textContent = '00:00';
                }, 3000);
            }

            updateDuration() {
                if (!this.isRecording || !this.startTime) return;

                const elapsed = (Date.now() - this.startTime) / 1000;
                this.durationEl.textContent = this.formatDuration(elapsed);
            }

            formatDuration(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // Audio Engine Toggle System
        class AudioEngineToggle {
            constructor() {
                this.isOpen = false;
                this.init();
            }

            init() {
                this.toggleBtn = document.getElementById('audio-engine-toggle');
                this.overlay = document.getElementById('audio-engine-overlay');
                this.closeBtn = document.getElementById('audio-engine-close');

                this.toggleBtn.addEventListener('click', () => this.toggle());
                this.closeBtn.addEventListener('click', () => this.close());

                // Close on overlay click (but not popup click)
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) this.close();
                });

                // ESC key closes audio engine (but only if others aren't open)
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen &&
                        !document.getElementById('chat-overlay').classList.contains('active') &&
                        !document.getElementById('recorder-overlay').classList.contains('active')) {
                        this.close();
                    }
                });
            }

            toggle() {
                if (this.isOpen) {
                    this.close();
                } else {
                    this.open();
                }
            }

            open() {
                this.isOpen = true;
                this.overlay.classList.add('active');
                this.toggleBtn.classList.add('active');
                this.toggleBtn.querySelector('span').textContent = 'Close Audio';
            }

            close() {
                this.isOpen = false;
                this.overlay.classList.remove('active');
                this.toggleBtn.classList.remove('active');
                this.toggleBtn.querySelector('span').textContent = 'Audio Engine';
            }
        }

        // Background LLEX Service - Complete content-addressable lexical system
        class BackgroundLLEXService {
            constructor() {
                this.llex = null;
                this.currentSession = null;
                this.isInitialized = false;
                this.init();
            }

            async init() {
                try {
                    // Load LLEX components
                    await this.loadScript('./llex-core.js');
                    await this.loadScript('./llex-indexes.js');
                    await this.loadScript('./llex-complete.js');

                    // Initialize complete LLEX system
                    this.llex = new window.LLEX.CompleteSystem();
                    this.currentSession = `session-${Date.now()}`;
                    this.isInitialized = true;

                    console.log('🌟 Background LLEX Service initialized - content-addressable morphological processing active');
                    console.log(`📊 LLEX Stats:`, await this.llex.getStats());
                } catch (error) {
                    console.warn('Failed to initialize background LLEX service:', error);
                }
            }

            async loadScript(src) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }

            // Automatically analyze words with full content-addressable storage
            async analyzeWord(word, context = '', metadata = {}) {
                if (!this.isInitialized || !word) return null;

                try {
                    // Full morphological analysis with LLEX
                    const morphAnalysis = await this.llex.analyzeMorphology(word, context);

                    // Trigger visual idea formation
                    if (window.ideaFormationVisualizer) {
                        const complexity = morphAnalysis.length / 5; // Normalize complexity
                        const intensity = Math.min(word.length / 10, 1); // Word length influence

                        // Dispatch visual idea formation event
                        document.dispatchEvent(new CustomEvent('llexActivity', {
                            detail: {
                                word,
                                complexity,
                                intensity,
                                morphemes: morphAnalysis.map(m => m.morpheme.form),
                                context,
                                timestamp: Date.now()
                            }
                        }));
                    }

                    // Create a button for this word (if it represents an operation)
                    if (this.isOperationalWord(word)) {
                        const buttonResult = await this.llex.createButton(
                            'lexicon',
                            `button:${word}`,
                            this.generateOperatorForWord(word, morphAnalysis),
                            morphAnalysis.map(m => m.morpheme.form),
                            {
                                class: this.classifyWord(word),
                                source: 'auto-analysis',
                                context,
                                ...metadata
                            }
                        );

                        console.debug(`🔧 Button created: ${buttonResult.address}`);
                    }

                    // Store in LLEX with full versioning
                    const result = {
                        word,
                        morphemes: morphAnalysis,
                        llex_addresses: morphAnalysis.map(m => m.address),
                        timestamp: Date.now(),
                        session: this.currentSession,
                        metadata
                    };

                    return result;
                } catch (error) {
                    console.debug('LLEX analysis failed for:', word, error);
                    return null;
                }
            }

            // Determine if word represents an operation/transformation
            isOperationalWord(word) {
                const operationalPatterns = [
                    /^(re|de|un|over|under|pre|post)/, // Prefix suggests transformation
                    /(ify|ize|ise|ate|en)$/, // Suffix suggests action
                    /^(make|do|go|set|get|put|run|turn|move|change|shift|scale|grow|build)/
                ];

                return operationalPatterns.some(pattern => pattern.test(word.toLowerCase()));
            }

            // Generate operator matrix for word
            generateOperatorForWord(word, morphAnalysis) {
                const roots = morphAnalysis.filter(m => m.morpheme.type === 'root');
                const prefixes = morphAnalysis.filter(m => m.morpheme.type === 'prefix');

                // Default identity transformation
                let operator = {
                    M: [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
                    b: [0, 0, 0],
                    alpha: 1.0,
                    beta: 0.0,
                    delta_level: 0
                };

                // Modify based on morphemes
                if (prefixes.some(p => p.morpheme.form === 're')) {
                    // "re-" suggests repetition/amplification
                    operator.alpha = 1.1;
                    operator.delta_level = 0;
                }

                if (prefixes.some(p => p.morpheme.form === 'un')) {
                    // "un-" suggests negation/reversal
                    operator.alpha = -1.0;
                    operator.delta_level = 0;
                }

                if (word.toLowerCase().includes('scale')) {
                    operator.M = [[1.2, 0, 0], [0, 1.2, 0], [0, 0, 1.2]];
                }

                if (word.toLowerCase().includes('shift')) {
                    operator.b = [0.1, 0.1, 0];
                }

                return operator;
            }

            // Classify word for semantic organization
            classifyWord(word) {
                if (word.match(/^(re|de|un|over|under)/)) return 'Transform';
                if (word.match(/(ify|ize|ise|ate|en)$/)) return 'Action';
                if (word.match(/^(big|small|fast|slow|high|low)/)) return 'Quality';
                return 'Concept';
            }

            // Click button in current session (AI/Librarian can trigger operations)
            async clickButton(buttonAddress, params = {}, provenance = {}) {
                if (!this.isInitialized) return null;

                try {
                    const result = await this.llex.clickButton(
                        this.currentSession,
                        buttonAddress,
                        params,
                        { ...provenance, client: 'background-service' }
                    );

                    console.debug(`⚡ Button clicked: ${buttonAddress} → new state level: ${result.newState.level}`);
                    return result;
                } catch (error) {
                    console.debug('Button click failed:', error);
                    return null;
                }
            }

            // Query interface for AI/Librarian
            async query(type, value, options = {}) {
                if (!this.isInitialized) return [];

                try {
                    switch (type) {
                        case 'search':
                            return await this.llex.search(value, options);
                        case 'address':
                            const obj = await this.llex.resolve(value);
                            return obj;
                        case 'replay':
                            return await this.llex.replaySession(value, options.toSeq);
                        case 'morpheme':
                            return await this.llex.search('', { morpheme: value });
                        default:
                            return [];
                    }
                } catch (error) {
                    console.debug('LLEX query failed:', error);
                    return [];
                }
            }

            // Get comprehensive system statistics
            async getStats() {
                if (!this.isInitialized) return null;

                const stats = await this.llex.getStats();
                const health = await this.llex.healthCheck();

                return {
                    ...stats,
                    health,
                    session: this.currentSession,
                    service_status: 'active'
                };
            }

            // Create new session
            newSession() {
                this.currentSession = `session-${Date.now()}`;
                console.debug(`📝 New LLEX session: ${this.currentSession}`);
                return this.currentSession;
            }

            // Get current session state
            async getSessionState() {
                if (!this.isInitialized || !this.currentSession) return null;

                try {
                    const recovery = await this.llex.eventSourcer.recoverSession(this.currentSession);
                    return recovery;
                } catch (error) {
                    console.debug('Session state recovery failed:', error);
                    return null;
                }
            }
        }

        // Desktop-Class Features for LLEX Integration
        class DesktopIntegration {
            constructor() {
                this.notifications = [];
                this.isMinimized = false;
                this.autoSaveInterval = null;
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.startAutoSave();
                this.setupKeyboardShortcuts();
            }

            setupEventListeners() {
                // Desktop control buttons
                document.getElementById('save-session-btn')?.addEventListener('click', () => this.saveSession());
                document.getElementById('export-llex-btn')?.addEventListener('click', () => this.exportLLEXData());
                document.getElementById('import-llex-btn')?.addEventListener('click', () => this.importLLEXData());
                document.getElementById('notification-btn')?.addEventListener('click', () => this.testNotification());

                // File drag and drop for LLEX data import
                document.addEventListener('dragover', (e) => e.preventDefault());
                document.addEventListener('drop', (e) => this.handleFileDrop(e));
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key) {
                            case 's':
                                e.preventDefault();
                                this.saveSession();
                                break;
                            case 'e':
                                e.preventDefault();
                                this.exportLLEXData();
                                break;
                            case 'n':
                                e.preventDefault();
                                if (window.backgroundLLEX) {
                                    window.backgroundLLEX.newSession();
                                    this.showNotification('New LLEX session started', 'success');
                                }
                                break;
                        }
                    }
                });
            }

            startAutoSave() {
                // Auto-save LLEX session every 5 minutes
                this.autoSaveInterval = setInterval(() => {
                    if (window.backgroundLLEX && window.backgroundLLEX.isInitialized) {
                        this.saveSession(true);
                    }
                }, 5 * 60 * 1000);
            }

            async saveSession(isAutoSave = false) {
                try {
                    if (!window.backgroundLLEX || !window.backgroundLLEX.isInitialized) {
                        this.showNotification('LLEX system not ready', 'error');
                        return;
                    }

                    const sessionState = await window.backgroundLLEX.getSessionState();
                    const stats = await window.backgroundLLEX.getStats();

                    const saveData = {
                        timestamp: new Date().toISOString(),
                        session: sessionState,
                        stats: stats,
                        version: '1.0.0'
                    };

                    // Save to localStorage
                    localStorage.setItem('world-engine-llex-session', JSON.stringify(saveData));

                    const message = isAutoSave ? 'Session auto-saved' : 'Session saved successfully';
                    this.showNotification(message, 'success');

                    console.log('💾 LLEX Session saved:', saveData);
                } catch (error) {
                    console.error('Save failed:', error);
                    this.showNotification('Save failed: ' + error.message, 'error');
                }
            }

            async exportLLEXData() {
                try {
                    if (!window.backgroundLLEX || !window.backgroundLLEX.isInitialized) {
                        this.showNotification('LLEX system not ready', 'error');
                        return;
                    }

                    const stats = await window.backgroundLLEX.getStats();
                    const sessionState = await window.backgroundLLEX.getSessionState();

                    const exportData = {
                        export_date: new Date().toISOString(),
                        system_stats: stats,
                        session_state: sessionState,
                        system_info: {
                            version: '1.0.0',
                            engine: 'LLEX',
                            type: 'content_addressable_lexical_export'
                        }
                    };

                    // Create and download file
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                        type: 'application/json'
                    });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `llex-export-${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                    URL.revokeObjectURL(url);

                    this.showNotification('LLEX data exported successfully', 'success');
                } catch (error) {
                    console.error('Export failed:', error);
                    this.showNotification('Export failed: ' + error.message, 'error');
                }
            }

            importLLEXData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.processImportFile(file);
                    }
                };
                input.click();
            }

            async processImportFile(file) {
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    if (data.system_info?.type === 'content_addressable_lexical_export') {
                        // Process LLEX import data
                        console.log('📥 Importing LLEX data:', data);

                        // Here you would restore the LLEX state
                        // For now, just show success
                        this.showNotification(`Imported LLEX data from ${file.name}`, 'success');
                    } else {
                        this.showNotification('Invalid LLEX export file', 'error');
                    }
                } catch (error) {
                    console.error('Import failed:', error);
                    this.showNotification('Import failed: ' + error.message, 'error');
                }
            }

            handleFileDrop(e) {
                e.preventDefault();
                const files = Array.from(e.dataTransfer.files);
                const jsonFiles = files.filter(f => f.name.endsWith('.json'));

                if (jsonFiles.length > 0) {
                    this.processImportFile(jsonFiles[0]);
                }
            }

            showNotification(message, type = 'info', duration = 3000) {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>${this.getNotificationIcon(type)}</span>
                        <span>${message}</span>
                    </div>
                `;

                document.body.appendChild(notification);

                // Show notification
                setTimeout(() => notification.classList.add('show'), 100);

                // Hide and remove notification
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, duration);
            }

            getNotificationIcon(type) {
                switch (type) {
                    case 'success': return '✅';
                    case 'error': return '❌';
                    case 'warning': return '⚠️';
                    default: return 'ℹ️';
                }
            }

            testNotification() {
                this.showNotification('Desktop integration working!', 'success');
            }

            // System tray simulation
            minimize() {
                this.isMinimized = true;
                document.body.style.display = 'none';
                this.showNotification('App minimized to system tray', 'info');
            }

            restore() {
                this.isMinimized = false;
                document.body.style.display = 'block';
            }

            // Cleanup
            destroy() {
                if (this.autoSaveInterval) {
                    clearInterval(this.autoSaveInterval);
                }
            }
        }

        // Visual Idea Formation System
        class IdeaFormationVisualizer {
            constructor() {
                this.canvas = document.getElementById('ideaCanvas');
                this.ctx = this.canvas?.getContext('2d');
                this.ideaTracker = document.getElementById('ideaTracker');
                this.perspectiveViewer = document.getElementById('perspectiveViewer');
                this.particles = [];
                this.conceptNodes = [];
                this.ideaFormationActive = false;
                this.init();
            }

            init() {
                if (!this.canvas) return;

                this.setupCanvas();
                this.setupConceptNodes();
                this.startVisualization();
                this.setupEventListeners();

                console.log('🎨 Idea Formation Visualizer initialized');

                // Initialize baseline floating patterns from RhythmCoder
                setTimeout(() => this.initBaselinePatterns(), 1000);
            }

            initBaselinePatterns() {
                // Create some baseline floating patterns for visual continuity
                this.createFloatingPattern(2); // Start with moderate intensity

                // Refresh baseline patterns periodically
                setInterval(() => {
                    if (Math.random() > 0.7) {
                        this.createFloatingPattern(1);
                    }
                }, 15000);

                console.log('🌟 Baseline floating patterns initialized');
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // Resize handler
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
            }

            setupConceptNodes() {
                this.conceptNodes = [
                    { id: 'node1', element: document.getElementById('node1'), active: false },
                    { id: 'node2', element: document.getElementById('node2'), active: false },
                    { id: 'node3', element: document.getElementById('node3'), active: false },
                    { id: 'node4', element: document.getElementById('node4'), active: false }
                ];
            }

            setupEventListeners() {
                // Listen for LLEX activity to trigger visual updates
                document.addEventListener('llexActivity', (e) => {
                    this.onIdeaActivity(e.detail);
                });

                // Listen for typing or text input
                document.addEventListener('input', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        this.onInputActivity(e.target.value);
                    }
                });

                // Listen for mouse movement for idea tracking
                document.addEventListener('mousemove', (e) => {
                    this.trackCursorMovement(e);
                });
            }

            onIdeaActivity(detail) {
                console.log('💡 Idea activity detected:', detail);

                // Activate concept nodes based on activity
                this.activateConceptNode(Math.floor(Math.random() * 4));

                // Add visual particles
                this.addIdeaParticles(detail.intensity || 1);

                // Update landscape elevation
                this.updateIdeaLandscape(detail);
            }

            onInputActivity(inputText) {
                if (inputText.length > 0) {
                    // Enhanced cognitive processing visualization based on Loop IDE
                    const words = inputText.split(' ').filter(w => w.length > 0);
                    const wordCount = words.length;
                    const avgWordLength = words.reduce((sum, w) => sum + w.length, 0) / wordCount;
                    const intensity = Math.min(wordCount / 10, 1);

                    // Update cognitive stages with enhanced 3D feedback
                    this.updateCognitiveStage('perception', Math.min(wordCount / 5, 1));
                    setTimeout(() => this.updateCognitiveStage('analysis', Math.min(avgWordLength / 8, 1)), 200);
                    setTimeout(() => this.updateCognitiveStage('synthesis', Math.min(wordCount / 20, 1)), 400);
                    setTimeout(() => this.updateCognitiveStage('output', Math.random() * 0.5 + 0.5), 600);

                    // Enhanced particle system with 3D effects
                    this.addIdeaParticles(intensity);

                    // Activate nodes in circular pattern
                    this.activateRandomNodes(Math.ceil(intensity * 4));

                    // Create depth visualization based on complexity
                    this.visualizeComplexityDepth(inputText);
                }
            }

            updateCognitiveStage(stageId, intensity) {
                const stage = document.getElementById(`cognitive-${stageId}`);
                if (!stage) return;

                // Enhanced 3D depth and glow based on intensity
                const depth = intensity * 15;
                const glow = intensity * 10;
                const scale = 1 + (intensity * 0.3);

                stage.style.transform = `translateZ(${depth}px) scale(${scale})`;
                stage.style.boxShadow = `0 0 ${glow}px var(--accent)`;
                stage.style.opacity = 0.3 + (intensity * 0.7);

                // Add pulsing animation for active stages
                if (intensity > 0.5) {
                    stage.classList.add('pulsing');
                    setTimeout(() => stage.classList.remove('pulsing'), 2000);
                }
            }

            visualizeComplexityDepth(text) {
                const flowVisual = document.getElementById('ideaFlowVisual');
                if (!flowVisual) return;

                // Create depth layers based on text complexity
                const complexity = this.calculateTextComplexity(text);
                const layers = Math.min(Math.ceil(complexity / 20), 5);

                for (let layer = 0; layer < layers; layer++) {
                    const depthLayer = document.createElement('div');
                    depthLayer.className = 'depth-layer';

                    const zDepth = -layer * 10;
                    const opacity = 1 - (layer * 0.15);
                    const scale = 1 - (layer * 0.1);

                    depthLayer.style.position = 'absolute';
                    depthLayer.style.top = '0';
                    depthLayer.style.left = '0';
                    depthLayer.style.width = '100%';
                    depthLayer.style.height = '100%';
                    depthLayer.style.transform = `translateZ(${zDepth}px) scale(${scale})`;
                    depthLayer.style.opacity = opacity;
                    depthLayer.style.background = `radial-gradient(circle,
                        rgba(100, 255, 218, ${0.1 - layer * 0.02}) 0%,
                        transparent 70%)`;
                    depthLayer.style.pointerEvents = 'none';

                    flowVisual.appendChild(depthLayer);

                    // Remove depth layer after visualization
                    setTimeout(() => {
                        if (depthLayer.parentNode) {
                            depthLayer.parentNode.removeChild(depthLayer);
                        }
                    }, 3000 + layer * 1000);
                }
            }

            calculateTextComplexity(text) {
                const words = text.split(/\s+/).filter(w => w.length > 0);
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const avgWordsPerSentence = words.length / Math.max(sentences.length, 1);
                const avgWordLength = words.reduce((sum, w) => sum + w.length, 0) / words.length;

                return words.length + (avgWordsPerSentence * 2) + (avgWordLength * 1.5);
            }

            trackCursorMovement(event) {
                // Create subtle tracking particles following cursor
                if (Math.random() < 0.1) { // 10% chance
                    this.createTrackingParticle(event.clientX, event.clientY);
                }
            }

            createTrackingParticle(x, y) {
                if (!this.ctx) return;

                const particle = {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * -2 - 1,
                    life: 1.0,
                    decay: 0.02,
                    size: Math.random() * 3 + 1
                };

                this.particles.push(particle);
            }

            addIdeaParticles(intensity = 1) {
                const flowVisual = document.getElementById('ideaFlowVisual');
                if (!flowVisual) return;

                // Add visual particles to the flow display with enhanced 3D effects
                for (let i = 0; i < intensity * 5; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'idea-particle';

                    // Random positioning with 3D depth
                    const startX = Math.random() * 80 + 10;
                    const startY = Math.random() * 20;
                    const depth = Math.random() * 30 - 15; // Z-axis variation

                    particle.style.left = startX + '%';
                    particle.style.top = startY + '%';
                    particle.style.animationDelay = Math.random() * 3 + 's';
                    particle.style.animationDuration = (3 + Math.random() * 2) + 's';

                    // Add random color from original systems
                    const colors = ['var(--accent)', 'var(--success)', '#ff6b6b', '#4ecdc4', '#f9c74f'];
                    particle.style.background = colors[Math.floor(Math.random() * colors.length)];

                    // 3D transform
                    particle.style.transform = `translateZ(${depth}px)`;

                    flowVisual.appendChild(particle);

                    // Remove particle after animation
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 6000);
                }

                // Create additional floating patterns inspired by RhythmCoder
                this.createFloatingPattern(intensity);
            }

            createFloatingPattern(intensity = 1) {
                const flowVisual = document.getElementById('ideaFlowVisual');
                if (!flowVisual) return;

                for (let i = 0; i < intensity * 2; i++) {
                    const pattern = document.createElement('div');
                    pattern.className = 'floating-pattern';

                    const size = 10 + Math.random() * 30;
                    const x = Math.random() * 80 + 10;
                    const y = Math.random() * 60 + 20;
                    const colors = ['#64ffda', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9c74f', '#90be6d'];

                    pattern.style.width = size + 'px';
                    pattern.style.height = size + 'px';
                    pattern.style.left = x + '%';
                    pattern.style.top = y + '%';
                    pattern.style.background = colors[Math.floor(Math.random() * colors.length)];
                    pattern.style.animationDelay = Math.random() * 10 + 's';
                    pattern.style.animationDuration = (15 + Math.random() * 10) + 's';

                    flowVisual.appendChild(pattern);

                    // Remove after animation cycle
                    setTimeout(() => {
                        if (pattern.parentNode) {
                            pattern.parentNode.removeChild(pattern);
                        }
                    }, 25000);
                }
            }

            activateConceptNode(nodeIndex) {
                if (nodeIndex >= this.conceptNodes.length) return;

                const node = this.conceptNodes[nodeIndex];
                node.active = true;
                node.element?.classList.add('active');

                // Enhanced 3D activation with multiple connections
                const connectionId = `conn${nodeIndex + 1}`;
                const connection = document.getElementById(connectionId);
                connection?.classList.add('active');

                // Create ripple effect from circular thinking system
                this.createNodeRipple(node.element);

                // Activate multiple nodes in sequence (circular pattern)
                if (Math.random() > 0.6) {
                    setTimeout(() => {
                        const nextIndex = (nodeIndex + 1) % this.conceptNodes.length;
                        this.activateConceptNode(nextIndex);
                    }, 800);
                }

                // Deactivate after some time
                setTimeout(() => {
                    node.active = false;
                    node.element?.classList.remove('active');
                    connection?.classList.remove('active');
                }, 3000);
            }

            createNodeRipple(nodeElement) {
                if (!nodeElement) return;

                const ripple = document.createElement('div');
                ripple.style.position = 'absolute';
                ripple.style.width = '4px';
                ripple.style.height = '4px';
                ripple.style.borderRadius = '50%';
                ripple.style.border = '1px solid var(--accent)';
                ripple.style.left = '6px';
                ripple.style.top = '6px';
                ripple.style.pointerEvents = 'none';
                ripple.style.animation = 'rippleExpand 2s ease-out forwards';

                nodeElement.appendChild(ripple);

                // Add CSS animation for ripple
                if (!document.querySelector('#rippleAnimation')) {
                    const style = document.createElement('style');
                    style.id = 'rippleAnimation';
                    style.textContent = `
                        @keyframes rippleExpand {
                            0% { width: 4px; height: 4px; opacity: 1; transform: translateZ(0); }
                            100% { width: 40px; height: 40px; opacity: 0; transform: translateZ(10px);
                                   left: -14px; top: -14px; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                setTimeout(() => {
                    if (ripple.parentNode) {
                        ripple.parentNode.removeChild(ripple);
                    }
                }, 2000);
            }            activateRandomNodes(count) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        this.activateConceptNode(Math.floor(Math.random() * 4));
                    }, i * 500);
                }
            }

            updateIdeaLandscape(detail) {
                const elevation = document.querySelector('.idea-elevation');
                if (!elevation) return;

                // Dynamically update the landscape based on idea complexity
                const complexity = detail.complexity || Math.random();
                const hue = 180 + (complexity * 60); // Blue to green spectrum

                elevation.style.background = `linear-gradient(45deg,
                    hsla(${hue}, 70%, 50%, 0.1) 0%,
                    hsla(${hue + 20}, 70%, 60%, 0.2) 25%,
                    hsla(${hue - 10}, 80%, 55%, 0.1) 50%,
                    hsla(${hue + 10}, 75%, 65%, 0.15) 75%,
                    hsla(${hue}, 70%, 50%, 0.05) 100%)`;
            }

            startVisualization() {
                this.animationLoop();
            }

            animationLoop() {
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.updateParticles();
                    this.drawParticles();
                }

                requestAnimationFrame(() => this.animationLoop());
            }

            updateParticles() {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= particle.decay;
                    particle.vy += 0.1; // Gravity

                    return particle.life > 0;
                });
            }

            drawParticles() {
                if (!this.ctx) return;

                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = '#7cdcff';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }

            // Public methods for external triggers
            triggerIdeaFormation(intensity = 1) {
                this.onIdeaActivity({ intensity, complexity: Math.random() });
            }

            showLookingDownView(show = true) {
                if (this.perspectiveViewer) {
                    this.perspectiveViewer.style.display = show ? 'block' : 'none';
                }
            }

            toggleIdeaTracker(show = true) {
                if (this.ideaTracker) {
                    this.ideaTracker.style.display = show ? 'block' : 'none';
                }
            }

            // Multimodal effect methods for different embedding types
            triggerImageEffect(embedding) {
                if (!embedding || embedding.length < 5) return;

                // Use embedding values to drive visual parameters
                const intensity = Math.abs(embedding[1]) * 2; // Use second dimension
                const hue = (embedding[0] + 1) * 180; // Map -1,1 to 0,360 degrees
                const particles = Math.floor(embedding[2] * 50) + 10; // 10-60 particles

                this.createModalityParticles('image', intensity, hue, particles);
                this.activateConceptNode(0); // Image node
            }

            triggerAudioEffect(embedding) {
                if (!embedding || embedding.length < 5) return;

                const intensity = Math.abs(embedding[3]) * 2; // Different dimension for audio
                const frequency = embedding[1] * 0.5 + 0.5; // Map to 0-1
                const waves = Math.floor(embedding[4] * 10) + 5; // 5-15 waves

                this.createModalityWaves('audio', intensity, frequency, waves);
                this.activateConceptNode(1); // Audio node
            }

            triggerVideoEffect(embedding) {
                if (!embedding || embedding.length < 5) return;

                const intensity = Math.abs(embedding[0]) * 2;
                const motion = embedding[2] * 0.5 + 0.5; // Motion factor
                const trails = Math.floor(embedding[3] * 8) + 3; // 3-11 trails

                this.createModalityTrails('video', intensity, motion, trails);
                this.activateConceptNode(2); // Video node
            }

            triggerTextEffect(embedding) {
                if (!embedding || embedding.length < 5) return;

                const complexity = Math.abs(embedding[4]) * 2;
                const semanticDepth = embedding[1] * 0.5 + 0.5;
                const connections = Math.floor(embedding[0] * 6) + 2; // 2-8 connections

                this.createSemanticConnections('text', complexity, semanticDepth, connections);
                this.activateConceptNode(3); // Text node
            }

            createModalityParticles(modality, intensity, hue, count) {
                const flowVisual = document.getElementById('ideaFlowVisual');
                if (!flowVisual) return;

                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = `multimodal-particle ${modality}-particle`;
                    particle.style.cssText = `
                        position: absolute;
                        width: 4px;
                        height: 4px;
                        background: hsl(${hue}, 70%, 60%);
                        border-radius: 50%;
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        animation: modalityFloat ${2 + intensity}s ease-in-out infinite;
                        animation-delay: ${Math.random() * 2}s;
                        box-shadow: 0 0 ${intensity * 10}px hsl(${hue}, 70%, 60%);
                    `;
                    flowVisual.appendChild(particle);

                    setTimeout(() => particle.remove(), 8000);
                }
            }

            createModalityWaves(modality, intensity, frequency, count) {
                const flowVisual = document.getElementById('ideaFlowVisual');
                if (!flowVisual) return;

                for (let i = 0; i < count; i++) {
                    const wave = document.createElement('div');
                    wave.className = `multimodal-wave ${modality}-wave`;
                    wave.style.cssText = `
                        position: absolute;
                        width: ${100 + intensity * 50}px;
                        height: 2px;
                        background: linear-gradient(90deg, transparent, #4ecdc4, transparent);
                        left: ${Math.random() * 80}%;
                        top: ${40 + Math.sin(frequency * Math.PI * 2 * i) * 30}%;
                        animation: modalityFloat ${1 + frequency * 2}s linear infinite;
                        animation-delay: ${i * 0.2}s;
                    `;
                    flowVisual.appendChild(wave);

                    setTimeout(() => wave.remove(), 6000);
                }
            }

            createModalityTrails(modality, intensity, motion, count) {
                const flowVisual = document.getElementById('ideaFlowVisual');
                if (!flowVisual) return;

                for (let i = 0; i < count; i++) {
                    const trail = document.createElement('div');
                    trail.className = `multimodal-trail ${modality}-trail`;
                    trail.style.cssText = `
                        position: absolute;
                        width: ${20 + intensity * 30}px;
                        height: 1px;
                        background: linear-gradient(90deg, #ff6b6b, transparent);
                        left: ${Math.random() * 90}%;
                        top: ${Math.random() * 90}%;
                        animation: modalityFloat ${motion * 3 + 1}s ease-in-out infinite;
                        animation-delay: ${i * 0.3}s;
                        transform: rotate(${Math.random() * 360}deg);
                    `;
                    flowVisual.appendChild(trail);

                    setTimeout(() => trail.remove(), 5000);
                }
            }

            createSemanticConnections(modality, complexity, depth, count) {
                const flowVisual = document.getElementById('ideaFlowVisual');
                if (!flowVisual) return;

                for (let i = 0; i < count; i++) {
                    const connection = document.createElement('div');
                    connection.className = `multimodal-connection ${modality}-connection`;
                    connection.style.cssText = `
                        position: absolute;
                        width: ${complexity * 80 + 20}px;
                        height: 1px;
                        background: linear-gradient(90deg,
                            hsla(180, 70%, 60%, ${depth}),
                            hsla(200, 70%, 70%, ${depth * 0.5}),
                            transparent);
                        left: ${Math.random() * 70}%;
                        top: ${Math.random() * 70}%;
                        animation: modalityFloat ${depth * 4 + 2}s ease-in-out infinite;
                        animation-delay: ${i * 0.4}s;
                        transform: rotate(${i * (360 / count)}deg);
                        transform-origin: left center;
                    `;
                    flowVisual.appendChild(connection);

                    setTimeout(() => connection.remove(), 7000);
                }
            }
        }

        // Audio Semantic Engine Integration
        class AudioSemanticEngineUI {
            constructor() {
                this.processor = null;
                this.visualizer = null;
                this.isProcessing = false;
                this.init();
            }

            async init() {
                try {
                    // Import and initialize the enhanced audio processing modules
                    const { EnhancedWebAudioProcessor, EnhancedAudioVisualizer } = await import('./enhanced-web-audio-integration.js');

                    this.processor = new EnhancedWebAudioProcessor();

                    // Setup canvas
                    const canvas = document.getElementById('audio-viz-canvas');
                    this.visualizer = new EnhancedAudioVisualizer(canvas, this.processor);

                    // Bind UI controls
                    this.bindControls();

                    // Setup event listeners
                    this.setupEventListeners();

                    console.log('🎵 Enhanced Audio Semantic Engine UI initialized');

                } catch (error) {
                    console.error('Failed to initialize Enhanced Audio Semantic Engine UI:', error);
                    this.updateStatus('Failed to load enhanced audio modules');
                }
            }

            bindControls() {
                const startBtn = document.getElementById('audio-start-btn');
                const stopBtn = document.getElementById('audio-stop-btn');

                startBtn.addEventListener('click', () => this.startProcessing());
                stopBtn.addEventListener('click', () => this.stopProcessing());
            }

            setupEventListeners() {
                if (!this.processor) return;

                // Listen for semantic updates
                this.processor.on('semanticUpdate', (output) => {
                    this.updateSemanticDisplay(output);
                    this.updateTempoDisplay(output);
                    this.updateEventsLog(output);

                    // Send to World Engine
                    this.sendToWorldEngine(output);
                });

                // Listen for processor status
                this.processor.on('started', () => {
                    this.updateStatus('Processing audio...');
                    this.visualizer?.start();
                });

                this.processor.on('stopped', () => {
                    this.updateStatus('Ready');
                    this.visualizer?.stop();
                });

                this.processor.on('error', (error) => {
                    this.updateStatus(`Error: ${error.message}`);
                    console.error('Audio processor error:', error);
                });
            }

            async startProcessing() {
                if (this.isProcessing || !this.processor) return;

                try {
                    await this.processor.startProcessing();
                    this.isProcessing = true;

                    // Update UI
                    document.getElementById('audio-start-btn').disabled = true;
                    document.getElementById('audio-stop-btn').disabled = false;

                } catch (error) {
                    console.error('Failed to start audio processing:', error);
                    this.updateStatus(`Error: ${error.message}`);
                }
            }

            stopProcessing() {
                if (!this.isProcessing || !this.processor) return;

                this.processor.stopProcessing();
                this.isProcessing = false;

                // Update UI
                document.getElementById('audio-start-btn').disabled = false;
                document.getElementById('audio-stop-btn').disabled = true;
            }

            updateSemanticDisplay(output) {
                const { state } = output;

                // Update bars and values
                this.updateStateBar('polarity', state[0], -1, 1);
                this.updateStateBar('intensity', state[1], 0, 2);
                this.updateStateBar('granularity', state[2], 0, 2);
                this.updateStateBar('confidence', state[3], 0, 1);
            }

            updateStateBar(name, value, min, max) {
                const barEl = document.getElementById(`${name}-bar`);
                const valueEl = document.getElementById(`${name}-value`);

                if (barEl && valueEl) {
                    // Calculate percentage (0-100%)
                    const percentage = ((value - min) / (max - min)) * 100;
                    barEl.style.width = `${Math.max(0, Math.min(100, percentage))}%`;
                    valueEl.textContent = value.toFixed(3);
                }
            }

            updateTempoDisplay(output) {
                const { tempo, operators } = output;

                document.getElementById('audio-tempo').textContent = `${tempo.toFixed(1)} BPM`;
                document.getElementById('audio-operators').textContent =
                    operators && operators.length > 0 ? operators.join(', ') : 'None';
            }

            updateEventsLog(output) {
                const { events } = output;
                const logEl = document.getElementById('audio-events-log');

                if (!logEl) return;

                // Get active events
                const activeEvents = Object.entries(events).filter(([_, active]) => active).map(([event, _]) => event);

                if (activeEvents.length > 0) {
                    const timestamp = new Date().toLocaleTimeString();
                    const eventText = activeEvents.join(', ');

                    // Add new event
                    const eventDiv = document.createElement('div');
                    eventDiv.innerHTML = `<span style="color: #888;">${timestamp}</span> ${eventText}`;
                    eventDiv.style.fontSize = '11px';
                    eventDiv.style.marginBottom = '2px';
                    eventDiv.style.color = '#7cdcff';

                    // Remove empty state if present
                    const emptyEl = logEl.querySelector('.audio-events-empty');
                    if (emptyEl) emptyEl.remove();

                    // Add event and scroll
                    logEl.appendChild(eventDiv);
                    logEl.scrollTop = logEl.scrollHeight;

                    // Limit log entries
                    while (logEl.children.length > 20) {
                        logEl.removeChild(logEl.firstChild);
                    }
                }
            }

            updateStatus(status) {
                document.getElementById('audio-status-text').textContent = status;
            }

            sendToWorldEngine(output) {
                // Send enhanced semantic state to World Engine iframe
                const engineFrame = document.getElementById('engine-frame');
                if (engineFrame && engineFrame.contentWindow) {
                    try {
                        engineFrame.contentWindow.postMessage({
                            type: 'ENHANCED_AUDIO_SEMANTIC_UPDATE',
                            payload: {
                                semantic: output.state,
                                temporal: {
                                    bpm: output.clock.bpm,
                                    phase: output.clock.phase
                                },
                                visual: {
                                    hue: output.hue,
                                    brightness: output.brightness,
                                    grain: output.grain,
                                    reverb: output.reverb
                                },
                                events: output.events,
                                operators: output.operators,
                                features: output.features,
                                timestamp: output.timestamp
                            }
                        }, '*');
                    } catch (error) {
                        console.warn('Failed to send enhanced audio data to World Engine:', error);
                    }
                }
            }

            getStatus() {
                return {
                    isProcessing: this.isProcessing,
                    processor: this.processor ? 'initialized' : 'not initialized',
                    visualizer: this.visualizer ? 'initialized' : 'not initialized'
                };
            }
        }

        // Modern Chat System
        class ModernChat {
            constructor() {
                this.messages = [];
                this.init();
            }

            init() {
                this.chatInput = document.getElementById('chat-input');
                this.sendBtn = document.getElementById('send-btn');
                this.messagesContainer = document.getElementById('chat-messages');
                this.pipelineBtn = document.getElementById('pipeline-btn');
                this.canvasBtn = document.getElementById('canvas-btn');

                // Event listeners
                this.sendBtn.addEventListener('click', () => this.sendMessage());
                this.chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMessage();
                });

                this.pipelineBtn.addEventListener('click', () => this.triggerPipeline());
                this.canvasBtn.addEventListener('click', () => this.openCanvas());

                // Setup query interface
                this.setupQueryInterface();

                // Initialize health indicators
                this.updateHealth('engine', 'active', 'Online');
                this.updateHealth('pipeline', 'warning', 'Standby');
                this.updateHealth('recorder', 'active', 'Ready');

                // Welcome message
                this.addMessage('system', '🌍 World Engine Studio initialized successfully!');
                this.addMessage('system', '🔬 Query modes: Text, DSL, JSON, Math operations available');
            }

            setupQueryInterface() {
                // Query interface elements
                this.queryModeButtons = document.querySelectorAll('.query-mode-btn');
                this.mathButtons = document.getElementById('mathButtons');
                this.mathOperationButtons = document.querySelectorAll('.math-btn');
                this.multimodalPanel = document.getElementById('multimodalPanel');
                this.modalityButtons = document.querySelectorAll('.modality-btn');
                this.spatialSlider = document.getElementById('spatialSlider');
                this.temporalSlider = document.getElementById('temporalSlider');
                this.rateSlider = document.getElementById('rateSlider');

                this.currentMode = 'semantic';
                this.currentModality = 'text';
                this.activeMathOps = [];

                // Handle query mode switching
                this.queryModeButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.queryModeButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentMode = btn.dataset.mode;

                        // Show/hide appropriate panels
                        this.mathButtons.classList.remove('show');
                        this.multimodalPanel.classList.remove('show');

                        if (this.currentMode === 'math') {
                            this.mathButtons.classList.add('show');
                            this.chatInput.placeholder = 'Enter text to apply mathematical operations...';
                        } else if (this.currentMode === 'multimodal') {
                            this.multimodalPanel.classList.add('show');
                            this.chatInput.placeholder = 'Enter content to analyze across modalities...';
                        } else {
                            this.updatePlaceholder();
                        }

                        this.addMessage('system', `🔄 Switched to ${this.currentMode.toUpperCase()} mode`);
                    });
                });

                // Handle modality switching
                this.modalityButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.modalityButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentModality = btn.dataset.modality;
                        this.addMessage('system', `🎭 Switched to ${this.currentModality} modality`);
                    });
                });

                // Handle scaling sliders
                this.setupScalingSliders();

                // Handle math operation buttons
                this.mathOperationButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const op = btn.dataset.op;
                        btn.classList.toggle('active');

                        if (btn.classList.contains('active')) {
                            if (!this.activeMathOps.includes(op)) {
                                this.activeMathOps.push(op);
                            }
                        } else {
                            this.activeMathOps = this.activeMathOps.filter(o => o !== op);
                        }

                        this.addMessage('system', `🧮 Math operations: [${this.activeMathOps.join(', ')}]`);
                    });
                });
            }

            setupScalingSliders() {
                const updateDisplay = (sliderId, valueId) => {
                    const slider = document.getElementById(sliderId);
                    const display = document.getElementById(valueId);

                    slider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        display.textContent = value.toFixed(2);

                        // Update multimodal system scales
                        if (window.queryIntegrationSystem && window.queryIntegrationSystem.multimodalEmbedding) {
                            const s = parseFloat(this.spatialSlider.value);
                            const tau = parseFloat(this.temporalSlider.value);
                            const r = parseFloat(this.rateSlider.value);

                            window.queryIntegrationSystem.multimodalEmbedding.updateScales(s, tau, r);
                            this.addMessage('system', `📊 Scales updated: s=${s.toFixed(2)}, τ=${tau.toFixed(2)}, r=${r.toFixed(2)}`);
                        }
                    });
                };

                updateDisplay('spatialSlider', 'spatialValue');
                updateDisplay('temporalSlider', 'temporalValue');
                updateDisplay('rateSlider', 'rateValue');
            }

            updateSimilarityDisplay(similarities) {
                if (similarities) {
                    document.getElementById('videoSim').textContent = similarities.video.toFixed(3);
                    document.getElementById('imageSim').textContent = similarities.image.toFixed(3);
                    document.getElementById('audioSim').textContent = similarities.audio.toFixed(3);
                    document.getElementById('textSim').textContent = similarities.text.toFixed(3);
                }
            }            updatePlaceholder() {
                const placeholders = {
                    'semantic': 'Type message or /command...',
                    'dsl': 'QUERY:: TOPIC("your topic") GOAL("analysis goal") ...',
                    'json': '{"meta": {"query_id": "..."}, "topic": [...], ...}',
                    'math': 'Text to process with selected operations...'
                };

                this.chatInput.placeholder = placeholders[this.currentMode] || 'Type your query...';
            }

            sendMessage() {
                const message = this.chatInput.value.trim();
                if (!message) return;

                this.addMessage('user', message);
                this.chatInput.value = '';

                // Process based on current mode
                if (this.currentMode === 'multimodal') {
                    this.processMultimodalQuery(message);
                } else if (this.currentMode === 'math' && this.activeMathOps.length > 0) {
                    this.processMathQuery(message);
                } else if (this.currentMode === 'dsl' || message.includes('QUERY::')) {
                    this.processDSLQuery(message);
                } else if (this.currentMode === 'json' || (message.startsWith('{') && message.includes('"meta"'))) {
                    this.processJSONQuery(message);
                } else {
                    // Regular message processing with enhanced semantic analysis
                    this.analyzeMessageWords(message);

                    // Enhanced semantic processing for regular text
                    if (window.queryIntegrationSystem) {
                        const result = window.queryIntegrationSystem.processQuery(message, 'semantic');
                        this.addMessage('system', `🔬 Semantic Analysis: Complexity=${Math.round(result.query.complexity)}, State=[${result.stateVector.map(v => v.toFixed(2)).join(', ')}]`);

                        // Update similarity display if multimodal data available
                        if (result.multimodal && result.multimodal.similarities) {
                            this.updateSimilarityDisplay(result.multimodal.similarities);
                        }
                    }
                }

                // Process commands
                if (message.startsWith('/')) {
                    this.handleCommand(message);
                } else if (this.currentMode === 'semantic' && !message.includes('QUERY::') && !message.startsWith('{')) {
                    // Regular chat response
                    setTimeout(() => {
                        this.addMessage('assistant', `Processing: "${message}"`);
                        this.updateHealth('engine', 'active', 'Processing');
                    }, 500);
                }
            }

            processMultimodalQuery(message) {
                if (!window.multimodalEmbeddingSystem) {
                    console.warn('Multimodal system not initialized');
                    return;
                }

                try {
                    // Process multimodal query silently
                    const result = window.multimodalEmbeddingSystem.processMultimodal(message);

                    // Store result for download if needed
                    this.lastMultimodalResult = result;

                    // Show minimal confirmation with key info
                    this.addMessage('system', `🌐 ${result.modality.toUpperCase()} • Confidence: ${(result.confidence * 100).toFixed(1)}% • <button onclick="modernChat.downloadMultimodalResult()" class="download-btn">Download</button>`);

                    // Update similarity display
                    if (result.similarities) {
                        this.updateSimilarityDisplay(result.similarities);
                    }

                    // Trigger visual effects (background)
                    if (window.ideaFormationVisualizer) {
                        const visualSystem = window.ideaFormationVisualizer;

                        switch(result.modality) {
                            case 'image':
                                visualSystem.triggerImageEffect(result.embedding);
                                break;
                            case 'audio':
                                visualSystem.triggerAudioEffect(result.embedding);
                                break;
                            case 'video':
                                visualSystem.triggerVideoEffect(result.embedding);
                                break;
                            default:
                                visualSystem.triggerTextEffect(result.embedding);
                        }
                    }

                    // Store the embedding for comparison (background)
                    if (!this.multimodalHistory) this.multimodalHistory = [];
                    this.multimodalHistory.push({
                        message: message,
                        embedding: result.embedding,
                        modality: result.modality,
                        timestamp: Date.now()
                    });

                    if (this.multimodalHistory.length > 10) {
                        this.multimodalHistory.shift();
                    }

                } catch (error) {
                    console.error('Error processing multimodal query:', error);
                    this.addMessage('error', 'Error processing multimodal query: ' + error.message);
                }
            }

            // Download methods for background processing results
            downloadJSONResult() {
                if (!this.lastJSONResult) {
                    this.addMessage('system', 'No JSON result to download');
                    return;
                }

                const blob = new Blob([JSON.stringify(this.lastJSONResult, null, 2)], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `json-query-result-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            downloadMultimodalResult() {
                if (!this.lastMultimodalResult) {
                    this.addMessage('system', 'No multimodal result to download');
                    return;
                }

                const blob = new Blob([JSON.stringify(this.lastMultimodalResult, null, 2)], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `multimodal-result-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }            updateSimilarityDisplay(similarities) {
                const display = document.getElementById('similarity-display');
                if (!display) return;

                let html = '<div class="similarity-grid">';
                for (const [modalityPair, similarity] of Object.entries(similarities)) {
                    const percentage = (similarity * 100).toFixed(1);
                    const intensity = Math.abs(similarity);
                    html += `
                        <div class="similarity-item" style="opacity: ${0.3 + intensity * 0.7}">
                            <span class="modality-pair">${modalityPair}</span>
                            <span class="similarity-value" style="color: hsl(${120 * similarity + 120}, 70%, 50%)">${percentage}%</span>
                        </div>
                    `;
                }
                html += '</div>';
                display.innerHTML = html;

                // Add fade-in animation
                display.style.animation = 'modalityFloat 0.5s ease-in-out';
            }

            processMathQuery(text) {
                try {
                    if (window.queryIntegrationSystem && window.queryIntegrationSystem.mathOps) {
                        // Start with initial state based on text complexity
                        const complexity = window.queryIntegrationSystem.calculateComplexity(text);
                        let state = [0, complexity / 100, 0.5, 0.7, 1]; // [polarity, intensity, granularity, confidence, lang_id]

                        // Apply selected mathematical operations silently
                        this.activeMathOps.forEach(op => {
                            if (window.queryIntegrationSystem.mathOps[op]) {
                                state = window.queryIntegrationSystem.mathOps[op](state);
                            }
                        });

                        // Store result for download if needed
                        this.lastMathResult = {
                            operations: this.activeMathOps,
                            initialState: [0, complexity / 100, 0.5, 0.7, 1],
                            finalState: state,
                            text: text,
                            timestamp: Date.now()
                        };

                        // Trigger visual effects based on final state (background)
                        const visualEffects = {
                            particleIntensity: Math.ceil(state[1] * 12),
                            depthLayers: Math.ceil(state[2] * 6),
                            nodeActivations: Math.ceil(state[3] * 4),
                            colorShift: state[0] > 0 ? 'warm' : 'cool',
                            animationSpeed: state[1] + 0.3
                        };

                        window.queryIntegrationSystem.triggerVisualEffects(visualEffects);

                        // Show minimal confirmation with key info
                        const avgState = state.reduce((sum, val) => sum + Math.abs(val), 0) / state.length;
                        this.addMessage('system', `🧮 MATH: ${this.activeMathOps.join('+')} • Intensity: ${(avgState * 100).toFixed(0)}% • <button onclick="modernChat.downloadMathResult()" class="download-btn">Download</button>`);
                        this.updateHealth('engine', 'active', 'Math Complete');
                    }
                } catch (error) {
                    this.addMessage('system', `❌ Math Processing Error: ${error.message}`);
                    this.updateHealth('engine', 'error', 'Math Error');
                }
            }

            downloadMathResult() {
                if (!this.lastMathResult) {
                    this.addMessage('system', 'No math result to download');
                    return;
                }

                const blob = new Blob([JSON.stringify(this.lastMathResult, null, 2)], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `math-query-result-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }            processDSLQuery(queryText) {
                try {
                    const result = window.queryIntegrationSystem.processQuery(queryText, 'dsl');

                    // Store result for download if needed
                    this.lastDSLResult = result;

                    if (result.error) {
                        this.addMessage('system', `❌ Query Error: ${result.error}`);
                        if (result.fallback) {
                            this.addMessage('system', `🔄 Fallback processing applied`);
                        }
                    } else {
                        // Show minimal confirmation with key insights
                        const topic = result.query.topic && result.query.topic.length > 0 ? result.query.topic.join(', ') : 'General';
                        const confidence = result.stateVector ? (result.stateVector[3] * 100).toFixed(0) : '0';

                        this.addMessage('system', `🔬 DSL: ${topic} • Confidence: ${confidence}% • <button onclick="modernChat.downloadDSLResult()" class="download-btn">Download</button>`);

                        // Update health status
                        this.updateHealth('engine', 'active', 'DSL Processed');
                    }
                } catch (error) {
                    this.addMessage('system', `❌ DSL Processing Error: ${error.message}`);
                    this.updateHealth('engine', 'error', 'DSL Error');
                }
            }

            downloadDSLResult() {
                if (!this.lastDSLResult) {
                    this.addMessage('system', 'No DSL result to download');
                    return;
                }

                const blob = new Blob([JSON.stringify(this.lastDSLResult, null, 2)], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dsl-query-result-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            processJSONQuery(queryText) {
                // Process JSON query silently in background
                try {
                    const result = window.queryIntegrationSystem.processQuery(queryText, 'json');

                    // Store result for download if needed
                    this.lastJSONResult = result;

                    // Show minimal confirmation
                    this.addMessage('system', `📋 JSON Query processed • <button onclick="modernChat.downloadJSONResult()" class="download-btn">Download Result</button>`);
                    this.updateHealth('engine', 'active', 'JSON Processed');
                } catch (error) {
                    this.addMessage('system', `❌ JSON Processing Error: ${error.message}`);
                    this.updateHealth('engine', 'error', 'JSON Error');
                }
            }

            // Background word analysis for AI/Librarian use
            analyzeMessageWords(message) {
                if (!window.backgroundLLE || !message) return;

                // Extract meaningful words (exclude common words)
                const words = message.toLowerCase()
                    .split(/\s+/)
                    .filter(word => word.length > 2 && !/^(the|and|for|are|but|not|you|all|can|had|her|was|one|our|out|day|get|has|him|his|how|its|may|new|now|old|see|two|way|who|boy|did|use|man|own|say|she|too|any|may|say|she|too|any)$/i.test(word))
                    .map(word => word.replace(/[^\w]/g, ''));

                // Analyze each meaningful word
                words.forEach(word => {
                    if (word.length > 2) {
                        window.backgroundLLE.analyzeWord(word, message, {
                            source: 'chat',
                            userMessage: true
                        });
                    }
                });
            }

            handleCommand(cmd) {
                const command = cmd.toLowerCase();

                if (command === '/help') {
                    this.addMessage('system', `
Available Commands:
/help - Show this help
/status - System status
/pipeline - Trigger Meta-Librarian Pipeline
/canvas - Open Pipeline Canvas
/clear - Clear chat messages
/lle [word] - Query LLE morphological analysis
/lle stats - Show LLE statistics
                    `.trim());
                } else if (command === '/status') {
                    this.addMessage('system', 'System Status: All systems operational');
                } else if (command === '/pipeline') {
                    this.triggerPipeline();
                } else if (command === '/canvas') {
                    this.openCanvas();
                } else if (command === '/clear') {
                    this.clearMessages();
                } else if (command.startsWith('/lle ')) {
                    this.handleLLEQuery(command.substring(5));
                } else if (command === '/lle') {
                    this.addMessage('system', 'Usage: /lle [word] or /lle stats');
                } else {
                    this.addMessage('system', `Unknown command: ${cmd}. Type /help for commands.`);
                }
            }

            // Handle LLEX queries for AI/Librarian
            async handleLLEQuery(query) {
                const parts = query.trim().toLowerCase().split(' ');
                const command = parts[0];
                const value = parts.slice(1).join(' ');

                if (command === 'stats') {
                    if (window.backgroundLLEX && window.backgroundLLEX.isInitialized) {
                        const stats = await window.backgroundLLEX.getStats();
                        this.addMessage('system', `
🌟 LLEX Content-Addressable System Statistics:
• Objects stored: ${stats.engine.object_store.total_objects}
• Catalog entries: ${stats.engine.catalog_entries}
• Vector indexes: ${stats.indexes.vector.total_vectors}
• Graph nodes: ${stats.indexes.graph.total_nodes}
• Text documents: ${stats.indexes.text.total_documents}
• Active sessions: ${stats.event_sourcer.active_sessions}
• System health: ${stats.health.status}
• Current session: ${stats.session}
                        `.trim());
                    } else {
                        this.addMessage('system', '⚠️ Background LLEX service not available');
                    }
                } else if (command === 'search' && value) {
                    if (window.backgroundLLEX && window.backgroundLLEX.isInitialized) {
                        const results = await window.backgroundLLEX.query('search', value, { limit: 5 });
                        if (results.results && results.results.length > 0) {
                            const resultList = results.results.map(r =>
                                `• ${r.cid.substring(0, 12)}... (${Array.from(r.sources).join(', ')})`
                            ).join('\n');
                            this.addMessage('system', `
🔍 LLEX Search Results for "${value}":
${resultList}
                            `.trim());
                        } else {
                            this.addMessage('system', `No results found for "${value}"`);
                        }
                    }
                } else if (command === 'resolve' && value) {
                    if (window.backgroundLLEX && window.backgroundLLEX.isInitialized) {
                        try {
                            const obj = await window.backgroundLLEX.query('address', value);
                            this.addMessage('system', `
🏷️ LLEX Address Resolution: ${value}
• Type: ${obj.type}
• LID: ${obj.lid || 'N/A'}
• VID: ${obj.vid || 'N/A'}
• CID: ${obj.cid || 'N/A'}
                            `.trim());
                        } catch (error) {
                            this.addMessage('system', `❌ Address not found: ${value}`);
                        }
                    }
                } else if (command === 'click' && value) {
                    if (window.backgroundLLEX && window.backgroundLLEX.isInitialized) {
                        try {
                            const result = await window.backgroundLLEX.clickButton(value, {}, { user: 'chat-query' });
                            if (result) {
                                this.addMessage('system', `
⚡ Button Click Result:
• Button: ${value}
• New state level: ${result.newState.level}
• Position: [${result.newState.x.map(x => x.toFixed(3)).join(', ')}]
• Event CID: ${result.event.cid}
                                `.trim());
                            } else {
                                this.addMessage('system', `❌ Button click failed: ${value}`);
                            }
                        } catch (error) {
                            this.addMessage('system', `❌ Button click error: ${error.message}`);
                        }
                    }
                } else if (command === 'session') {
                    if (window.backgroundLLEX && window.backgroundLLEX.isInitialized) {
                        if (value === 'new') {
                            const newSession = window.backgroundLLEX.newSession();
                            this.addMessage('system', `📝 Created new session: ${newSession}`);
                        } else if (value === 'state') {
                            const state = await window.backgroundLLEX.getSessionState();
                            if (state) {
                                this.addMessage('system', `
📊 Current Session State:
• Session: ${state.session}
• Final state level: ${state.finalState?.level || 'N/A'}
• Position: [${state.finalState?.x?.map(x => x.toFixed(3)).join(', ') || 'N/A'}]
• Recovery method: ${state.recoveredFrom || 'direct'}
                                `.trim());
                            } else {
                                this.addMessage('system', '❌ Could not retrieve session state');
                            }
                        } else {
                            this.addMessage('system', 'Usage: /llex session [new|state]');
                        }
                    }
                } else if (value && window.backgroundLLEX && window.backgroundLLEX.isInitialized) {
                    // Default: analyze word
                    const analysis = await window.backgroundLLEX.analyzeWord(value, 'chat-query', { source: 'manual' });
                    if (analysis) {
                        const morphemeList = analysis.morphemes.map(m =>
                            `${m.morpheme.form} (${m.morpheme.type})`
                        ).join(', ');
                        this.addMessage('system', `
🧬 LLEX Morphological Analysis for "${value}":
• Morphemes: ${morphemeList}
• Addresses: ${analysis.llex_addresses.length} created
• Session: ${analysis.session}
• Classification: ${window.backgroundLLEX.classifyWord(value)}
                        `.trim());
                    } else {
                        this.addMessage('system', `Word "${value}" analysis failed. Service may be initializing.`);
                    }
                } else {
                    this.addMessage('system', `
🌟 LLEX Commands:
/llex stats - System statistics
/llex search [query] - Search across all indexes
/llex resolve [address] - Resolve llex:// address
/llex click [button-address] - Trigger button click
/llex session [new|state] - Session management
/llex [word] - Analyze word morphology
                    `.trim());
                }
            }            addMessage(type, content) {
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message ${type}`;
                messageEl.innerHTML = content.replace(/\n/g, '<br>');

                this.messagesContainer.appendChild(messageEl);
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;

                this.messages.push({ type, content, timestamp: Date.now() });
            }

            clearMessages() {
                const welcome = this.messagesContainer.querySelector('.welcome-message');
                this.messagesContainer.innerHTML = '';
                if (welcome) this.messagesContainer.appendChild(welcome);
                this.messages = [];
            }

            updateHealth(component, status, text) {
                const dot = document.getElementById(`${component}-health`);
                const statusText = document.getElementById(`${component}-status-text`);

                if (dot) {
                    dot.className = `health-dot ${status}`;
                }
                if (statusText) {
                    statusText.textContent = text;
                }
            }

            async triggerPipeline() {
                this.addMessage('system', '🧠 Triggering Meta-Librarian Pipeline...');
                this.updateHealth('pipeline', 'active', 'Processing');

                const lastMessage = this.messages.filter(m => m.type === 'user').pop();
                const text = lastMessage ? lastMessage.content : 'Process system state';

                try {
                    const response = await fetch('/api/pipeline/process', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        this.addMessage('assistant', `✅ Pipeline Result: ${result.zones?.ACTIONABLE_OUTPUT || 'Processing complete'}`);
                        this.updateHealth('pipeline', 'active', 'Complete');
                    } else {
                        throw new Error('Pipeline API not available');
                    }
                } catch (error) {
                    this.addMessage('system', `⚠️ Pipeline simulation: Processing "${text}" through 7-zone system`);
                    this.updateHealth('pipeline', 'warning', 'Simulation');
                }
            }

            openCanvas() {
                this.addMessage('system', '🎨 Opening Pipeline Canvas...');
                const canvasWindow = window.open('/api/pipeline/canvas', 'pipelineCanvas',
                    'width=1200,height=800,scrollbars=no,resizable=yes');

                if (canvasWindow) {
                    canvasWindow.focus();
                    this.addMessage('system', '✅ Pipeline Canvas opened in new window');
                } else {
                    // Fallback to meta-librarian-canvas.html
                    const fallbackWindow = window.open('meta-librarian-canvas.html', 'pipelineCanvas',
                        'width=1200,height=800,scrollbars=no,resizable=yes');
                    if (fallbackWindow) {
                        fallbackWindow.focus();
                        this.addMessage('system', '✅ Pipeline Canvas opened (local version)');
                    } else {
                        this.addMessage('system', '❌ Please allow popups to open Pipeline Canvas');
                    }
                }
            }
        }

        // Compact Semantic Query Processing System
        class CompactDSLQueryProcessor {
            constructor() {
                this.operators = {
                    'Deconstruct': { weight: 0.9, visual: '→' },
                    'ChallengeAssumptions': { weight: 0.8, visual: '⚡' },
                    'PatternRecognize': { weight: 0.7, visual: '🔍' },
                    'MapRelations': { weight: 0.8, visual: '🕸️' },
                    'Synthesize': { weight: 0.9, visual: '⊕' },
                    'Elevate': { weight: 0.8, visual: '▲' }
                };

                this.uiButtons = {
                    'ALIGN': { weight: 0.9, desc: 'word/feature alignment' },
                    'PROJ': { weight: 0.8, desc: 'annotation projection' },
                    'REFINE': { weight: 0.7, desc: 'statistical refinement' },
                    'POLY': { weight: 0.4, desc: 'polysemy resolver' },
                    'IRONY': { weight: 0.3, desc: 'sarcasm/irony detector' },
                    'GRAPH': { weight: 0.6, desc: 'synonym/antonym graph propagate' },
                    'DIRECTION': { weight: 0.5, desc: 'increase/decrease/variance' },
                    'RECOMPUTE': { weight: 0.6, desc: 'translucent recomputation pass' }
                };

                this.csgComponents = ['Base', 'Addition', 'Subtraction', 'Intersection', 'Difference'];
            }

            parseDSLQuery(queryText) {
                const query = {
                    topic: [],
                    goal: '',
                    modes: {},
                    actions: [],
                    components: [],
                    operators: [],
                    constraints: {},
                    ui: [],
                    math: {},
                    lexicon: {},
                    weights: {},
                    visual: {},
                    output: {}
                };

                // Parse TOPIC
                const topicMatch = queryText.match(/TOPIC\("([^"]+)"\)/);
                if (topicMatch) {
                    query.topic = topicMatch[1].split(' ');
                }

                // Parse GOAL
                const goalMatch = queryText.match(/GOAL\("([^"]+)"\)/);
                if (goalMatch) {
                    query.goal = goalMatch[1];
                }

                // Parse MODES
                const modesMatch = queryText.match(/MODES\{([^}]+)\}/);
                if (modesMatch) {
                    modesMatch[1].split(',').forEach(mode => {
                        const [key, value] = mode.split(':');
                        if (key && value) {
                            query.modes[key.trim()] = value.trim();
                        }
                    });
                }

                // Parse ACTIONS
                const actionsMatch = queryText.match(/ACTIONS\[([^\]]+)\]/);
                if (actionsMatch) {
                    query.actions = actionsMatch[1].split('|').map(a => a.trim());
                }

                // Parse UI buttons
                const uiMatch = queryText.match(/UI\{buttons:([^}]+)\}/);
                if (uiMatch) {
                    query.ui = uiMatch[1].split(',').map(btn => btn.trim());
                }

                // Parse WEIGHTS
                const weightsMatch = queryText.match(/WEIGHTS\{([^}]+)\}/);
                if (weightsMatch) {
                    weightsMatch[1].split(',').forEach(weight => {
                        const [key, value] = weight.split(':');
                        if (key && value) {
                            query.weights[key.trim()] = parseFloat(value.trim());
                        }
                    });
                }

                return query;
            }

            processQuery(queryText) {
                const query = this.parseDSLQuery(queryText);
                const stateVector = this.computeStateVector(query);
                const visualEffects = this.generateVisualEffects(query, stateVector);

                return {
                    query: query,
                    stateVector: stateVector,
                    visualEffects: visualEffects,
                    timestamp: Date.now()
                };
            }

            computeStateVector(query) {
                // State vector [polarity, intensity, granularity, confidence, language_id]
                let polarity = 0;
                let intensity = 0;
                let granularity = 0.5;
                let confidence = 0.5;
                let languageId = 1; // English

                // Compute based on active buttons and weights
                Object.keys(query.weights).forEach(button => {
                    const weight = query.weights[button];
                    if (this.uiButtons[button]) {
                        intensity += weight * 0.3;
                        granularity += weight * 0.2;
                        confidence += weight * 0.1;
                    }
                });

                // Normalize values
                polarity = Math.max(-1, Math.min(1, polarity));
                intensity = Math.max(0, Math.min(1, intensity));
                granularity = Math.max(0, Math.min(1, granularity));
                confidence = Math.max(0, Math.min(1, confidence));

                return [polarity, intensity, granularity, confidence, languageId];
            }

            generateVisualEffects(query, stateVector) {
                const [polarity, intensity, granularity, confidence, languageId] = stateVector;

                return {
                    particleIntensity: Math.ceil(intensity * 10),
                    depthLayers: Math.ceil(granularity * 5),
                    nodeActivations: Math.ceil(confidence * 4),
                    colorShift: polarity > 0 ? 'warm' : 'cool',
                    animationSpeed: intensity + 0.5,
                    cognitiveStages: query.operators.map(op => ({
                        operator: op,
                        visual: this.operators[op]?.visual || '●',
                        weight: this.operators[op]?.weight || 0.5
                    }))
                };
            }
        }

        // Mathematical Button Operations System
        class MathButtonOperations {
            constructor() {
                this.alignMatrix = [
                    [1.1, 0.1, 0.2, 0.1, 0],
                    [0.1, 1.2, 0.1, 0.2, 0],
                    [0.2, 0.1, 1.3, 0.3, 0],
                    [0.1, 0.2, 0.3, 1.4, 0],
                    [0, 0, 0, 0, 1]
                ];
            }

            // Pure mathematical operations on state vector [p, i, g, c, ℓ]
            ALIGN(state) {
                // S ← A·S where A is alignment matrix
                const result = [0, 0, 0, 0, 0];
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 5; j++) {
                        result[i] += this.alignMatrix[i][j] * state[j];
                    }
                }
                // Normalize and clamp
                result[2] = Math.min(1, result[2]); // granularity
                result[3] = Math.min(1, result[3]); // confidence
                return result;
            }

            PROJ(state, alpha = 0.2, beta = 0.1, gamma = 0.3) {
                // S ← S + [0, α, -β, γ-c, 0]
                const [p, i, g, c, l] = state;
                return [p, i + alpha, g - beta, Math.min(1, c + gamma - c), l];
            }

            REFINE(state, eta = 0.7) {
                // Reduces variance and raises confidence when c < η
                const [p, i, g, c, l] = state;
                if (c < eta) {
                    return [p * 0.9, i * 0.95, g + 0.1, Math.min(1, c + 0.2), l];
                }
                return state;
            }

            POLY(state, ambiguity = 0.5) {
                // S ← S + [0, 0, 0.3π, -0.2π, 0]
                const [p, i, g, c, l] = state;
                return [p, i, g + 0.3 * ambiguity, c - 0.2 * ambiguity, l];
            }

            IRONY(state, contextRule = 1) {
                // p ← σp with σ ∈ {-1, +1}
                const [p, i, g, c, l] = state;
                return [p * contextRule, i, g, c, l];
            }

            GRAPH(state, kappa = 0.3) {
                // Propagate over synonym/antonym graph
                const [p, i, g, c, l] = state;
                return [p, i, Math.min(1, g + kappa), Math.min(1, c + kappa), l];
            }

            DIRECTION(state, direction = 0) {
                // Add direction vector {-1, 0, +1}
                const [p, i, g, c, l] = state;
                return [p + direction * 0.1, i, g, c, l];
            }

            RECOMPUTE(state) {
                // Idempotent visibility pass
                return [...state]; // Return copy without modification
            }

            executeCanonicalPipeline(initialState) {
                // S_final = GRAPH(REFINE(PROJ(ALIGN(S0)))) ∘ [IRONY?] ∘ [DIRECTION?] ∘ [RECOMPUTE?]
                let state = this.ALIGN(initialState);
                state = this.PROJ(state);
                state = this.REFINE(state);
                state = this.GRAPH(state);

                // Optional operations
                if (Math.random() > 0.5) state = this.IRONY(state);
                if (Math.random() > 0.5) state = this.DIRECTION(state, Math.floor(Math.random() * 3) - 1);
                state = this.RECOMPUTE(state);

                return state;
            }
        }

        // Multimodal Embedding System
        // Unified embedding space Z where video, image, audio, and text map to vectors
        // with spatial (s), temporal (τ), and rate (r) scaling parameters
        class MultimodalEmbeddingSystem {
            constructor() {
                this.dimension = 16;
                this.modalityWeights = {
                    video: 0.31,
                    image: 0.53,
                    audio: 0.79,
                    text: 0.97
                };

                this.samples = {
                    video: ["city timelapse", "cooking tutorial", "soccer highlights"],
                    image: ["mountain sunrise photo", "diagram: transformer block", "product render: translucent glass"],
                    audio: ["piano arpeggio", "crowd cheering", "spoken phrase: hello world"],
                    text: ["A cat sits on a windowsill.", "Define cosine similarity.", "Translucent module recompute status."]
                };

                // Current scaling parameters
                this.scales = { s: 0.5, tau: 0.5, r: 0.5 };
                this.prototypes = this.computePrototypes();
            }

            // Seeded PRNG (Mulberry32) for deterministic embeddings
            mulberry32(seed) {
                return function() {
                    let t = (seed += 0x6D2B79F5);
                    t = Math.imul(t ^ (t >>> 15), t | 1);
                    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
                };
            }

            // Simple string hash → int seed
            hashSeed(str) {
                let h = 2166136261;
                for (let i = 0; i < str.length; i++) {
                    h ^= str.charCodeAt(i);
                    h = Math.imul(h, 16777619);
                }
                return (h >>> 0) % 2147483647;
            }

            // Build pseudo-embedding for modality with scales (s, tau, r)
            embed(content, modality, { s, tau, r } = this.scales) {
                const modalityId = this.modalityWeights[modality];
                const seed = this.hashSeed(`${modality}:${content}`);
                const rand = this.mulberry32(seed);

                // Generate base vector
                const v = new Array(this.dimension).fill(0).map(() => rand() * 2 - 1);

                // Apply scale-aware transforms
                const alpha = 0.15 + 0.25 * s; // spatial contributes to image/video
                const beta = 0.15 + 0.25 * tau; // temporal contributes to audio/video
                const gamma = 0.15 + 0.25 * r; // rate contributes to text/audio

                for (let i = 0; i < this.dimension; i++) {
                    const b1 = Math.sin((i + 1) * 0.37 + modalityId) * alpha;
                    const b2 = Math.cos((i + 1) * 0.13 + modalityId) * beta;
                    const b3 = Math.sin((i + 1) * 0.19 + modalityId) * gamma;
                    v[i] = v[i] + b1 + b2 + b3;
                }

                // Normalize to unit vector
                const norm = Math.sqrt(v.reduce((a, b) => a + b * b, 0)) || 1;
                return v.map((x) => x / norm);
            }

            // Cosine similarity between two vectors
            cosine(a, b) {
                let dot = 0, na = 0, nb = 0;
                for (let i = 0; i < a.length; i++) {
                    dot += a[i] * b[i];
                    na += a[i] * a[i];
                    nb += b[i] * b[i];
                }
                return dot / (Math.sqrt(na) * Math.sqrt(nb) || 1);
            }

            // Compute prototype embeddings for each modality
            computePrototypes() {
                const prototypes = {};

                Object.keys(this.samples).forEach(modality => {
                    const embeddings = this.samples[modality].map(content =>
                        this.embed(content, modality, this.scales)
                    );

                    // Compute centroid
                    const mean = new Array(this.dimension).fill(0);
                    embeddings.forEach(emb => {
                        emb.forEach((val, i) => mean[i] += val);
                    });
                    mean.forEach((val, i) => mean[i] /= embeddings.length);

                    // Normalize centroid
                    const norm = Math.sqrt(mean.reduce((a, b) => a + b * b, 0)) || 1;
                    prototypes[modality] = mean.map(x => x / norm);
                });

                return prototypes;
            }

            // Update scaling parameters and recompute prototypes
            updateScales(s, tau, r) {
                this.scales = { s, tau, r };
                this.prototypes = this.computePrototypes();
            }

            // Process content across all modalities and return similarity scores
            processMultimodal(content, sourceModality = 'text') {
                // Get embedding for the input content
                const contentEmbedding = this.embed(content, sourceModality, this.scales);

                // Calculate cross-modal similarities
                const similarities = {};
                Object.keys(this.prototypes).forEach(modality => {
                    similarities[modality] = Number(this.cosine(contentEmbedding, this.prototypes[modality]).toFixed(3));
                });

                return {
                    content: content,
                    sourceModality: sourceModality,
                    embedding: contentEmbedding.slice(0, 8), // First 8 dimensions for display
                    similarities: similarities,
                    scales: { ...this.scales },
                    timestamp: Date.now()
                };
            }

            // Auto-detect modality based on content keywords
            detectModality(content) {
                const videoKeywords = ['video', 'movie', 'film', 'timelapse', 'footage', 'tutorial', 'highlights'];
                const imageKeywords = ['photo', 'picture', 'image', 'diagram', 'render', 'visual', 'graphic'];
                const audioKeywords = ['sound', 'audio', 'music', 'voice', 'spoken', 'noise', 'melody'];

                const lower = content.toLowerCase();

                if (videoKeywords.some(kw => lower.includes(kw))) return 'video';
                if (imageKeywords.some(kw => lower.includes(kw))) return 'image';
                if (audioKeywords.some(kw => lower.includes(kw))) return 'audio';

                return 'text'; // Default
            }
        }

        // Enhanced Query Integration System
        class QueryIntegrationSystem {
            constructor() {
                this.dslProcessor = new CompactDSLQueryProcessor();
                this.mathOps = new MathButtonOperations();
                this.multimodalEmbedding = new MultimodalEmbeddingSystem();
                this.currentQuery = null;
                this.visualEffectQueue = [];
            }

            processQuery(queryText, format = 'dsl') {
                try {
                    let result;

                    if (format === 'dsl' && queryText.includes('QUERY::')) {
                        result = this.dslProcessor.processQuery(queryText);
                    } else if (format === 'json') {
                        result = this.processJSONQuery(JSON.parse(queryText));
                    } else {
                        // Default semantic processing
                        result = this.processSemanticText(queryText);
                    }

                    this.currentQuery = result;
                    this.triggerVisualEffects(result.visualEffects);

                    return result;
                } catch (error) {
                    console.error('Query processing error:', error);
                    return { error: error.message, fallback: this.processSemanticText(queryText) };
                }
            }

            processJSONQuery(jsonQuery) {
                // Process executable JSON query format
                const query = {
                    meta: jsonQuery.meta || {},
                    topic: jsonQuery.topic || [],
                    lexicon: jsonQuery.lexicon || {},
                    frameworks: jsonQuery.frameworks || [],
                    phases: jsonQuery.phases || [],
                    uiButtons: jsonQuery.ui_buttons || [],
                    constraints: jsonQuery.constraints || {},
                    mathKernel: jsonQuery.math_kernel || {}
                };

                // Compute state vector from JSON structure
                let intensity = 0;
                let granularity = 0.5;
                let confidence = 0.5;

                // Process UI buttons and weights
                if (query.uiButtons && Array.isArray(query.uiButtons)) {
                    query.uiButtons.forEach(button => {
                        if (button.weight) {
                            intensity += button.weight * 0.2;
                            confidence += button.weight * 0.1;
                        }
                    });
                }

                // Process phases for granularity
                if (query.phases && Array.isArray(query.phases)) {
                    granularity += query.phases.length * 0.1;
                }

                // Process topic complexity
                if (query.topic && Array.isArray(query.topic)) {
                    intensity += Math.min(query.topic.length / 20, 0.5);
                }

                const stateVector = [0, Math.min(1, intensity), Math.min(1, granularity), Math.min(1, confidence), 1];
                const finalState = this.mathOps.executeCanonicalPipeline(stateVector);

                return {
                    query: query,
                    stateVector: finalState,
                    visualEffects: {
                        particleIntensity: Math.ceil(finalState[1] * 10),
                        depthLayers: Math.ceil(finalState[2] * 5),
                        nodeActivations: Math.ceil(finalState[3] * 4),
                        colorShift: finalState[0] > 0 ? 'warm' : 'cool',
                        animationSpeed: finalState[1] + 0.4,
                        cognitiveStages: query.phases.map(phase => ({
                            phase: phase.name,
                            operations: phase.ops,
                            visual: phase.id === 'P1' ? '→' : phase.id === 'P2' ? '🔍' : '⊕'
                        }))
                    },
                    timestamp: Date.now()
                };
            }

            processSemanticText(text) {
                // Enhanced semantic processing with multimodal analysis
                const words = text.split(/\s+/).filter(w => w.length > 0);
                const complexity = this.calculateComplexity(text);
                const initialState = [0, complexity / 100, 0.5, 0.7, 1];

                // Detect modality and process multimodal embeddings
                const sourceModality = this.multimodalEmbedding.detectModality(text);
                const multimodalResult = this.multimodalEmbedding.processMultimodal(text, sourceModality);

                // Use multimodal similarities to enhance state vector
                const maxSimilarity = Math.max(...Object.values(multimodalResult.similarities));
                const modalityDiversity = Object.values(multimodalResult.similarities).filter(s => s > 0.3).length;

                // Enhance intensity and granularity based on cross-modal similarity
                initialState[1] += maxSimilarity * 0.3; // intensity boost from similarity
                initialState[2] += (modalityDiversity / 4) * 0.2; // granularity from diversity

                const finalState = this.mathOps.executeCanonicalPipeline(initialState);

                return {
                    query: { topic: words, complexity: complexity },
                    stateVector: finalState,
                    multimodal: multimodalResult,
                    visualEffects: {
                        particleIntensity: Math.ceil(finalState[1] * 8),
                        depthLayers: Math.ceil(finalState[2] * 4),
                        nodeActivations: Math.ceil(finalState[3] * 3),
                        colorShift: finalState[0] > 0 ? 'warm' : 'cool',
                        animationSpeed: finalState[1] + 0.3,
                        modalityEffects: this.generateModalityEffects(multimodalResult)
                    },
                    timestamp: Date.now()
                };
            }

            generateModalityEffects(multimodalResult) {
                const effects = [];

                // Generate effects based on cross-modal similarities
                Object.entries(multimodalResult.similarities).forEach(([modality, similarity]) => {
                    if (similarity > 0.4) {
                        effects.push({
                            modality: modality,
                            similarity: similarity,
                            visual: this.getModalityVisual(modality),
                            intensity: Math.ceil(similarity * 5),
                            color: this.getModalityColor(modality)
                        });
                    }
                });

                return effects;
            }

            getModalityVisual(modality) {
                const visuals = {
                    video: '🎬',
                    image: '🖼️',
                    audio: '🎵',
                    text: '📝'
                };
                return visuals[modality] || '●';
            }

            getModalityColor(modality) {
                const colors = {
                    video: '#ff6b6b',
                    image: '#4ecdc4',
                    audio: '#45b7d1',
                    text: '#f9c74f'
                };
                return colors[modality] || '#64ffda';
            }            calculateComplexity(text) {
                const words = text.split(/\s+/).filter(w => w.length > 0);
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const avgWordsPerSentence = words.length / Math.max(sentences.length, 1);
                const avgWordLength = words.reduce((sum, w) => sum + w.length, 0) / words.length;

                return words.length + (avgWordsPerSentence * 2) + (avgWordLength * 1.5);
            }

            triggerVisualEffects(effects) {
                // Send enhanced visual effects to idea formation visualizer
                if (window.ideaFormationVisualizer && effects) {
                    // Enhanced particle generation
                    if (effects.particleIntensity > 0) {
                        window.ideaFormationVisualizer.addIdeaParticles(effects.particleIntensity);
                    }

                    // Depth layer visualization
                    if (effects.depthLayers > 1) {
                        window.ideaFormationVisualizer.visualizeComplexityDepth(`${'complex '.repeat(effects.depthLayers)}`);
                    }

                    // Node activation patterns
                    if (effects.nodeActivations > 0) {
                        for (let i = 0; i < effects.nodeActivations; i++) {
                            setTimeout(() => {
                                window.ideaFormationVisualizer.activateConceptNode(i);
                            }, i * 400);
                        }
                    }

                    // Cognitive stage visualization
                    if (effects.cognitiveStages) {
                        effects.cognitiveStages.forEach((stage, index) => {
                            setTimeout(() => {
                                window.ideaFormationVisualizer.updateCognitiveStage('analysis', stage.weight);
                            }, index * 300);
                        });
                    }

                    // Multimodal effects
                    if (effects.modalityEffects && effects.modalityEffects.length > 0) {
                        this.triggerMultimodalEffects(effects.modalityEffects);
                    }
                }

                console.log('🔬 Query visual effects triggered:', effects);
            }

            triggerMultimodalEffects(modalityEffects) {
                modalityEffects.forEach((effect, index) => {
                    setTimeout(() => {
                        // Create modality-specific visual patterns
                        if (window.ideaFormationVisualizer) {
                            // Add colored particles based on modality
                            const flowVisual = document.getElementById('ideaFlowVisual');
                            if (flowVisual) {
                                for (let i = 0; i < effect.intensity; i++) {
                                    const particle = document.createElement('div');
                                    particle.className = 'multimodal-particle';
                                    particle.textContent = effect.visual;

                                    const x = Math.random() * 80 + 10;
                                    const y = Math.random() * 60 + 20;

                                    particle.style.position = 'absolute';
                                    particle.style.left = x + '%';
                                    particle.style.top = y + '%';
                                    particle.style.color = effect.color;
                                    particle.style.fontSize = (12 + effect.intensity * 2) + 'px';
                                    particle.style.animation = `modalityFloat 3s ease-out forwards`;
                                    particle.style.pointerEvents = 'none';
                                    particle.style.zIndex = '1000';

                                    flowVisual.appendChild(particle);

                                    // Remove after animation
                                    setTimeout(() => {
                                        if (particle.parentNode) {
                                            particle.parentNode.removeChild(particle);
                                        }
                                    }, 3000);
                                }
                            }

                            // Update cognitive stage based on modality
                            window.ideaFormationVisualizer.updateCognitiveStage('perception', effect.similarity);
                        }
                    }, index * 200);
                });

                console.log('🎭 Multimodal effects triggered:', modalityEffects);
            }
        }

        // Unified Math Engine Control Functions
        async function executeMathOperation(buttonKey) {
            if (!window.studioManager?.unifiedEngine?.mathEngine) {
                showMathResult('❌ Unified World Engine not available', 'error');
                return;
            }

            try {
                showMathStatus('⚡ Executing operation...');
                const result = await window.studioManager.unifiedEngine.mathEngine.safeClickButton(buttonKey);

                if (result.success) {
                    updateMathState(result.result);
                    showMathResult(`✅ ${buttonKey} operation completed successfully`, 'success');
                } else {
                    showMathResult(`❌ ${buttonKey} failed: ${result.error}`, 'error');
                }
            } catch (error) {
                showMathResult(`❌ Error executing ${buttonKey}: ${error.message}`, 'error');
            }
        }

        async function executeDimensionOperation(type, params) {
            if (!window.studioManager?.unifiedEngine?.mathEngine) {
                showMathResult('❌ Unified World Engine not available', 'error');
                return;
            }

            try {
                showMathStatus(`⚡ ${type === 'upscale' ? 'Upscaling' : 'Downscaling'}...`);

                let result;
                if (type === 'upscale') {
                    result = await window.studioManager.unifiedEngine.mathEngine.safeUpscale(null, params);
                } else {
                    result = await window.studioManager.unifiedEngine.mathEngine.safeDownscale(params);
                }

                if (result.success) {
                    updateMathState(result.result);
                    const dimChange = `${result.before_dimensions}D → ${result.after_dimensions}D`;
                    showMathResult(`✅ ${type} completed: ${dimChange}`, 'success');
                    updateMathDimensions(result.after_dimensions);
                } else {
                    showMathResult(`❌ ${type} failed: ${result.error}`, 'error');
                }
            } catch (error) {
                showMathResult(`❌ Error during ${type}: ${error.message}`, 'error');
            }
        }

        async function previewMathComposition() {
            if (!window.studioManager?.unifiedEngine?.mathEngine) {
                showMathResult('❌ Unified World Engine not available', 'error');
                return;
            }

            try {
                const operations = ['RB', 'SC', { type: 'upscale', toDim: 4 }, 'MV'];
                const preview = await window.studioManager.unifiedEngine.mathEngine.previewComposition(operations);

                if (preview.success) {
                    const stability = preview.mathematical_analysis.mathematical_stability ? '🟢 Stable' : '🔴 Unstable';
                    const recovery = preview.mathematical_analysis.recovery_possible ? '✅ Recoverable' : '❌ No Recovery';
                    showMathResult(`📊 Preview: ${stability}, ${recovery}. Steps: ${preview.steps.length}`, 'info');
                } else {
                    showMathResult(`❌ Preview failed: ${preview.error}`, 'error');
                }
            } catch (error) {
                showMathResult(`❌ Preview error: ${error.message}`, 'error');
            }
        }

        async function undoMathOperation() {
            if (!window.studioManager?.unifiedEngine?.mathEngine) {
                showMathResult('❌ Unified World Engine not available', 'error');
                return;
            }

            try {
                const result = await window.studioManager.unifiedEngine.mathEngine.safeUndo();

                if (result.success && result.restored) {
                    updateMathState(result.result);
                    showMathResult('✅ Operation undone successfully', 'success');
                } else {
                    showMathResult('⚠️ No operation to undo', 'warning');
                }
            } catch (error) {
                showMathResult(`❌ Undo error: ${error.message}`, 'error');
            }
        }

        async function runMathTests() {
            if (!window.studioManager?.unifiedEngine?.mathEngine) {
                showMathResult('❌ Unified World Engine not available', 'error');
                return;
            }

            try {
                showMathStatus('🔬 Running mathematical tests...');
                const testResults = await window.studioManager.unifiedEngine.mathEngine.runMathematicalTests();

                const resultsEl = document.getElementById('mathTestResults');
                const health = testResults.overall_health;
                const score = (health.overall_score * 100).toFixed(1);

                let html = `<div class="test-info">📊 Test Results (${score}% - ${health.health_status})</div>`;
                html += `<div class="test-info">Basic: ${testResults.basic_tests.summary.passed}/${testResults.basic_tests.summary.total}</div>`;

                testResults.mathematical_tests.forEach(test => {
                    const status = test.success ? 'test-pass' : 'test-fail';
                    const icon = test.success ? '✅' : '❌';
                    html += `<div class="${status}">${icon} ${test.name}</div>`;
                    if (test.error) html += `<div class="test-fail">  Error: ${test.error}</div>`;
                });

                resultsEl.innerHTML = html;
                resultsEl.classList.add('show');

                showMathResult(`✅ Tests completed: ${health.tests_passed}/${health.total_tests} passed`, 'success');
            } catch (error) {
                showMathResult(`❌ Test error: ${error.message}`, 'error');
            }
        }

        async function runMathDemo() {
            if (!window.UnifiedWorldEngine) {
                showMathResult('❌ UnifiedWorldEngine not available', 'error');
                return;
            }

            try {
                showMathStatus('🚀 Running unified demo...');
                const demoResults = await window.UnifiedWorldEngine.runUnifiedDemo();

                showMathResult(`✅ Demo completed! Components: ${demoResults.components.status}`, 'success');
                console.log('🌍 Unified Demo Results:', demoResults);
            } catch (error) {
                showMathResult(`❌ Demo error: ${error.message}`, 'error');
            }
        }

        async function showMathState() {
            if (!window.studioManager?.unifiedEngine?.mathEngine) {
                showMathResult('❌ Unified World Engine not available', 'error');
                return;
            }

            try {
                const state = window.studioManager.unifiedEngine.mathEngine.getEnhancedState();
                console.log('🌍 Enhanced Unified Engine State:', state);

                const resultsEl = document.getElementById('mathTestResults');
                let html = `<div class="test-info">📊 Enhanced State (v${state.system_version})</div>`;
                html += `<div class="test-info">Dimensions: ${state.dimensions}D</div>`;
                html += `<div class="test-info">Components: ${window.studioManager.unifiedEngine.components.status}</div>`;
                html += `<div class="test-info">Operations: ${state.mathematical.available_operations.length}</div>`;

                const stability = state.mathematical.stability;
                Object.entries(stability).forEach(([key, value]) => {
                    const status = value ? 'test-pass' : 'test-fail';
                    const icon = value ? '✅' : '❌';
                    html += `<div class="${status}">${icon} ${key.replace(/_/g, ' ')}: ${value}</div>`;
                });

                resultsEl.innerHTML = html;
                resultsEl.classList.add('show');

                showMathResult('✅ State information displayed', 'success');
            } catch (error) {
                showMathResult(`❌ State error: ${error.message}`, 'error');
            }
        }        function updateMathState(stationaryUnit) {
            const stateEl = document.getElementById('mathCurrentState');
            if (stateEl && stationaryUnit) {
                stateEl.textContent = stationaryUnit.toString();
                updateMathDimensions(stationaryUnit.d);

                // Update stability indicator
                const stabilityEl = document.getElementById('mathStability');
                if (stabilityEl) {
                    const isStable = stationaryUnit.x.every(Number.isFinite) &&
                                   Math.max(...stationaryUnit.x.map(Math.abs)) < 1000;

                    const indicator = stabilityEl.querySelector('.stability-indicator');
                    const text = stabilityEl.querySelector('span:last-child');

                    if (isStable) {
                        indicator.textContent = '🟢';
                        text.textContent = 'Stable';
                    } else {
                        indicator.textContent = '🔴';
                        text.textContent = 'Unstable';
                    }
                }
            }
        }

        function updateMathDimensions(dimensions) {
            const dimEl = document.getElementById('mathDimensions');
            if (dimEl) {
                dimEl.textContent = `${dimensions}D`;
            }
        }

        function showMathStatus(message) {
            const statusEl = document.getElementById('math-status-text');
            if (statusEl) {
                statusEl.textContent = message;
                setTimeout(() => {
                    statusEl.textContent = 'Ready';
                }, 3000);
            }
        }

        function showMathResult(message, type = 'info') {
            // Show in console
            const icon = type === 'error' ? '❌' : type === 'success' ? '✅' : type === 'warning' ? '⚠️' : 'ℹ️';
            console.log(`${icon} Math Engine: ${message}`);

            // Show in UI status briefly
            showMathStatus(message.substring(0, 50));

            // Could also show in chat if available
            if (window.studioManager?.chat) {
                window.studioManager.chat.announce(`🧮 ${message}`);
            }
        }

        // Toggle Math Panel Visibility
        function toggleMathPanel() {
            const panel = document.getElementById('mathOperationsPanel');
            if (panel) {
                const isHidden = panel.style.display === 'none';
                panel.style.display = isHidden ? 'block' : 'none';

                // Save preference
                localStorage.setItem('mathPanelVisible', isHidden ? 'true' : 'false');

                return !isHidden;
            }
            return false;
        }

        // Lexicon Engine UI Fixes
        function initLexiconEngineFixes() {
            // Add processing indicator
            const indicator = document.createElement('div');
            indicator.id = 'processing-indicator';
            indicator.className = 'processing-indicator';
            indicator.innerHTML = '<div class="processing-spinner"></div><div>Processing...</div>';
            document.body.appendChild(indicator);

            // Add visual feedback to all buttons
            const buttons = document.querySelectorAll('.math-btn, .action-btn, .desktop-btn, .send-btn');

            buttons.forEach(button => {
                button.addEventListener('click', (e) => {
                    // Show button press animation
                    e.target.classList.add('button-pressed');
                    setTimeout(() => {
                        e.target.classList.remove('button-pressed');
                    }, 300);

                    // Show processing indicator
                    indicator.classList.add('active');

                    // Simulate processing and show result
                    setTimeout(() => {
                        indicator.classList.remove('active');
                        showProcessingResult(e.target.textContent.trim());
                    }, 1000 + Math.random() * 1000);
                });
            });

            // Fix content overflow
            const contentAreas = document.querySelectorAll('.chat-content, .audio-engine-content');
            contentAreas.forEach(area => {
                area.style.overflowY = 'auto';
                area.style.maxHeight = 'calc(100vh - 200px)';
                area.style.paddingRight = '8px';
            });

            // Add input feedback
            const textInputs = document.querySelectorAll('input[type="text"], textarea');
            textInputs.forEach(input => {
                input.addEventListener('input', (e) => {
                    if (e.target.value && e.target.value.length > 5) {
                        e.target.style.borderColor = 'var(--accent)';
                        e.target.style.boxShadow = '0 0 6px rgba(124, 220, 255, 0.3)';

                        setTimeout(() => {
                            e.target.style.borderColor = '';
                            e.target.style.boxShadow = '';
                        }, 1000);
                    }
                });
            });

            console.log('🔧 Lexicon Engine UI fixes applied');
        }

        function showProcessingResult(buttonText) {
            const operations = {
                'ALIGN': 'Word alignment completed successfully',
                'PROJ': 'Annotation projection applied',
                'REFINE': 'Statistical refinement processed',
                'GRAPH': 'Synonym graph updated',
                'POLY': 'Polysemy resolution complete',
                'IRONY': 'Irony detection analyzed',
                'DIRECTION': 'Directional analysis complete',
                'RECOMPUTE': 'Recomputation pass finished',
                'Send': 'Message processed successfully',
                'Process Pipeline': 'Pipeline processing complete',
                'Open Canvas': 'Canvas interface activated'
            };

            const resultText = operations[buttonText] || `${buttonText} operation completed`;

            // Create or find result display area
            let resultArea = document.getElementById('result-display');
            if (!resultArea) {
                resultArea = document.createElement('div');
                resultArea.id = 'result-display';
                resultArea.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 20px;
                    max-width: 300px;
                    z-index: 1500;
                `;
                document.body.appendChild(resultArea);
            }

            // Create result message
            const resultDiv = document.createElement('div');
            resultDiv.className = 'result-highlight';
            resultDiv.textContent = resultText;
            resultDiv.style.cssText = `
                background: rgba(124, 220, 255, 0.1);
                border: 1px solid var(--accent);
                border-left: 3px solid var(--accent);
                padding: 12px;
                margin: 4px 0;
                border-radius: 6px;
                color: var(--fg);
                font-size: 0.9rem;
                animation: slideIn 0.3s ease;
            `;

            resultArea.appendChild(resultDiv);

            // Remove after delay
            setTimeout(() => {
                if (resultDiv.parentNode) {
                    resultDiv.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => {
                        if (resultDiv.parentNode) {
                            resultDiv.parentNode.removeChild(resultDiv);
                        }
                    }, 300);
                }
            }, 3000);
        }

        // Initialize Modern Systems
        let modernChat, chatToggle, recorderToggle, modernRecorder, audioEngineToggle, audioEngineUI, backgroundLLEX, desktopIntegration, ideaFormationVisualizer, queryIntegrationSystem;
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                chatToggle = new ChatToggle();
                recorderToggle = new RecorderToggle();
                audioEngineToggle = new AudioEngineToggle();
                backgroundLLEX = new BackgroundLLEXService(); // Full LLEX system instead of simple LLE
                modernChat = new ModernChat();
                modernRecorder = new ModernRecorder();
                audioEngineUI = new AudioSemanticEngineUI();
                desktopIntegration = new DesktopIntegration(); // Desktop-class features
                ideaFormationVisualizer = new IdeaFormationVisualizer(); // Visual idea formation system
                queryIntegrationSystem = new QueryIntegrationSystem(); // Compact semantic query processing
                multimodalEmbeddingSystem = new MultimodalEmbeddingSystem(); // Multimodal embedding system with unified space Z
                console.log('🌍 Modern Systems initialized: Chat Toggle, Recorder Toggle, Audio Engine Toggle, Background LLEX Service, Chat, Recorder, Audio Engine UI, Desktop Integration, Idea Formation Visualizer, Query Integration System, Multimodal Embedding System');

                // Make systems globally accessible
                window.backgroundLLEX = backgroundLLEX;
                window.desktopIntegration = desktopIntegration;
                window.ideaFormationVisualizer = ideaFormationVisualizer;
                window.queryIntegrationSystem = queryIntegrationSystem;
                window.multimodalEmbeddingSystem = multimodalEmbeddingSystem;

                // Wire up multimodal scaling controls
                const spatialScale = document.getElementById('spatial-scale');
                const temporalScale = document.getElementById('temporal-scale');
                const rateScale = document.getElementById('rate-scale');

                if (spatialScale) {
                    spatialScale.addEventListener('input', (e) => {
                        multimodalEmbeddingSystem.spatialScale = parseFloat(e.target.value);
                        document.querySelector('#spatial-scale + .scale-value').textContent = e.target.value;
                    });
                }

                if (temporalScale) {
                    temporalScale.addEventListener('input', (e) => {
                        multimodalEmbeddingSystem.temporalScale = parseFloat(e.target.value);
                        document.querySelector('#temporal-scale + .scale-value').textContent = e.target.value;
                    });
                }

                if (rateScale) {
                    rateScale.addEventListener('input', (e) => {
                        multimodalEmbeddingSystem.rateScale = parseFloat(e.target.value);
                        document.querySelector('#rate-scale + .scale-value').textContent = e.target.value;
                    });
                }

                // Initialize Lexicon Engine UI Fixes
                initLexiconEngineFixes();

                // Initialize Math Panel
                const mathPanelVisible = localStorage.getItem('mathPanelVisible') !== 'false';
                const mathPanel = document.getElementById('mathOperationsPanel');
                if (mathPanel) {
                    mathPanel.style.display = mathPanelVisible ? 'block' : 'none';
                }

                // Expose StudioManager globally for math engine access
                if (window.studioManager) {
                    Utils.log('🧮 StudioManager exposed globally for math engine integration', 'info');
                }
            }, 500);
        });

        // Initialize Studio Manager
        let studioManager;
        document.addEventListener('DOMContentLoaded', () => {
            studioManager = new StudioManager();
            window.studioManager = studioManager; // Global access for math functions
        });

        // Global error handling
        window.addEventListener('error', (event) => {
            Utils.log(`Global error: ${event.error.message}`, 'error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            Utils.log(`Unhandled promise rejection: ${event.reason}`, 'error');
        });
    </script>
</body>
</html>
