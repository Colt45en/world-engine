<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HSV Wheel + Shader Playground</title>
  <style>
    :root {
      --bg: #0f0f10;
      --panel: #1c1c20;
      --panel2: #131316;
      --text: #e9e9ee;
      --muted: #a0a0aa;
      --ring: rgba(255,255,255,0.12);
      --ring-strong: rgba(99,102,241,0.9);
    }
    html, body { margin: 0; background: var(--bg); color: var(--text); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; display: grid; gap: 16px; grid-template-columns: 1fr; }
    @media (min-width: 1024px) { .wrap { grid-template-columns: 1fr 1fr; } }
    h1 { font-size: 22px; margin: 0; }
    h2 { font-size: 16px; margin: 0; }
    .hdr { grid-column: 1 / -1; display:flex; justify-content:space-between; align-items:center; }
    .card { background: linear-gradient(180deg, var(--panel), var(--panel2)); border-radius: 20px; padding: 16px; box-shadow: 0 4px 28px rgba(0,0,0,0.35); }
    .row { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    .btn { background:#2a2a30; color:var(--text); border:0; padding:8px 12px; border-radius:14px; cursor:pointer; }
    .btn:hover { background:#34343b; }
    .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    .grid4 { display:grid; grid-template-columns: repeat(4, 1fr); gap:12px; }
    .muted { color: var(--muted); font-size: 12px; }
    .pill { background:#101014; border:1px solid var(--ring); border-radius: 12px; padding: 8px; }
    input[type="text"] { background:#101014; color:var(--text); border:1px solid var(--ring); border-radius:12px; padding:8px 10px; }
    input[type="checkbox"] { accent-color:#6366f1; }
    .slider-track { position:relative; height:44px; border-radius:14px; outline:none; }
    .slider-knob { position:absolute; top:50%; width:24px; height:24px; border-radius:50%; border:2px solid white; transform:translate(-50%, -50%); box-shadow: 0 0 0 1px rgba(0,0,0,.5); pointer-events:none; }
    .block { border-radius:16px; height:110px; position:relative; border:1px solid var(--ring); overflow:hidden; }
    .block .label { position:absolute; left:8px; right:8px; bottom:8px; display:flex; justify-content:space-between; font-weight:600; font-size:13px; }
    .block .controls { position:absolute; top:8px; right:8px; display:flex; gap:6px; opacity:0; transition:opacity .15s; }
    .block:hover .controls { opacity:1; }
    .holderbar { display:flex; gap:8px; overflow:auto; padding:6px 0; }
    .holderbtn { border-radius:10px; padding:6px 10px; background:#101014; border:1px solid var(--ring); }
    .holderbtn.on { background:#6366f1; border-color:#6366f1; }
    .live { position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden; }
    code { background:#101014; padding:2px 4px; border-radius:6px; border:1px solid var(--ring); }
    .hash { position:absolute; inset:0; background-image: repeating-linear-gradient(45deg, rgba(0,0,0,0.28) 0, rgba(0,0,0,0.28) 4px, transparent 4px, transparent 8px); border-radius:14px; pointer-events:none; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="hdr">
      <h1>HSV Wheel + Brightness Slider</h1>
      <button id="startTest" class="btn">Start 6-Swatch Test</button>
    </header>

    <section class="card" style="grid-column:1 / -1">
      <div class="row" style="justify-content:space-between">
        <div class="muted">Holders (1–10): press a number to switch</div>
        <div id="holderBtns" class="holderbar"></div>
      </div>
      <div class="row" style="margin-top:10px">
        <input id="holderName" type="text" placeholder="Rename current holder" />
        <button id="renameHolder" class="btn">Rename</button>
      </div>
    </section>

    <section class="card">
      <div class="row" style="gap:24px; align-items:flex-start">
        <div style="position:relative; width:320px; height:320px">
          <canvas id="wheel" width="320" height="320" tabindex="0" aria-label="Hue wheel"></canvas>
          <div id="wheelMarker" style="position:absolute;width:24px;height:24px;border-radius:50%;border:2px solid white;box-shadow:0 0 0 2px rgba(0,0,0,0.5);pointer-events:none;"></div>
        </div>
        <div style="flex:1; min-width:260px">
          <div class="pill">
            <div class="muted">Brightness</div>
            <div id="vSlider" class="slider-track" tabindex="0" role="slider" aria-label="Brightness slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <canvas id="vBg" width="640" height="44" style="width:100%;height:44px;border-radius:14px;"></canvas>
              <div id="vKnob" class="slider-knob"></div>
              <div id="vHash" class="hash" hidden></div>
            </div>
          </div>
          <div class="grid2" style="margin-top:12px">
            <div class="pill"><div class="muted">Hue</div><div id="readH"></div></div>
            <div class="pill"><div class="muted">Saturation</div><div id="readS"></div></div>
            <div class="pill"><div class="muted">Brightness</div><div id="readV"></div></div>
            <div class="pill"><div class="muted">Hex</div><div id="readHex" style="font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;"></div></div>
            <div class="pill"><div class="muted">Luminance (Y)</div><div id="readLum"></div></div>
            <div class="pill"><div class="muted">Friendly</div><div id="readName"></div></div>
          </div>
          <div class="row" style="margin-top:10px">
            <label class="row" style="gap:6px"><input id="autoContrast" type="checkbox" /><span class="muted">Auto-contrast (≥ 4.5:1 vs BG)</span></label>
            <label class="row" style="gap:6px"><input id="bloom" type="checkbox" /><span class="muted">Bloom</span></label>
            <label class="row" style="gap:6px"><input id="dot" type="checkbox" /><span class="muted">Dot</span></label>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="muted">Background</div>
          <input id="bgHex" type="text" value="#111111" />
        </div>
        <div class="muted">Contrast ratio
          <div id="readCR" style="font-size:18px"></div>
        </div>
      </div>
      <div id="preview" style="position:relative; height:260px; margin-top:12px; border-radius:18px; overflow:hidden;"></div>

      <div class="pill" style="margin-top:12px">
        <div class="row">
          <div class="muted">Target</div>
          <div id="targetSwatch" style="width:28px;height:28px;border-radius:6px;border:1px solid var(--ring)"></div>
          <div id="testStatus" class="muted">(start test to measure TTC, errors, keyboard-only)</div>
        </div>
        <div id="resultsWrap" style="overflow:auto; margin-top:8px; display:none;">
          <table id="results" style="width:100%; border-collapse:collapse; font-size:12px">
            <thead><tr>
              <th style="text-align:left;padding:6px">#</th>
              <th style="text-align:left;padding:6px">Target</th>
              <th style="text-align:left;padding:6px">TTC (s)</th>
              <th style="text-align:left;padding:6px">KB-only</th>
              <th style="text-align:left;padding:6px">Ptr path (px)</th>
              <th style="text-align:left;padding:6px">Dwell (ms)</th>
              <th style="text-align:left;padding:6px">Undo</th>
            </tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between">
        <h2>Linked Color Blocks</h2>
        <div class="muted">Click a block to navigate</div>
      </div>
      <div class="row" style="align-items:flex-end; margin-top:8px">
        <div style="flex:1; min-width:140px">
          <div class="muted">Label</div>
          <input id="blkLabel" type="text" placeholder="e.g., Docs, Gallery, #section" />
        </div>
        <div style="flex:2; min-width:260px">
          <div class="muted">Link</div>
          <input id="blkUrl" type="text" placeholder="https://, /route, or #anchor" />
        </div>
        <label class="row" style="gap:6px">
          <input id="blkNewTab" type="checkbox" checked />
          <span class="muted">Open in new tab</span>
        </label>
        <button id="addBlock" class="btn">Add block from current color</button>
      </div>
      <div id="blocks" class="grid4" style="margin-top:12px"></div>
    </section>

    <section class="card" style="grid-column:1 / -1">
      <div class="row" style="justify-content:space-between; gap:8px; flex-wrap:wrap">
        <h2>Fragment Shader Playground</h2>
        <span class="muted">Edit a GLSL fragment shader string; uniforms: <code>u_time</code>, <code>u_resolution</code>, <code>u_color</code></span>
      </div>
      <div class="row" style="gap:12px; margin-top:10px; align-items:flex-start">
        <div style="flex:1; min-width:280px">
          <div class="row">
            <label class="row" style="gap:6px"><input id="useGL2" type="checkbox" checked /><span class="muted">Use WebGL2 (#version 300 es)</span></label>
            <label class="row" style="gap:6px"><input id="animate" type="checkbox" checked /><span class="muted">Animate</span></label>
            <button id="resetShader" class="btn">Reset to sample</button>
          </div>
          <div class="muted" style="margin-top:6px">Fragment shader source (string)</div>
          <textarea id="fragSrc" spellcheck="false" style="width:100%; min-height:220px; background:#101014; color:var(--text); border:1px solid var(--ring); border-radius:12px; padding:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px;"></textarea>
          <pre id="shaderErr" class="muted" style="white-space:pre-wrap; color:#ff9aa2; background:#3b0d0d33; border-radius:12px; padding:8px; margin-top:6px;"></pre>
        </div>
        <div style="flex:1; min-width:280px">
          <canvas id="glCanvas" class="block" style="height:340px"></canvas>
          <div class="muted" style="margin-top:6px">Tip: WebGL2 supports <code>#version 300 es</code> + <code>out vec4 fragColor</code>; WebGL1 uses <code>gl_FragColor</code>.</div>
        </div>
      </div>
    </section>

    <div id="live" class="live" aria-live="polite" aria-atomic="true"></div>
  </div>

  <script type="module">
    const TAU = Math.PI * 2;
    const clamp = (x, a, b) => Math.min(b, Math.max(a, x));
    const srgbToLinear = (u) => (u <= 0.04045 ? u / 12.92 : Math.pow((u + 0.055) / 1.055, 2.4));
    const linearToSrgb = (u) => (u <= 0.0031308 ? 12.92 * u : 1.055 * Math.pow(u, 1/2.4) - 0.055);

    function hsvToLinearRgb(h, s, v) {
      const c = v * s;
      const hh = (h % 360) / 60;
      const x = c * (1 - Math.abs((hh % 2) - 1));
      let r1 = 0, g1 = 0, b1 = 0;
      if (hh < 1) [r1, g1, b1] = [c, x, 0];
      else if (hh < 2) [r1, g1, b1] = [x, c, 0];
      else if (hh < 3) [r1, g1, b1] = [0, c, x];
      else if (hh < 4) [r1, g1, b1] = [0, x, c];
      else if (hh < 5) [r1, g1, b1] = [x, 0, c];
      else [r1, g1, b1] = [c, 0, x];
      const m = v - c;
      const srgb = [r1 + m, g1 + m, b1 + m];
      return srgb.map(linearize);
      function linearize(value) { return srgbToLinear(clamp(value, 0, 1)); }
    }

    function linRgbToHex([r, g, b]) {
      const sr = clamp(Math.round(linearToSrgb(r) * 255), 0, 255);
      const sg = clamp(Math.round(linearToSrgb(g) * 255), 0, 255);
      const sb = clamp(Math.round(linearToSrgb(b) * 255), 0, 255);
      return '#' + [sr, sg, sb].map(n => n.toString(16).padStart(2, '0')).join('').toUpperCase();
    }

    function linRgbFromHex(hex) {
      const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex || '');
      if (!m) return [0, 0, 0];
      const [r, g, b] = [m[1], m[2], m[3]].map(x => parseInt(x, 16) / 255);
      return [r, g, b].map(srgbToLinear);
    }

    function relativeLuminance([r, g, b]) { return 0.2126 * r + 0.7152 * g + 0.0722 * b; }
    function contrastRatio(L1, L2) { const a = Math.max(L1, L2) + 0.05, b = Math.min(L1, L2) + 0.05; return a / b; }
    function textColorForHex(hex) {
      const y = relativeLuminance(linRgbFromHex(hex));
      return contrastRatio(1, y) >= contrastRatio(0, y) ? '#FFFFFF' : '#000000';
    }

    const NAMED = [
      { name: 'Black', hex: '#000000' }, { name: 'White', hex: '#FFFFFF' },
      { name: 'Red', hex: '#FF0000' }, { name: 'Green', hex: '#00FF00' },
      { name: 'Blue', hex: '#0000FF' }, { name: 'Yellow', hex: '#FFFF00' },
      { name: 'Cyan', hex: '#00FFFF' }, { name: 'Magenta', hex: '#FF00FF' },
      { name: 'Orange', hex: '#FFA500' }, { name: 'Pink', hex: '#FFC0CB' },
    ];

    function simpleNearestName(hex) {
      const [r, g, b] = linRgbFromHex(hex).map(linearToSrgb);
      let best = { d: Number.POSITIVE_INFINITY, name: hex };
      for (const n of NAMED) {
        const [nr, ng, nb] = linRgbFromHex(n.hex).map(linearToSrgb);
        const d = (nr - r) ** 2 + (ng - g) ** 2 + (nb - b) ** 2;
        if (d < best.d) best = { d, name: n.name };
      }
      return best.d < 0.15 ? best.name : hex;
    }

    function linRgbToXyz([r, g, b]) {
      return [
        r * 0.4124564 + g * 0.3575761 + b * 0.1804375,
        r * 0.2126729 + g * 0.7151522 + b * 0.0721750,
        r * 0.0193339 + g * 0.1191920 + b * 0.9503041,
      ];
    }

    function xyzToLab([X, Y, Z]) {
      const Xn = 0.95047, Yn = 1.0, Zn = 1.08883;
      const f = t => t > 216 / 24389 ? Math.cbrt(t) : (841 / 108) * t + 4 / 29;
      const fx = f(X / Xn), fy = f(Y / Yn), fz = f(Z / Zn);
      return [116 * fy - 16, 500 * (fx - fy), 200 * (fy - fz)];
    }

    function deltaE2000(L1, L2) {
      const [L1v, a1, b1] = L1, [L2v, a2, b2] = L2;
      const avgLp = (L1v + L2v) / 2;
      const C1 = Math.hypot(a1, b1), C2 = Math.hypot(a2, b2), avgC = (C1 + C2) / 2;
      const G = 0.5 * (1 - Math.sqrt(Math.pow(avgC, 7) / (Math.pow(avgC, 7) + Math.pow(25, 7))));
      const a1p = (1 + G) * a1, a2p = (1 + G) * a2;
      const C1p = Math.hypot(a1p, b1), C2p = Math.hypot(a2p, b2), avgCp = (C1p + C2p) / 2;
      const h1p = Math.atan2(b1, a1p) + (Math.atan2(b1, a1p) < 0 ? TAU : 0);
      const h2p = Math.atan2(b2, a2p) + (Math.atan2(b2, a2p) < 0 ? TAU : 0);
      const avgHp = Math.abs(h1p - h2p) > Math.PI ? (h1p + h2p + TAU) / 2 : (h1p + h2p) / 2;
      const T = 1 - 0.17 * Math.cos(avgHp - Math.PI / 6)
        + 0.24 * Math.cos(2 * avgHp)
        + 0.32 * Math.cos(3 * avgHp + Math.PI / 30)
        - 0.20 * Math.cos(4 * avgHp - 63 * Math.PI / 180);
      let dhp = h2p - h1p;
      if (Math.abs(dhp) > Math.PI) dhp -= Math.sign(dhp) * TAU;
      const dLp = L2v - L1v, dCp = C2p - C1p, dHp = 2 * Math.sqrt(C1p * C2p) * Math.sin(dhp / 2);
      const Sl = 1 + (0.015 * Math.pow(avgLp - 50, 2)) / Math.sqrt(20 + Math.pow(avgLp - 50, 2));
      const Sc = 1 + 0.045 * avgCp;
      const Sh = 1 + 0.015 * avgCp * T;
      const delTheta = (30 * Math.PI / 180) * Math.exp(-Math.pow((avgHp * 180 / Math.PI - 275) / 25, 2));
      const Rc = 2 * Math.sqrt(Math.pow(avgCp, 7) / (Math.pow(avgCp, 7) + Math.pow(25, 7)));
      const Rt = -Rc * Math.sin(2 * delTheta);
      return Math.sqrt(
        Math.pow(dLp / Sl, 2) +
        Math.pow(dCp / Sc, 2) +
        Math.pow(dHp / Sh, 2) +
        Rt * (dCp / Sc) * (dHp / Sh)
      );
    }

    function deltaE(hex1, hex2) {
      const lab1 = xyzToLab(linRgbToXyz(linRgbFromHex(hex1)));
      const lab2 = xyzToLab(linRgbToXyz(linRgbFromHex(hex2)));
      return deltaE2000(lab1, lab2);
    }

    let h = 312, s = 0.60, v = 0.24;
    let bgHex = '#111111';
    let autoContrast = false, bloom = false, dot = false;
    let holder = load('activeHolder', 1);
    let holderNames = load('holderNames', {});
    let blocks = loadScene(holder).blocks;
    const TEST_SWATCHES = ['#FF5733', '#2ECC71', '#3498DB', '#9B59B6', '#F1C40F', '#1ABC9C'];

    const el = (id) => document.getElementById(id);
    const wheel = el('wheel');
    const wheelMarker = el('wheelMarker');
    const vTrack = el('vSlider'), vBg = el('vBg'), vKnob = el('vKnob'), vHash = el('vHash');
    const readH = el('readH'), readS = el('readS'), readV = el('readV'), readHex = el('readHex'), readLum = el('readLum'), readName = el('readName'), readCR = el('readCR');
    const bgHexInput = el('bgHex'), live = el('live');

    el('autoContrast').addEventListener('change', e => { autoContrast = e.target.checked; renderAll(); saveScene(); });
    el('bloom').addEventListener('change', e => { bloom = e.target.checked; renderPreview(); saveScene(); });
    el('dot').addEventListener('change', e => { dot = e.target.checked; renderPreview(); saveScene(); });
    bgHexInput.addEventListener('input', e => { bgHex = e.target.value || '#111111'; renderAll(); saveScene(); });

    const blocksWrap = el('blocks');
    const blkLabel = el('blkLabel'), blkUrl = el('blkUrl'), blkNewTab = el('blkNewTab');
    el('addBlock').onclick = () => {
      if (!blkUrl.value.trim()) return;
      const id = String(Date.now());
      blocks.push({ id, label: blkLabel.value.trim() || currentHex().toUpperCase(), hex: currentHex(), url: blkUrl.value.trim(), newTab: blkNewTab.checked });
      blkLabel.value = '';
      blkUrl.value = '';
      renderBlocks();
      saveScene();
    };

    const holderBtns = el('holderBtns');
    const holderName = el('holderName'), renameHolder = el('renameHolder');
    renameHolder.onclick = () => {
      const nm = holderName.value.trim() || `Holder ${holder}`;
      holderNames[String(holder)] = nm;
      save('holderNames', holderNames);
      renderHolderBar();
    };

    window.addEventListener('keydown', (e) => {
      const tag = (e.target && e.target.tagName) || '';
      if ([ 'INPUT', 'TEXTAREA', 'SELECT' ].includes(tag)) return;
      if (e.ctrlKey || e.altKey || e.metaKey) return;
      if (/^[0-9]$/.test(e.key)) {
        let n = parseInt(e.key, 10);
        if (n === 0) n = 10;
        if (n >= 1 && n <= 10) switchHolder(n);
      }
    });

    function renderHolderBar() {
      holderBtns.innerHTML = '';
      for (let i = 1; i <= 10; i++) {
        const b = document.createElement('button');
        b.className = 'holderbtn' + (i === holder ? ' on' : '');
        b.textContent = holderNames[String(i)] || String(i);
        b.onclick = () => switchHolder(i);
        holderBtns.appendChild(b);
      }
      holderName.value = holderNames[String(holder)] || `Holder ${holder}`;
    }

    function switchHolder(n) {
      save('activeHolder', n);
      holder = n;
      const sc = loadScene(holder);
      h = sc.h; s = sc.s; v = sc.v; bgHex = sc.bgHex; autoContrast = sc.autoContrast; bloom = sc.bloom; dot = sc.dot; blocks = sc.blocks || [];
      el('autoContrast').checked = autoContrast;
      el('bloom').checked = bloom;
      el('dot').checked = dot;
      bgHexInput.value = bgHex;
      renderHolderBar();
      renderAll();
    }

    function saveScene() {
      const sc = { blocks, h, s, v, bgHex, autoContrast, bloom, dot };
      save(sceneKey(holder), sc);
    }

    let lastAnnounce = 0, queued = 0;
    function announce(text) {
      const now = performance.now();
      const minGap = 500;
      if (now - lastAnnounce >= minGap) {
        lastAnnounce = now;
        live.textContent = '';
        requestAnimationFrame(() => live.textContent = text);
      } else {
        clearTimeout(queued);
        queued = setTimeout(() => {
          lastAnnounce = performance.now();
          live.textContent = '';
          requestAnimationFrame(() => live.textContent = text);
        }, minGap - (now - lastAnnounce));
      }
    }

    drawWheel();
    function drawWheel() {
      const ctx = wheel.getContext('2d', { willReadFrequently: true });
      const W = wheel.width, H = wheel.height, cx = W / 2, cy = H / 2, R = Math.min(cx, cy);
      const img = ctx.createImageData(W, H), d = img.data;
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          const dx = x - cx, dy = y - cy, r = Math.hypot(dx, dy) / R, i = (y * W + x) * 4;
          if (r <= 1) {
            let hue = Math.atan2(dy, dx) * 180 / Math.PI;
            if (hue < 0) hue += 360;
            const sat = clamp(r, 0, 1);
            const lin = hsvToLinearRgb(hue, sat, 1);
            d[i] = Math.round(linearToSrgb(lin[0]) * 255);
            d[i + 1] = Math.round(linearToSrgb(lin[1]) * 255);
            d[i + 2] = Math.round(linearToSrgb(lin[2]) * 255);
            d[i + 3] = 255;
          } else d[i] = d[i + 1] = d[i + 2] = d[i + 3] = 0;
        }
      }
      ctx.putImageData(img, 0, 0);
    }

    function wheelSetFromEvent(clientX, clientY) {
      const r = wheel.getBoundingClientRect();
      const x = clientX - r.left, y = clientY - r.top;
      const cx = r.width / 2, cy = r.height / 2, dx = x - cx, dy = y - cy, R = Math.min(cx, cy);
      let radius = Math.hypot(dx, dy) / R;
      let hue = Math.atan2(dy, dx) * 180 / Math.PI;
      if (hue < 0) hue += 360;
      let sat = clamp(radius, 0, 1);
      if (sat < 0.08) sat = 0;
      h = hue;
      s = sat;
      renderAll();
      saveScene();
    }

    let draggingWheel = false;
    wheel.addEventListener('pointerdown', e => { draggingWheel = true; wheel.setPointerCapture(e.pointerId); wheelSetFromEvent(e.clientX, e.clientY); });
    window.addEventListener('pointermove', e => { if (draggingWheel) wheelSetFromEvent(e.clientX, e.clientY); });
    window.addEventListener('pointerup', e => { draggingWheel = false; try { wheel.releasePointerCapture(e.pointerId); } catch { /* noop */ } });
    wheel.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        e.preventDefault();
        const delta = (e.shiftKey ? 10 : 1) * (e.key === 'ArrowLeft' ? -1 : 1);
        h = (h + delta + 360) % 360;
        renderAll();
        saveScene();
      }
    });

    function drawVBg() {
      const ctx = vBg.getContext('2d'), W = vBg.width, H = vBg.height, data = ctx.createImageData(W, H), d = data.data;
      let clipped = false;
      for (let x = 0; x < W; x++) {
        const vv = x / (W - 1);
        const lin = hsvToLinearRgb(h, s, vv);
        if (lin.some(c => c < 0 || c > 1)) clipped = true;
        const sr = [linearToSrgb(lin[0]), linearToSrgb(lin[1]), linearToSrgb(lin[2])];
        for (let y = 0; y < H; y++) {
          const i = (y * W + x) * 4;
          d[i] = Math.round(sr[0] * 255);
          d[i + 1] = Math.round(sr[1] * 255);
          d[i + 2] = Math.round(sr[2] * 255);
          d[i + 3] = 255;
        }
      }
      ctx.putImageData(data, 0, 0);
      vHash.hidden = !clipped;
    }

    function setV_fromX(clientX) {
      const r = vTrack.getBoundingClientRect();
      const x = clamp(clientX - r.left, 0, r.width);
      v = x / r.width;
      renderAll();
      saveScene();
    }

    let draggingV = false;
    vTrack.addEventListener('pointerdown', e => { draggingV = true; vTrack.setPointerCapture(e.pointerId); setV_fromX(e.clientX); metrics.pointerStart(e); });
    window.addEventListener('pointermove', e => { if (draggingV) { setV_fromX(e.clientX); metrics.pointerMove(e); } });
    window.addEventListener('pointerup', e => { draggingV = false; try { vTrack.releasePointerCapture(e.pointerId); } catch { /* noop */ } metrics.pointerEnd(e); });
    vTrack.addEventListener('keydown', e => {
      let dv = 0, handled = false;
      if (e.key === 'ArrowUp') { dv = e.shiftKey ? 0.05 : 0.01; handled = true; }
      if (e.key === 'ArrowDown') { dv = e.shiftKey ? -0.05 : -0.01; handled = true; }
      if (e.key === 'Home') { v = 0; handled = true; }
      if (e.key === 'End') { v = 1; handled = true; }
      if (handled) {
        e.preventDefault();
        v = clamp(v + dv, 0, 1);
        metrics.valueChange(dv);
        renderAll();
        saveScene();
      }
    });
    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'c') {
        v = clamp(v, 0, 1);
        renderAll();
        saveScene();
      }
    });

    function currentLin() { return hsvToLinearRgb(h, s, autoContrast ? adjustedV() : v); }
    function currentHex() { return linRgbToHex(currentLin()); }
    function adjustedV() {
      const bgLin = linRgbFromHex(bgHex);
      let lo = 0, hi = 1, best = v;
      for (let i = 0; i < 16; i++) {
        const mid = (lo + hi) / 2;
        const lin = hsvToLinearRgb(h, s, mid);
        const cr = contrastRatio(relativeLuminance(lin), relativeLuminance(bgLin));
        if (cr >= 4.5) {
          best = mid;
          hi = mid;
        } else {
          lo = mid;
        }
      }
      return best;
    }

    function renderWheelMarker() {
      const R = 150, r = s * R, rad = h * Math.PI / 180;
      const x = 160 + r * Math.cos(rad), y = 160 + r * Math.sin(rad);
      wheelMarker.style.left = (x - 12) + 'px';
      wheelMarker.style.top = (y - 12) + 'px';
    }

    function renderReadouts() {
      const hex = currentHex(), lin = currentLin();
      readH.textContent = Math.round(h) + '°';
      readS.textContent = Math.round(s * 100) + '%';
      readV.textContent = Math.round((autoContrast ? adjustedV() : v) * 100) + '%';
      readHex.textContent = hex;
      readLum.textContent = relativeLuminance(lin).toFixed(3);
      readName.textContent = simpleNearestName(hex);
      const bgL = relativeLuminance(linRgbFromHex(bgHex));
      readCR.textContent = contrastRatio(relativeLuminance(lin), bgL).toFixed(2) + ' : 1';
      vTrack.setAttribute('aria-valuenow', String(Math.round((autoContrast ? adjustedV() : v) * 100)));
      announce(`Hue ${Math.round(h)}°, Brightness ${Math.round((autoContrast ? adjustedV() : v) * 100)}%, ${hex}`);
    }

    function renderVKnob() {
      vKnob.style.left = ((autoContrast ? adjustedV() : v) * 100).toFixed(2) + '%';
    }

    function renderPreview() {
      const prev = document.getElementById('preview');
      prev.style.background = bgHex;
      prev.innerHTML = '';
      const glow = document.createElement('div');
      glow.style.position = 'absolute'; glow.style.inset = '16px';
      glow.style.borderRadius = '18px'; glow.style.boxShadow = '0 8px 30px rgba(0,0,0,.4)';
      glow.style.background = currentHex();
      glow.style.filter = bloom ? 'blur(8px) brightness(1.2)' : 'none';
      const dotEl = document.createElement('div');
      dotEl.style.position = 'absolute'; dotEl.style.inset = '0'; dotEl.style.display = 'flex'; dotEl.style.alignItems = 'center'; dotEl.style.justifyContent = 'center';
      const ring = document.createElement('div');
      ring.style.width = '120px'; ring.style.height = '120px'; ring.style.borderRadius = '50%'; ring.style.border = '4px solid rgba(255,255,255,.2)';
      ring.style.background = currentHex(); ring.style.position = 'relative';
      if (dot) {
        const d = document.createElement('div');
        d.style.width = '8px'; d.style.height = '8px'; d.style.borderRadius = '50%'; d.style.background = 'rgba(255,255,255,.9)';
        d.style.position = 'absolute'; d.style.left = '50%'; d.style.top = '50%'; d.style.transform = 'translate(-50%,-50%)';
        ring.appendChild(d);
      }
      dotEl.appendChild(ring);
      prev.appendChild(glow);
      prev.appendChild(dotEl);
    }

    function renderBlocks() {
      blocksWrap.innerHTML = '';
      for (const b of blocks) {
        const a = document.createElement('a');
        a.href = b.url;
        if (b.newTab) { a.target = '_blank'; a.rel = 'noopener noreferrer'; }
        a.className = 'block';
        a.style.background = b.hex;
        a.title = (b.label || b.hex) + ' → ' + b.url;
        a.setAttribute('role', 'link');
        a.setAttribute('aria-label', `${b.label || b.hex} — opens ${b.url}`);
        const label = document.createElement('div'); label.className = 'label'; label.style.color = textColorForHex(b.hex);
        const spanL = document.createElement('span'); spanL.textContent = (b.label || b.hex);
        const spanH = document.createElement('span'); spanH.textContent = b.hex.toUpperCase(); spanH.style.opacity = '.85'; spanH.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        label.appendChild(spanL); label.appendChild(spanH);
        const controls = document.createElement('div'); controls.className = 'controls';
        const paint = document.createElement('button'); paint.className = 'btn'; paint.style.padding = '4px 8px'; paint.textContent = 'Paint';
        paint.onclick = (e) => { e.preventDefault(); e.stopPropagation(); b.hex = currentHex(); renderBlocks(); saveScene(); };
        const remove = document.createElement('button'); remove.className = 'btn'; remove.style.padding = '4px 8px'; remove.textContent = 'Remove';
        remove.onclick = (e) => { e.preventDefault(); e.stopPropagation(); blocks = blocks.filter(x => x.id !== b.id); renderBlocks(); saveScene(); };
        controls.appendChild(paint); controls.appendChild(remove);
        a.appendChild(label);
        a.appendChild(controls);
        blocksWrap.appendChild(a);
      }
    }

    const metrics = (() => {
      let ptrCount = 0, lastPtr = null, path = 0, dwell = 0, lastMoveT = 0, undo = 0, lastDV = 0, lastChangeT = 0;
      const onValueChange = (dv) => {
        const now = performance.now();
        if (lastDV !== 0 && Math.sign(dv) !== 0 && Math.sign(dv) !== Math.sign(lastDV) && (now - lastChangeT) <= 1000) undo++;
        lastDV = Math.sign(dv);
        lastChangeT = now;
        if (firstInputTime == null) firstInputTime = now;
      };
      const onStart = (e) => { ptrCount++; lastPtr = { x: e.clientX, y: e.clientY }; lastMoveT = e.timeStamp; };
      const onMove = (e) => { if (!lastPtr) return; path += Math.hypot(e.clientX - lastPtr.x, e.clientY - lastPtr.y); dwell += (e.timeStamp - lastMoveT); lastPtr = { x: e.clientX, y: e.clientY }; lastMoveT = e.timeStamp; };
      const onEnd = () => {};
      const reset = () => { ptrCount = 0; lastPtr = null; path = 0; dwell = 0; lastMoveT = 0; undo = 0; lastDV = 0; lastChangeT = 0; };
      const snapshot = () => ({ ptrCount, path: path.toFixed(1), dwell: Math.round(dwell), undo });
      return {
        pointerStart: onStart,
        pointerMove: onMove,
        pointerEnd: onEnd,
        valueChange: onValueChange,
        reset,
        snapshot,
        get ptrCount() { return ptrCount; },
      };
    })();

    let testActive = false, targetIdx = 0, targetHex = '#000', firstInputTime = null, holdTimer = null, results = [];
    const targetSwatch = el('targetSwatch'), testStatus = el('testStatus'), resultsWrap = el('resultsWrap'), resultsTable = el('results').querySelector('tbody');

    function startTest() {
      testActive = true;
      targetIdx = 0;
      results = [];
      metrics.reset();
      firstInputTime = null;
      targetHex = TEST_SWATCHES[targetIdx];
      targetSwatch.style.background = targetHex;
      testStatus.textContent = `Swatch 1 / ${TEST_SWATCHES.length}`;
      resultsWrap.style.display = 'none';
      resultsTable.innerHTML = '';
      el('startTest').textContent = 'Stop Test';
    }

    function stopTest() {
      testActive = false;
      testStatus.textContent = '(start test to measure TTC, errors, keyboard-only)';
      el('startTest').textContent = 'Start 6-Swatch Test';
    }

    el('startTest').onclick = () => testActive ? stopTest() : startTest();

    function maybeFinishSwatch() {
      if (!testActive || firstInputTime == null) return;
      const match = deltaE(currentHex(), targetHex) <= 1.5;
      if (match && !holdTimer) {
        holdTimer = setTimeout(() => {
          const ttc = (performance.now() - firstInputTime) / 1000;
          const snap = metrics.snapshot();
          const rec = { idx: targetIdx + 1, targetHex, ttc, kbOnly: metrics.ptrCount === 0, path: snap.path, dwell: snap.dwell, undo: snap.undo };
          results.push(rec);
          const tr = document.createElement('tr'); tr.innerHTML =
            `<td style="padding:6px">${rec.idx}</td>
             <td style="padding:6px;font-family:monospace">${rec.targetHex}</td>
             <td style="padding:6px">${rec.ttc.toFixed(2)}</td>
             <td style="padding:6px">${rec.kbOnly ? 'Yes' : 'No'}</td>
             <td style="padding:6px">${rec.path}</td>
             <td style="padding:6px">${rec.dwell}</td>
             <td style="padding:6px">${rec.undo}</td>`;
          resultsTable.appendChild(tr);
          targetIdx++;
          if (targetIdx < TEST_SWATCHES.length) {
            targetHex = TEST_SWATCHES[targetIdx];
            targetSwatch.style.background = targetHex;
            testStatus.textContent = `Swatch ${targetIdx + 1} / ${TEST_SWATCHES.length}`;
            metrics.reset();
            firstInputTime = null;
          } else {
            resultsWrap.style.display = 'block';
            stopTest();
          }
          holdTimer = null;
        }, 600);
      } else if (!match && holdTimer) {
        clearTimeout(holdTimer);
        holdTimer = null;
      }
    }

    const glCanvas = el('glCanvas'), fragSrc = el('fragSrc'), shaderErr = el('shaderErr');
    const useGL2 = el('useGL2'), animate = el('animate'), resetShader = el('resetShader');
    const DEFAULT_VS_300ES = `#version 300 es
precision highp float;
layout(location=0) in vec2 a_position;
out vec2 v_uv;
void main(){ v_uv = a_position*0.5 + 0.5; gl_Position = vec4(a_position,0.0,1.0); }`;
    const DEFAULT_VS_100ES = `precision highp float;
attribute vec2 a_position; varying vec2 v_uv;
void main(){ v_uv = a_position*0.5 + 0.5; gl_Position = vec4(a_position,0.0,1.0); }`;
    const DEFAULT_FS_300ES = `#version 300 es
precision highp float; out vec4 fragColor; in vec2 v_uv;
uniform vec2 u_resolution; uniform float u_time; uniform vec4 u_color;
void main(){ vec2 uv=v_uv; vec3 base=vec3(uv, 0.5+0.5*sin(u_time)); vec3 col=mix(base,u_color.rgb,0.25); fragColor=vec4(col,1.0); }`;
    const DEFAULT_FS_100ES = `precision highp float; varying vec2 v_uv;
uniform vec2 u_resolution; uniform float u_time; uniform vec4 u_color;
void main(){ vec2 uv=v_uv; vec3 base=vec3(uv, 0.5+0.5*sin(u_time)); vec3 col=mix(base,u_color.rgb,0.25); gl_FragColor=vec4(col,1.0); }`;
    fragSrc.value = DEFAULT_FS_300ES;

    let gl = null, program = null, aPos = 0, uTime = null, uRes = null, uColor = null, buf = null, raf = 0, start = 0;

    function initGL() {
      shaderErr.textContent = '';
      gl = glCanvas.getContext(useGL2.checked ? 'webgl2' : 'webgl');
      if (!gl) {
        shaderErr.textContent = useGL2.checked ? 'WebGL2 not supported; disable the toggle.' : 'WebGL not supported.';
        return;
      }
      const vsSrc = useGL2.checked ? DEFAULT_VS_300ES : DEFAULT_VS_100ES;
      program = createProgram(gl, vsSrc, fragSrc.value);
      if (!program) return;
      const pos = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW);
      aPos = gl.getAttribLocation(program, 'a_position');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
      uTime = gl.getUniformLocation(program, 'u_time');
      uRes = gl.getUniformLocation(program, 'u_resolution');
      uColor = gl.getUniformLocation(program, 'u_color');
      start = performance.now();
      drawGL();
    }

    function createProgram(gl, vsSrc, fsSrc) {
      const vs = compile(gl, gl.VERTEX_SHADER, vsSrc);
      if (!vs) return null;
      const fs = compile(gl, gl.FRAGMENT_SHADER, fsSrc);
      if (!fs) { gl.deleteShader(vs); return null; }
      const p = gl.createProgram();
      gl.attachShader(p, vs);
      gl.attachShader(p, fs);
      gl.bindAttribLocation(p, 0, 'a_position');
      gl.linkProgram(p);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        shaderErr.textContent = gl.getProgramInfoLog(p) || 'Link error';
        gl.deleteProgram(p);
        return null;
      }
      return p;
    }

    function compile(gl, type, src) {
      const sh = gl.createShader(type);
      gl.shaderSource(sh, src);
      gl.compileShader(sh);
      if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
        shaderErr.textContent = gl.getShaderInfoLog(sh) || 'Compile error';
        gl.deleteShader(sh);
        return null;
      }
      return sh;
    }

    function resizeGL() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const cssW = glCanvas.clientWidth || 500, cssH = glCanvas.clientHeight || 340;
      const w = Math.floor(cssW * dpr), h = Math.floor(cssH * dpr);
      if (glCanvas.width !== w || glCanvas.height !== h) {
        glCanvas.width = w;
        glCanvas.height = h;
      }
      gl.viewport(0, 0, glCanvas.width, glCanvas.height);
    }

    function linToSrgbTriplet([r, g, b]) { return [linearToSrgb(r), linearToSrgb(g), linearToSrgb(b)]; }

    function drawGL() {
      if (!gl || !program) return;
      resizeGL();
      gl.useProgram(program);
      const t = (performance.now() - start) / 1000;
      const [r, g, b] = linToSrgbTriplet(currentLin());
      gl.uniform1f(uTime, animate.checked ? t : 0);
      gl.uniform2f(uRes, glCanvas.width, glCanvas.height);
      gl.uniform4f(uColor, r, g, b, 1);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      if (animate.checked) raf = requestAnimationFrame(drawGL);
    }

    function rebuildGL() {
      cancelAnimationFrame(raf);
      if (gl && program) {
        try { gl.deleteBuffer(buf); } catch { /* noop */ }
        try { gl.deleteProgram(program); } catch { /* noop */ }
      }
      initGL();
    }

    useGL2.onchange = rebuildGL;
    animate.onchange = () => { if (animate.checked) drawGL(); };
    resetShader.onclick = () => { fragSrc.value = useGL2.checked ? DEFAULT_FS_300ES : DEFAULT_FS_100ES; rebuildGL(); };
    fragSrc.addEventListener('input', rebuildGL);
    window.addEventListener('resize', () => drawGL());

    function sceneKey(n) { return 'scene:' + n; }
    function save(key, value) { try { localStorage.setItem('colorApp:' + key, JSON.stringify(value)); } catch { /* noop */ } }
    function load(key, fallback) { try { const raw = localStorage.getItem('colorApp:' + key); return raw ? JSON.parse(raw) : fallback; } catch { return fallback; } }
    function loadScene(n) { return load(sceneKey(n), { blocks: [], h: 312, s: 0.6, v: 0.24, bgHex: '#111111', autoContrast: false, bloom: false, dot: false }); }

    (function selfTests() {
      try {
        console.assert(linRgbToHex(hsvToLinearRgb(0, 0, 0)) === '#000000', 'Black fail');
        console.assert(linRgbToHex(hsvToLinearRgb(0, 0, 1)) === '#FFFFFF', 'White fail');
        const red = linRgbToHex(hsvToLinearRgb(0, 1, 1));
        console.assert(red.startsWith('#FF') && red.endsWith('00'), 'Red fail: ' + red);
      } catch (e) { console.warn('Self-tests skipped', e); }
    })();

    function renderAll() {
      drawVBg();
      renderVKnob();
      renderWheelMarker();
      renderReadouts();
      renderPreview();
      renderBlocks();
      maybeFinishSwatch();
      drawGL();
    }

    renderHolderBar();
    renderAll();
    rebuildGL();

  </script>
</body>
</html>
