<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PNG to Voxel GLB Test</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body class="bg-slate-900 text-white">
    <div class="p-4">
        <h1 class="text-2xl font-bold mb-4">üßä PNG to Voxel GLB Converter</h1>
        
        <div class="mb-4">
            <button id="uploadBtn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 rounded">
                Upload PNG Image
            </button>
            <button id="exportBtn" class="px-4 py-2 bg-green-500 hover:bg-green-600 rounded ml-2" disabled>
                Export GLB
            </button>
        </div>
        
        <div id="status" class="mb-4 p-3 bg-slate-800 rounded"></div>
        
        <div class="grid grid-cols-2 gap-4">
            <div>
                <h3 class="font-bold mb-2">Original Image</h3>
                <canvas id="originalCanvas" class="border border-slate-700"></canvas>
            </div>
            <div>
                <h3 class="font-bold mb-2">Processed Mask</h3>
                <canvas id="maskCanvas" class="border border-slate-700"></canvas>
            </div>
        </div>
        
        <div class="mt-4">
            <h3 class="font-bold mb-2">3D Preview</h3>
            <div id="preview3d" class="w-full h-96 bg-slate-800 rounded"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

        const status = document.getElementById('status');
        const originalCanvas = document.getElementById('originalCanvas');
        const maskCanvas = document.getElementById('maskCanvas');
        const uploadBtn = document.getElementById('uploadBtn');
        const exportBtn = document.getElementById('exportBtn');
        const preview3d = document.getElementById('preview3d');

        let currentMesh = null;
        let scene, camera, renderer;

        function log(msg) {
            console.log(msg);
            status.innerHTML = msg;
        }

        // Setup 3D scene
        function setup3DPreview() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e293b);

            camera = new THREE.PerspectiveCamera(45, preview3d.clientWidth / preview3d.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 3);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(preview3d.clientWidth, preview3d.clientHeight);
            preview3d.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(2, 4, 3);
            scene.add(directionalLight);

            const gridHelper = new THREE.GridHelper(4, 20, 0x475569, 0x334155);
            scene.add(gridHelper);

            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (currentMesh) {
                currentMesh.rotation.y += 0.005;
            }
            renderer.render(scene, camera);
        }

        // Image processing
        function imageToCanvas(img) {
            const canvas = document.createElement('canvas');
            canvas.width = Math.min(img.width, 128);
            canvas.height = Math.min(img.height, 128);
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            return canvas;
        }

        function canvasToGrayscale(canvas) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                const a = data[i + 3];
                const gray = a > 0 ? (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]) : 0;
                data[i] = data[i + 1] = data[i + 2] = gray;
                data[i + 3] = 255;
            }
            ctx.putImageData(imgData, 0, 0);
        }

        function otsuThreshold(canvas) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            const hist = new Array(256).fill(0);

            for (let i = 0; i < data.length; i += 4) {
                hist[data[i]]++;
            }

            const total = canvas.width * canvas.height;
            let sum = 0;
            for (let i = 0; i < 256; i++) sum += i * hist[i];

            let sumB = 0, wB = 0, wF = 0, maxVar = 0, threshold = 0;
            for (let t = 0; t < 256; t++) {
                wB += hist[t];
                if (wB === 0) continue;
                wF = total - wB;
                if (wF === 0) break;

                sumB += t * hist[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const varBetween = wB * wF * (mB - mF) * (mB - mF);

                if (varBetween > maxVar) {
                    maxVar = varBetween;
                    threshold = t;
                }
            }

            return threshold;
        }

        function applyThreshold(canvas, threshold) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;

            for (let i = 0; i < data.length; i += 4) {
                const v = data[i];
                const bin = v >= threshold ? 255 : 0;
                data[i] = data[i + 1] = data[i + 2] = bin;
                data[i + 3] = 255;
            }

            ctx.putImageData(imgData, 0, 0);
        }

        function readMask(canvas) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            const mask = new Uint8Array(canvas.width * canvas.height);
            for (let i = 0, p = 0; i < mask.length; i++, p += 4) {
                mask[i] = data[p];
            }
            return mask;
        }

        // Voxel geometry creation
        function createVoxelGeometry(mask, w, h) {
            log(`üßä Creating voxel geometry from ${w}x${h} mask...`);
            
            const VOXEL_SIZE = 0.1;
            const depth = Math.floor(w * 0.3); // Depth for extrusion
            const voxels = [];

            // Calculate distance field for depth variation
            const distField = new Float32Array(w * h);
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y * w + x;
                    if (mask[idx] > 0) {
                        let minDist = Math.max(w, h);
                        const searchR = 15;
                        for (let dy = -searchR; dy <= searchR; dy++) {
                            const sy = y + dy;
                            if (sy < 0 || sy >= h) continue;
                            for (let dx = -searchR; dx <= searchR; dx++) {
                                const sx = x + dx;
                                if (sx < 0 || sx >= w) continue;
                                if (mask[sy * w + sx] === 0) {
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    minDist = Math.min(minDist, dist);
                                }
                            }
                        }
                        distField[idx] = minDist;
                    }
                }
            }

            // Create voxels with varying depth
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y * w + x;
                    if (mask[idx] > 0) {
                        const distFromEdge = distField[idx];
                        const normalizedDist = Math.min(1, distFromEdge / 10);
                        const voxelDepth = Math.floor(depth * normalizedDist * 0.8);
                        
                        for (let z = 0; z < voxelDepth; z++) {
                            voxels.push({ x, y, z });
                        }
                    }
                }
            }

            log(`Generated ${voxels.length} voxels`);

            if (voxels.length === 0) {
                return new THREE.BoxGeometry(0.5, 1.7, 0.3);
            }

            // Merge voxel cubes
            const boxGeo = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);
            const positions = [];
            const normals = [];
            const indices = [];
            let vertexOffset = 0;

            const sx = (w * VOXEL_SIZE) * 0.5;
            const sy = (h * VOXEL_SIZE) * 0.5;
            const sz = (depth * VOXEL_SIZE) * 0.5;

            const matrix = new THREE.Matrix4();
            const tempGeo = boxGeo.clone();

            voxels.forEach((cell) => {
                const px = cell.x * VOXEL_SIZE - sx + VOXEL_SIZE * 0.5;
                const py = -(cell.y * VOXEL_SIZE) + sy - VOXEL_SIZE * 0.5;
                const pz = cell.z * VOXEL_SIZE - sz + VOXEL_SIZE * 0.5;

                matrix.makeTranslation(px, py, pz);
                tempGeo.applyMatrix4(matrix);

                const pos = tempGeo.attributes.position.array;
                for (let i = 0; i < pos.length; i++) {
                    positions.push(pos[i]);
                }

                const norm = tempGeo.attributes.normal.array;
                for (let i = 0; i < norm.length; i++) {
                    normals.push(norm[i]);
                }

                const idx = tempGeo.index.array;
                for (let i = 0; i < idx.length; i++) {
                    indices.push(idx[i] + vertexOffset);
                }

                vertexOffset += pos.length / 3;

                matrix.makeTranslation(-px, -py, -pz);
                tempGeo.applyMatrix4(matrix);
            });

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setIndex(indices);

            // Scale to target height
            const bbox = new THREE.Box3().setFromBufferAttribute(geometry.attributes.position);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim > 0) {
                const targetScale = 1.7 / maxDim;
                geometry.scale(targetScale, targetScale, targetScale);
            }

            geometry.computeVertexNormals();
            log(`‚úì Voxel mesh: ${voxels.length} cubes, ${vertexOffset} vertices`);
            
            return geometry;
        }

        // Upload handler
        uploadBtn.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/png,image/jpeg,image/jpg';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                log(`Loading ${file.name}...`);

                const img = new Image();
                img.onload = () => {
                    // Show original
                    const origCtx = originalCanvas.getContext('2d');
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    origCtx.drawImage(img, 0, 0);

                    // Process to mask
                    const canvas = imageToCanvas(img);
                    canvasToGrayscale(canvas);
                    const threshold = otsuThreshold(canvas);
                    log(`Auto threshold: ${threshold}`);
                    applyThreshold(canvas, threshold);

                    // Show mask
                    maskCanvas.width = canvas.width;
                    maskCanvas.height = canvas.height;
                    const maskCtx = maskCanvas.getContext('2d');
                    maskCtx.drawImage(canvas, 0, 0);

                    // Create 3D mesh
                    const mask = readMask(canvas);
                    const geometry = createVoxelGeometry(mask, canvas.width, canvas.height);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x4ecdc4,
                        roughness: 0.7,
                        metalness: 0.3
                    });

                    if (currentMesh) {
                        scene.remove(currentMesh);
                    }

                    currentMesh = new THREE.Mesh(geometry, material);
                    scene.add(currentMesh);

                    exportBtn.disabled = false;
                    log(`‚úÖ Ready! Preview loaded. Click Export GLB to save.`);
                };

                img.src = URL.createObjectURL(file);
            };
            input.click();
        });

        // Export handler
        exportBtn.addEventListener('click', () => {
            if (!currentMesh) return;

            log('Exporting to GLB...');
            const exporter = new GLTFExporter();
            exporter.parse(
                currentMesh,
                (result) => {
                    const blob = new Blob([result], { type: 'model/gltf-binary' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'voxel_model.glb';
                    a.click();
                    URL.revokeObjectURL(url);
                    log(`‚úÖ Exported voxel_model.glb (${(blob.size / 1024).toFixed(1)} KB)`);
                },
                (error) => {
                    log(`‚ùå Export error: ${error.message}`);
                },
                { binary: true }
            );
        });

        setup3DPreview();
        log('Ready! Upload a PNG image to begin.');
    </script>
</body>
</html>
