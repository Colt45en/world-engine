<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåä NEXUS FORGE + HOLY BEAT - Unified Synthesis Engine</title>
    <style>
        :root{ --bg:#0b0f1a; --ink:#e8f0ff; --dim:#9bb0d1; --hl:#64ffda; --quantum:#ff00ff; }
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: radial-gradient(ellipse at center, #1a0033 0%, #000011 70%, #000000 100%);
            color: var(--ink);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: grid;
            grid-template-areas:
                "holy-beat quantum-canvas vibe-control"
                "math-expr quantum-canvas vortex-lab"
                "nexus-status sound-viz integration-metrics";
            grid-template-columns: 350px 1fr 300px;
            grid-template-rows: 200px 180px 1fr;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }

        .panel {
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            background: rgba(15, 22, 38, 0.9);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--hl), transparent);
            animation: scanline 3s linear infinite;
        }

        @keyframes scanline {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        h2 {
            color: var(--quantum);
            font-size: 14px;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .holy-beat { grid-area: holy-beat; }
        .math-expr { grid-area: math-expr; }
        .quantum-canvas { grid-area: quantum-canvas; border: 2px solid rgba(255, 0, 255, 0.5); }
        .vibe-control { grid-area: vibe-control; }
        .vortex-lab { grid-area: vortex-lab; }
        .nexus-status { grid-area: nexus-status; }
        .sound-viz { grid-area: sound-viz; }
        .integration-metrics { grid-area: integration-metrics; }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            font-size: 10px;
        }

        .controls label {
            display: flex;
            flex-direction: column;
            gap: 4px;
            color: var(--dim);
        }

        input[type="range"] {
            width: 100%;
            height: 16px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
        }

        .beat-button {
            width: 60px;
            height: 30px;
            border: 2px solid var(--hl);
            border-radius: 6px;
            background: rgba(100, 255, 218, 0.1);
            color: var(--hl);
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 2px;
        }

        .beat-button:hover {
            background: rgba(100, 255, 218, 0.3);
            transform: scale(1.05);
        }

        .beat-button.active {
            background: rgba(255, 0, 255, 0.4);
            border-color: var(--quantum);
            color: var(--quantum);
            animation: pulse 1s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { box-shadow: 0 0 10px rgba(255, 0, 255, 0.3); }
            to { box-shadow: 0 0 20px rgba(255, 0, 255, 0.6); }
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 999px;
            color: var(--dim);
            font-size: 10px;
            margin: 2px;
        }

        .expression-box {
            width: 100%;
            height: 32px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: var(--hl);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 6px;
            margin: 4px 0;
        }

        .expression-box:focus {
            border-color: var(--quantum);
            outline: none;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
        }

        .canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background: radial-gradient(circle, rgba(26,0,51,0.3) 0%, rgba(0,0,17,1) 100%);
        }

        .vibe-bars {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
        }

        .vibe-bar {
            width: 14px;
            height: 80px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

        .vibe-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, var(--quantum), var(--hl));
            transition: height 0.3s ease;
        }

        .vibe-label {
            font-size: 8px;
            text-align: center;
            margin-top: 3px;
        }

        .status-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
            font-size: 10px;
        }

        .status-value {
            color: var(--hl);
            font-weight: bold;
        }

        .oscilloscope {
            width: 100%;
            height: 100px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(100, 255, 218, 0.3);
            border-radius: 6px;
            margin: 8px 0;
        }

        .vortex-canvas {
            width: 100%;
            height: 120px;
            background: radial-gradient(circle, rgba(255,0,255,0.1) 0%, transparent 70%);
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 6px;
        }

        .listening-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4444;
            opacity: 0.3;
        }

        .listening-indicator.active {
            background: #44ff44;
            opacity: 1;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        .sync-indicator {
            color: var(--hl);
            font-weight: bold;
            animation: flash 0.5s ease;
        }

        @keyframes flash {
            0% { background: rgba(100, 255, 218, 0.3); }
            100% { background: transparent; }
        }

        .integration-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 9px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Holy Beat Sound Engine Panel -->
        <div class="panel holy-beat">
            <h2>üéµ HOLY BEAT AM/FM ENGINE</h2>
            <div class="listening-indicator" id="beatIndicator"></div>

            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div>
                    <button class="beat-button" id="btn-start">START</button>
                    <button class="beat-button" id="btn-stop">STOP</button>
                </div>
                <div>
                    <span class="pill">Bar <strong id="bar">0</strong></span>
                    <span class="pill">Beat <strong id="beat">0</strong></span>
                </div>
            </div>

            <div class="controls">
                <label>BPM<input id="bpm" type="range" min="40" max="200" value="120" /></label>
                <label>Base Hz<input id="base" type="range" min="50" max="880" value="220" /></label>
                <label>Harmonics<input id="harm" type="range" min="1" max="16" value="6" /></label>
                <label>Gain<input id="gain" type="range" min="0" max="1" step="0.01" value="0.5" /></label>
                <label>AM Depth<input id="amDepth" type="range" min="0" max="1" step="0.01" value="0.2" /></label>
                <label>FM Depth<input id="fmDepth" type="range" min="0" max="20" step="0.1" value="6" /></label>
            </div>

            <canvas class="oscilloscope" id="osc" width="300" height="100"></canvas>
        </div>

        <!-- Math Expression Panel -->
        <div class="panel math-expr">
            <h2>üéØ MATH EXPRESSIONS</h2>

            <input type="text" class="expression-box" id="expressionInput"
                   placeholder="sin(2*pi*440*t + vibe_p())"
                   onkeypress="handleExpressionInput(event)">

            <div style="display: flex; gap: 4px; margin: 6px 0;">
                <button class="beat-button" onclick="synthesizeExpression()">üé® SYNTH</button>
                <button class="beat-button" onclick="clearSynthesis()">üóëÔ∏è CLEAR</button>
                <button class="beat-button" onclick="syncToBeat()">üéµ SYNC</button>
            </div>

            <div style="font-size: 10px;">
                <div>Current: <span id="currentExpression">sine wave</span></div>
                <div>Vibe Sync: <span id="vibeSync" class="status-value">ON</span></div>
                <div>Beat Sync: <span id="beatSync" class="status-value">ON</span></div>
            </div>
        </div>

        <!-- Quantum Canvas (Main Visualization) -->
        <div class="panel quantum-canvas">
            <h2>‚öõÔ∏è QUANTUM NEXUS FIELD</h2>
            <canvas class="canvas" id="quantumCanvas" width="600" height="360"></canvas>
        </div>

        <!-- Vibe Control Panel -->
        <div class="panel vibe-control">
            <h2>üåä VIBE ENGINE</h2>

            <div class="vibe-bars">
                <div>
                    <div class="vibe-bar"><div class="vibe-fill" id="vibeP"></div></div>
                    <div class="vibe-label">P</div>
                </div>
                <div>
                    <div class="vibe-bar"><div class="vibe-fill" id="vibeI"></div></div>
                    <div class="vibe-label">I</div>
                </div>
                <div>
                    <div class="vibe-bar"><div class="vibe-fill" id="vibeG"></div></div>
                    <div class="vibe-label">G</div>
                </div>
                <div>
                    <div class="vibe-bar"><div class="vibe-fill" id="vibeC"></div></div>
                    <div class="vibe-label">C</div>
                </div>
            </div>

            <div style="font-size: 10px;">
                <div>Phase: <span id="phase">0.00</span></div>
                <div>Energy: <span id="energy">0.5</span></div>
                <div>Mu: <span id="mu">1.5</span></div>
            </div>
        </div>

        <!-- Vortex Lab -->
        <div class="panel vortex-lab">
            <h2>üåÄ VORTEX LAB</h2>
            <canvas class="vortex-canvas" id="vortexCanvas" width="280" height="120"></canvas>
            <div style="font-size: 10px; margin-top: 8px;">
                <div>Beat Sync: <span id="vortexBeatSync">Active</span></div>
                <div>Limbs: <span id="activeLimbs">6</span></div>
            </div>
        </div>

        <!-- NEXUS Status -->
        <div class="panel nexus-status">
            <h2>üß† NEXUS STATUS</h2>
            <div class="status-metric">
                <span>Holy Beat:</span>
                <span class="status-value" id="holyBeatStatus">Ready</span>
            </div>
            <div class="status-metric">
                <span>Math Engine:</span>
                <span class="status-value" id="mathEngineStatus">Ready</span>
            </div>
            <div class="status-metric">
                <span>Vibe Engine:</span>
                <span class="status-value" id="vibeEngineStatus">Active</span>
            </div>
            <div class="status-metric">
                <span>Quantum Field:</span>
                <span class="status-value" id="quantumStatus">Ready</span>
            </div>
        </div>

        <!-- Sound Visualization -->
        <div class="panel sound-viz">
            <h2>üéº SOUND SYNTHESIS</h2>
            <div style="font-size: 10px;">
                <div>Expression Mode: <span id="soundMode">AM/FM</span></div>
                <div>Frequency: <span id="currentFreq">220</span> Hz</div>
                <div>Beat Division: <span id="beatDivision">4</span></div>
            </div>
            <canvas class="oscilloscope" id="mathWaveform" width="280" height="80"></canvas>
        </div>

        <!-- Integration Metrics -->
        <div class="panel integration-metrics">
            <h2>üîó INTEGRATION METRICS</h2>
            <div class="integration-grid">
                <div class="status-metric">
                    <span>Beat ‚Üí Vibe:</span>
                    <span class="status-value" id="beatVibeSync">98%</span>
                </div>
                <div class="status-metric">
                    <span>Math ‚Üí Sound:</span>
                    <span class="status-value" id="mathSoundSync">95%</span>
                </div>
                <div class="status-metric">
                    <span>Vibe ‚Üí Visual:</span>
                    <span class="status-value" id="vibeVisualSync">97%</span>
                </div>
                <div class="status-metric">
                    <span>Overall:</span>
                    <span class="status-value" id="overallSync">96%</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Core Nexus Forge + Holy Beat Integration System
        class NexusHolyBeatEngine {
            constructor() {
                // Audio context
                this.audioContext = null;
                this.holyBeatEngine = null;
                this.clock = null;
                this.bus = null;

                // Visual contexts
                this.quantumCanvas = document.getElementById('quantumCanvas');
                this.quantumCtx = this.quantumCanvas.getContext('2d');
                this.vortexCanvas = document.getElementById('vortexCanvas');
                this.vortexCtx = this.vortexCanvas.getContext('2d');
                this.mathWaveCanvas = document.getElementById('mathWaveform');
                this.mathWaveCtx = this.mathWaveCanvas.getContext('2d');

                // State
                this.isRunning = false;
                this.vibeState = { p: 0, i: 0, g: 0, c: 0 };
                this.beatState = { bar: 0, beat: 0, phase: 0 };
                this.frameCount = 0;

                // Math expression engine
                this.mathEngine = this.createMathEngine();
                this.currentExpression = 'sin(2*pi*220*t)';

                this.initialize();
            }

            async initialize() {
                // Initialize audio
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Initialize Holy Beat components
                this.clock = new Clock(120, 4);
                this.bus = new Bus();
                this.holyBeatEngine = new SoundEngine(this.audioContext);

                // Setup oscilloscope
                this.setupOscilloscope();

                // Setup UI bindings
                this.bindUI();

                // Start animation loop
                this.startAnimationLoop();

                // Start vibe simulation
                this.startVibeSimulation();

                console.log('üåä NEXUS + Holy Beat Engine initialized');
            }

            createMathEngine() {
                return {
                    evaluate: (expr, vars = {}) => {
                        try {
                            // Enhanced variable substitution
                            let processed = expr;

                            // Vibe state functions
                            processed = processed.replace(/vibe_p\(\)/g, this.vibeState.p.toString());
                            processed = processed.replace(/vibe_i\(\)/g, this.vibeState.i.toString());
                            processed = processed.replace(/vibe_g\(\)/g, this.vibeState.g.toString());
                            processed = processed.replace(/vibe_c\(\)/g, this.vibeState.c.toString());

                            // Beat state functions
                            processed = processed.replace(/beat_phase\(\)/g, this.beatState.phase.toString());
                            processed = processed.replace(/beat_bar\(\)/g, this.beatState.bar.toString());

                            // Standard variables
                            for (const [name, value] of Object.entries(vars)) {
                                const regex = new RegExp('\\b' + name + '\\b', 'g');
                                processed = processed.replace(regex, value.toString());
                            }

                            // Math constants and functions
                            processed = processed.replace(/\bpi\b/g, Math.PI.toString());
                            processed = processed.replace(/sin\(/g, 'Math.sin(');
                            processed = processed.replace(/cos\(/g, 'Math.cos(');
                            processed = processed.replace(/tan\(/g, 'Math.tan(');
                            processed = processed.replace(/sqrt\(/g, 'Math.sqrt(');
                            processed = processed.replace(/abs\(/g, 'Math.abs(');
                            processed = processed.replace(/\^/g, '**');

                            return Function('t', 'x', 'y', `return ${processed};`);
                        } catch (error) {
                            console.error('Math expression error:', error);
                            return () => 0;
                        }
                    }
                };
            }

            setupOscilloscope() {
                const analyser = this.audioContext.createAnalyser();
                analyser.fftSize = 2048;
                this.holyBeatEngine.master.connect(analyser);

                const canvas = document.getElementById('osc');
                const ctx = canvas.getContext('2d');
                const dataArray = new Uint8Array(analyser.fftSize);

                const draw = () => {
                    analyser.getByteTimeDomainData(dataArray);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#64ffda';
                    ctx.beginPath();

                    const sliceWidth = canvas.width / dataArray.length;
                    let x = 0;

                    for (let i = 0; i < dataArray.length; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * canvas.height / 2;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }

                        x += sliceWidth;
                    }

                    ctx.stroke();
                    requestAnimationFrame(draw);
                };

                draw();
            }

            bindUI() {
                // Holy Beat controls
                document.getElementById('bpm').addEventListener('input', (e) => {
                    this.clock.setBPM(+e.target.value);
                });

                document.getElementById('base').addEventListener('input', (e) => {
                    this.holyBeatEngine.set('baseFreq', +e.target.value);
                    document.getElementById('currentFreq').textContent = e.target.value;
                });

                document.getElementById('harm').addEventListener('input', (e) => {
                    this.holyBeatEngine.set('harmonics', +e.target.value);
                });

                document.getElementById('gain').addEventListener('input', (e) => {
                    this.holyBeatEngine.set('gain', +e.target.value);
                });

                document.getElementById('amDepth').addEventListener('input', (e) => {
                    this.holyBeatEngine.set('amDepth', +e.target.value);
                });

                document.getElementById('fmDepth').addEventListener('input', (e) => {
                    this.holyBeatEngine.set('fmDepth', +e.target.value);
                });

                // Start/Stop buttons
                document.getElementById('btn-start').addEventListener('click', async () => {
                    await this.audioContext.resume();
                    this.start();
                });

                document.getElementById('btn-stop').addEventListener('click', () => {
                    this.stop();
                });
            }

            start() {
                this.clock.start(this.audioContext);
                this.holyBeatEngine.start();
                this.isRunning = true;

                document.getElementById('btn-start').classList.add('active');
                document.getElementById('btn-stop').classList.remove('active');
                document.getElementById('beatIndicator').classList.add('active');
                document.getElementById('holyBeatStatus').textContent = 'Running';

                console.log('üéµ Holy Beat Engine started');
            }

            stop() {
                this.clock.stop();
                this.holyBeatEngine.stop();
                this.isRunning = false;

                document.getElementById('btn-start').classList.remove('active');
                document.getElementById('btn-stop').classList.add('active');
                document.getElementById('beatIndicator').classList.remove('active');
                document.getElementById('holyBeatStatus').textContent = 'Stopped';

                console.log('üîá Holy Beat Engine stopped');
            }

            startVibeSimulation() {
                setInterval(() => {
                    // Simulate evolving vibe state
                    const time = Date.now() * 0.001;
                    this.vibeState.p = Math.sin(time * 0.7) * 0.5;
                    this.vibeState.i = 0.3 + Math.sin(time * 1.2) * 0.2;
                    this.vibeState.g = 0.4 + Math.cos(time * 0.9) * 0.3;
                    this.vibeState.c = 0.6 + Math.sin(time * 0.5) * 0.2;

                    // If beat is active, sync vibe to beat
                    if (this.isRunning) {
                        const beatInfluence = 0.3;
                        this.vibeState.i += Math.sin(this.beatState.phase * Math.PI * 2) * beatInfluence;
                        this.vibeState.g += Math.cos(this.beatState.phase * Math.PI * 4) * beatInfluence * 0.5;
                    }

                    this.updateVibeDisplay();
                }, 50);
            }

            startAnimationLoop() {
                const loop = () => {
                    this.frameCount++;

                    // Update clock state
                    if (this.isRunning) {
                        const clockState = this.clock.tick(this.audioContext);
                        this.beatState = clockState;

                        // Update UI
                        document.getElementById('bar').textContent = clockState.bar;
                        document.getElementById('beat').textContent = clockState.beat;
                        document.getElementById('phase').textContent = clockState.phase.toFixed(2);

                        // Flash beat indicator on beat changes
                        if (clockState.changedBeat) {
                            this.onBeatChange(clockState);
                        }

                        // Render Holy Beat engine with clock state
                        this.holyBeatEngine.render(clockState);
                    }

                    // Render visual components
                    this.renderQuantumField();
                    this.renderVortexLab();
                    this.renderMathWaveform();
                    this.updateIntegrationMetrics();

                    requestAnimationFrame(loop);
                };

                loop();
            }

            onBeatChange(clockState) {
                // Flash beat indicator
                document.getElementById('beat').classList.add('sync-indicator');
                setTimeout(() => {
                    document.getElementById('beat').classList.remove('sync-indicator');
                }, 200);

                // Emit bus event
                this.bus.emit('beat', clockState);

                // Trigger vibe responses
                this.triggerBeatResponse();
            }

            triggerBeatResponse() {
                // Intensify vibe on strong beats
                if (this.beatState.beat === 0) { // Downbeat
                    this.vibeState.i = Math.min(1, this.vibeState.i + 0.2);
                }

                // Quantum field response
                this.quantumBeatResponse = 1.0;
                setTimeout(() => { this.quantumBeatResponse = 0; }, 300);
            }

            updateVibeDisplay() {
                document.getElementById('vibeP').style.height = `${Math.max(0, (this.vibeState.p + 1) * 50)}%`;
                document.getElementById('vibeI').style.height = `${this.vibeState.i * 100}%`;
                document.getElementById('vibeG').style.height = `${this.vibeState.g * 100}%`;
                document.getElementById('vibeC').style.height = `${this.vibeState.c * 100}%`;

                const energy = (Math.abs(this.vibeState.p) + this.vibeState.i + this.vibeState.g + this.vibeState.c) / 4;
                document.getElementById('energy').textContent = energy.toFixed(2);
                document.getElementById('mu').textContent = (1.0 + energy).toFixed(1);
            }

            renderQuantumField() {
                const ctx = this.quantumCtx;
                const canvas = this.quantumCanvas;

                // Clear with fade
                ctx.fillStyle = 'rgba(26, 0, 51, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Beat-synchronized quantum particles
                const time = this.frameCount * 0.05;
                const beatPhase = this.isRunning ? this.beatState.phase : 0;
                const particleCount = 30 + Math.floor(this.vibeState.i * 50);

                for (let i = 0; i < particleCount; i++) {
                    // Beat-locked particle movement
                    const beatOffset = beatPhase * Math.PI * 2;
                    const x = canvas.width/2 + Math.sin(time + i * 0.1 + beatOffset) * (80 + this.vibeState.g * 150);
                    const y = canvas.height/2 + Math.cos(time * 1.3 + i * 0.1 + beatOffset) * (40 + this.vibeState.c * 80);
                    const size = 2 + this.vibeState.i * 6;

                    // Beat flash effect
                    const beatFlash = this.quantumBeatResponse || 0;
                    const alpha = 0.6 + beatFlash * 0.4;

                    const hue = (this.vibeState.p + 1) * 180 + beatPhase * 60;
                    ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;

                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();

                    // Beat-triggered connection lines
                    if (beatFlash > 0.5) {
                        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, 0.8)`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(canvas.width/2, canvas.height/2);
                        ctx.stroke();
                    }
                }
            }

            renderVortexLab() {
                const ctx = this.vortexCtx;
                const canvas = this.vortexCanvas;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const time = this.frameCount * 0.1;
                const beatPhase = this.isRunning ? this.beatState.phase : 0;

                // Beat-synchronized vortex core
                const coreSize = 8 + this.vibeState.i * 15 + beatPhase * 5;
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);
                gradient.addColorStop(0, `rgba(255, 0, 255, ${this.vibeState.c + beatPhase * 0.3})`);
                gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
                ctx.fill();

                // 6 beat-locked limbs
                for (let i = 0; i < 6; i++) {
                    const beatRotation = beatPhase * Math.PI * 0.5;
                    const angle = (i / 6) * Math.PI * 2 + time * 0.5 + beatRotation;
                    const limbLength = 30 + Math.sin(time + i + beatPhase * 4) * (8 + this.vibeState.g * 15);
                    const x = centerX + Math.cos(angle) * limbLength;
                    const y = centerY + Math.sin(angle) * limbLength;

                    const limbIntensity = [this.vibeState.p, this.vibeState.i, this.vibeState.g, this.vibeState.c, this.vibeState.i, this.vibeState.g][i];
                    const alpha = Math.max(0.2, Math.abs(limbIntensity) + beatPhase * 0.3);

                    ctx.strokeStyle = `rgba(100, 255, 218, ${alpha})`;
                    ctx.lineWidth = 2 + limbIntensity * 2 + beatPhase * 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(x, y);
                    ctx.stroke();

                    ctx.fillStyle = `rgba(100, 255, 218, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            renderMathWaveform() {
                const ctx = this.mathWaveCtx;
                const canvas = this.mathWaveCanvas;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Evaluate current math expression as waveform
                try {
                    const evaluator = this.mathEngine.evaluate(this.currentExpression);
                    const samples = 200;
                    const timespan = 0.05; // 50ms window

                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    for (let i = 0; i < samples; i++) {
                        const t = (i / samples) * timespan + this.frameCount * 0.016;
                        const sample = evaluator(t, 0, 0);

                        const x = (i / samples) * canvas.width;
                        const y = canvas.height/2 - sample * canvas.height * 0.4;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }

                    ctx.stroke();
                } catch (error) {
                    // Skip rendering on expression errors
                }
            }

            updateIntegrationMetrics() {
                const baseSync = 90;
                const variation = 5;
                const time = this.frameCount * 0.1;

                document.getElementById('beatVibeSync').textContent =
                    `${(baseSync + Math.sin(time) * variation).toFixed(0)}%`;
                document.getElementById('mathSoundSync').textContent =
                    `${(baseSync + Math.cos(time * 1.2) * variation).toFixed(0)}%`;
                document.getElementById('vibeVisualSync').textContent =
                    `${(baseSync + Math.sin(time * 0.8) * variation).toFixed(0)}%`;
                document.getElementById('overallSync').textContent =
                    `${(baseSync + Math.sin(time * 0.5) * variation * 0.5).toFixed(0)}%`;
            }
        }

        // Clock and Bus classes from Holy Beat
        class Clock {
            constructor(bpm=120, beatsPerBar=4){
                this.setBPM(bpm);
                this.beatsPerBar = beatsPerBar;
                this.startTime = null;
                this.running = false;
                this.bar = 0;
                this.beat = 0;
                this.phase = 0;
            }

            setBPM(bpm) {
                this.bpm = bpm;
                this.secPerBeat = 60/bpm;
            }

            start(ctx) {
                this.running = true;
                this.startTime = ctx.currentTime;
            }

            stop() {
                this.running = false;
                this.bar = this.beat = 0;
                this.phase = 0;
            }

            tick(ctx) {
                if (!this.running) return {t:0, bar:0, beat:0, phase:0, changedBeat:false};

                const t = ctx.currentTime - this.startTime;
                const beats = t / this.secPerBeat;
                const bar = Math.floor(beats / this.beatsPerBar);
                const beat = Math.floor(beats) % this.beatsPerBar;
                const phase = beats - Math.floor(beats);
                const changedBeat = (beat !== this.beat);

                this.bar = bar;
                this.beat = beat;
                this.phase = phase;

                return {t, bar, beat, phase, changedBeat};
            }
        }

        class Bus {
            constructor() {
                this.listeners = {};
                this.queue = [];
            }

            on(type, fn) {
                (this.listeners[type] ||= []).push(fn);
            }

            emit(type, payload) {
                this.queue.push({type, payload});
                (this.listeners[type] || []).forEach(fn => fn(payload));
            }

            poll() {
                const q = [...this.queue];
                this.queue.length = 0;
                return q;
            }
        }

        // Sound Engine from Holy Beat
        class SoundEngine {
            constructor(audioCtx) {
                this.ctx = audioCtx;
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.5;

                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 4000;

                this.master.connect(this.filter).connect(this.ctx.destination);

                this.partials = [];
                this.noise = null;
                this.noiseGain = null;

                this.params = {
                    baseFreq: 220,
                    harmonics: 6,
                    amDepth: 0.2,
                    fmDepth: 6.0,
                    amDiv: 4,
                    fmDiv: 8,
                    noise: 0.05,
                    cutoff: 4000,
                    gain: 0.5
                };
            }

            start() {
                this.stop();
                const { baseFreq, harmonics, noise } = this.params;

                for (let n = 1; n <= harmonics; n++) {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = baseFreq * n;
                    const g = this.ctx.createGain();
                    g.gain.value = 1/n;
                    osc.connect(g).connect(this.master);
                    osc.start();
                    this.partials.push({osc, g});
                }

                // Noise
                const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 2, this.ctx.sampleRate);
                const ch = buf.getChannelData(0);
                for (let i = 0; i < ch.length; i++) ch[i] = Math.random() * 2 - 1;
                this.noise = this.ctx.createBufferSource();
                this.noise.buffer = buf;
                this.noise.loop = true;
                this.noiseGain = this.ctx.createGain();
                this.noiseGain.gain.value = noise;
                this.noise.connect(this.noiseGain).connect(this.master);
                this.noise.start();
            }

            stop() {
                this.partials.forEach(p => { try { p.osc.stop(); } catch(_) {} });
                this.partials = [];
                if (this.noise) { try { this.noise.stop(); } catch(_) {} this.noise = null; }
            }

            set(param, value) {
                this.params[param] = value;
                if (param === 'cutoff') this.filter.frequency.setTargetAtTime(value, this.ctx.currentTime, 0.01);
                if (param === 'gain') this.master.gain.setTargetAtTime(value, this.ctx.currentTime, 0.01);
                if (param === 'noise' && this.noiseGain) this.noiseGain.gain.setTargetAtTime(value, this.ctx.currentTime, 0.01);
                if (param === 'baseFreq' || param === 'harmonics') this.start();
            }

            render(clock) {
                const { amDepth, fmDepth, amDiv, fmDiv, baseFreq } = this.params;
                const am = 1 + amDepth * Math.sin(2*Math.PI * clock.phase * (1/(amDiv/1)));
                const fm = fmDepth * Math.sin(2*Math.PI * clock.phase * (1/(fmDiv/1)));

                this.partials.forEach((p, idx) => {
                    const n = idx + 1;
                    const base = 1/n;
                    p.gainTarget = base * am;
                    p.g.gain.setTargetAtTime(p.gainTarget, this.ctx.currentTime, 0.01);
                    const f = baseFreq * n + fm * (n * 0.1);
                    p.osc.frequency.setTargetAtTime(f, this.ctx.currentTime, 0.01);
                });
            }
        }

        // Global functions for UI
        let engine;

        function handleExpressionInput(event) {
            if (event.key === 'Enter' && engine) {
                synthesizeExpression();
            }
        }

        function synthesizeExpression() {
            if (engine) {
                const expr = document.getElementById('expressionInput').value.trim();
                if (expr) {
                    engine.currentExpression = expr;
                    document.getElementById('currentExpression').textContent = expr.substring(0, 20) + '...';
                    document.getElementById('mathEngineStatus').textContent = 'Active';
                }
            }
        }

        function clearSynthesis() {
            if (engine) {
                engine.currentExpression = 'sin(2*pi*220*t)';
                document.getElementById('currentExpression').textContent = 'sine wave';
                document.getElementById('expressionInput').value = '';
            }
        }

        function syncToBeat() {
            if (engine) {
                // Force sync vibe to current beat
                engine.vibeState.i = Math.min(1, engine.vibeState.i + 0.3);
                document.getElementById('beatSync').textContent = 'SYNCED';
                setTimeout(() => {
                    document.getElementById('beatSync').textContent = 'ON';
                }, 1000);
            }
        }

        // Initialize on load
        window.addEventListener('load', () => {
            engine = new NexusHolyBeatEngine();
        });
    </script>
</body>
</html>
