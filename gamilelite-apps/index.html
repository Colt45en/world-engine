<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameLite - 3D Animation Platform</title>
    <link rel="icon" href="data:,">
    <style>
        :root {
            --bg: #0a0f17;
            --ink: #e9f0ff;
            --muted: #9fb0d1;
            --line: rgba(170,220,255,.25);
            --good: #22c55e;
            --bad: #ef4444;
            --mana: #3b82f6;
            --gold: #eab308;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Global Button Styles */
        button {
            appearance: none;
            border: 1px solid rgba(255,255,255,.2);
            background: rgba(0,0,0,.4);
            color: var(--ink);
            padding: 0.4rem 1rem;
            font-size: 0.875rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        button:hover {
            border-color: rgba(255,255,255,.35);
            background: rgba(255,255,255,.1);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        /* Global Input & Form Styles */
        input[type="text"],
        input[type="number"],
        input[type="email"],
        input[type="password"],
        input[type="search"],
        textarea,
        select {
            appearance: none;
            background: rgba(0,0,0,.4);
            border: 1px solid rgba(255,255,255,.2);
            color: var(--ink);
            padding: 0.4rem;
            border-radius: 3px;
            font-family: inherit;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="email"]:focus,
        input[type="password"]:focus,
        input[type="search"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--mana);
            background: rgba(0,0,0,.5);
        }

        input[type="range"] {
            appearance: none;
            height: 6px;
            background: rgba(255,255,255,.2);
            border-radius: 3px;
            outline: none;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--mana);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #60a5fa;
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--mana);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #60a5fa;
            transform: scale(1.2);
        }

        input[type="checkbox"] {
            appearance: none;
            width: 20px;
            height: 20px;
            background: rgba(0,0,0,.4);
            border: 1px solid rgba(255,255,255,.2);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        input[type="checkbox"]:checked {
            background: var(--mana);
            border-color: var(--mana);
        }

        input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            color: white;
            font-size: 14px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        input[type="color"] {
            appearance: none;
            width: 50px;
            height: 30px;
            border: 1px solid rgba(255,255,255,.2);
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 2px;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 3px;
        }

        input[type="file"] {
            cursor: pointer;
        }

        select {
            cursor: pointer;
            padding-right: 2rem;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23e9f0ff' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            background: radial-gradient(1200px 800px at 15% -10%, #10183b, var(--bg));
            color: var(--ink);
            font-family: system-ui, 'Segoe UI', Roboto, Inter, Arial, sans-serif;
        }

        /* Main Container */
        #app-container {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
        }

        /* Top Navigation Bar - ULTRA COMPACT */
        #nav-bar {
            background: rgba(0,0,0,.7);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--line);
            padding: 0.25rem 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            position: relative;
            z-index: 1000;
            transition: all 0.3s ease;
            min-height: 32px;
        }

        #nav-bar.collapsed {
            padding: 0.25rem 0.5rem;
        }

        .logo {
            font-size: 0.75rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            white-space: nowrap;
        }

        #menu-toggle-btn {
            appearance: none;
            border: 1px solid rgba(255,255,255,.3);
            background: rgba(0,0,0,.5);
            color: var(--ink);
            padding: 0.25rem 0.4rem;
            font-size: 0.9rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            line-height: 1;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        #menu-toggle-btn:hover {
            background: rgba(255,255,255,.1);
            transform: scale(1.05);
        }

        #nav-buttons {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
            align-items: center;
            flex: 1;
            overflow: hidden;
            transition: all 0.3s ease;
            max-height: 150px;
        }

        #nav-bar.collapsed #nav-buttons {
            max-height: 0;
            opacity: 0;
            pointer-events: none;
        }

        #nav-bar button {
            appearance: none;
            border: 1px solid rgba(255,255,255,.2);
            background: rgba(0,0,0,.35);
            color: var(--ink);
            padding: 0.25rem 0.4rem;
            font-size: 0.65rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            line-height: 1.2;
        }

        #nav-bar button:hover {
            border-color: rgba(255,255,255,.35);
            background: rgba(255,255,255,.08);
            transform: translateY(-1px);
        }

        #nav-bar button.active {
            background: var(--mana);
            border-color: var(--mana);
            box-shadow: 0 0 10px rgba(59,130,246,0.3);
        }

        /* Quick Access Panel Buttons */
        #quick-access-panel button {
            appearance: none;
            border: 1px solid rgba(255,255,255,.2);
            background: rgba(0,0,0,.35);
            color: var(--ink);
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #quick-access-panel button:hover {
            border-color: rgba(255,255,255,.35);
            background: rgba(255,255,255,.08);
            transform: translateY(-1px);
        }

        /* Main Content Area */
        #content-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        /* Canvas Container */
        #canvas-container {
            position: absolute;
            inset: 0;
        }

        canvas {
            display: block;
        }

        /* Timeline Panel - COMPACT */
        #timeline-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: rgba(0,0,0,.85);
            backdrop-filter: blur(10px);
            border-top: 1px solid var(--line);
            display: none;
            flex-direction: column;
            pointer-events: all;
        }

        #timeline-panel.active {
            display: flex;
        }

        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.4rem 0.6rem;
            border-bottom: 1px solid var(--line);
        }

        .timeline-controls button {
            padding: 0.3rem 0.5rem;
            background: rgba(255,255,255,.1);
            border: 1px solid var(--line);
            border-radius: 4px;
            color: var(--ink);
            cursor: pointer;
            font-size: 0.7rem;
        }

        .timeline-controls button:hover {
            background: rgba(255,255,255,.15);
        }

        #timeline-track {
            flex: 1;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
            background: rgba(0,0,0,.4);
            cursor: pointer;
            user-select: none;
        }

        #timeline-track:hover {
            background: rgba(0,0,0,.5);
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            background: radial-gradient(1200px 800px at 15% -10%, #10183b, var(--bg));
            color: var(--ink);
            font-family: system-ui, 'Segoe UI', Roboto, Inter, Arial, sans-serif;
        }

        /* Main Container */
        #app-container {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
        }

        /* Top Navigation Bar */
        #nav-bar {
            background: rgba(0,0,0,.5);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--line);
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            z-index: 1000;
            pointer-events: all;
        }

        #nav-bar .logo {
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #nav-bar button {
            appearance: none;
            border: 1px solid rgba(255,255,255,.2);
            background: rgba(0,0,0,.35);
            color: var(--ink);
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #nav-bar button:hover {
            border-color: rgba(255,255,255,.35);
            background: rgba(255,255,255,.08);
        }

        #nav-bar button.active {
            background: var(--mana);
            border-color: var(--mana);
        }

        .timeline-playhead {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--good);
            pointer-events: none;
            z-index: 10;
            transition: left 0.1s ease-out;
        }

        .timeline-playhead::before {
            content: '';
            position: absolute;
            top: 0;
            left: -4px;
            width: 10px;
            height: 10px;
            background: var(--good);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--good);
        }

        .timeline-time-marker {
            position: absolute;
            bottom: 5px;
            font-size: 10px;
            color: var(--muted);
            pointer-events: none;
        }

        .keyframe {
            position: absolute;
            width: 10px;
            height: 30px;
            background: var(--mana);
            border-radius: 3px;
            cursor: pointer;
            top: 50%;
            transform: translateY(-50%);
        }

        .keyframe:hover {
            background: var(--good);
        }

        /* Side Panel - COMPACT */
        #side-panel {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 220px;
            background: rgba(0,0,0,.85);
            backdrop-filter: blur(10px);
            border-left: 1px solid var(--line);
            display: none;
            flex-direction: column;
            pointer-events: all;
            overflow-y: auto;
        }

        #side-panel.active {
            display: flex;
        }

        .panel-section {
            border-bottom: 1px solid var(--line);
            padding: 0.6rem;
        }

        .panel-section h3 {
            margin-bottom: 0.4rem;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: var(--muted);
        }

        .control-group {
            margin-bottom: 0.6rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.3rem;
            font-size: 0.7rem;
        }

        .control-group input[type="range"],
        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group select {
            width: 100%;
            padding: 0.3rem;
            background: rgba(255,255,255,.1);
            border: 1px solid var(--line);
            border-radius: 4px;
            color: var(--ink);
            font-size: 0.7rem;
        }

        .control-group input[type="file"] {
            display: none;
        }

        .file-upload-btn {
            display: block;
            width: 100%;
            padding: 0.4rem;
            background: rgba(255,255,255,.1);
            border: 1px dashed var(--line);
            border-radius: 4px;
            color: var(--ink);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-upload-btn:hover {
            background: rgba(255,255,255,.15);
            border-color: var(--mana);
        }

        /* Reference Image Overlay */
        #reference-image-container {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: none;
        }

        #reference-image-container.active {
            display: block;
        }

        #reference-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Debug Overlay - COMPACT */
        #debug-overlay {
            position: absolute;
            top: 40px;
            left: 8px;
            background: rgba(0,0,0,.85);
            backdrop-filter: blur(10px);
            border: 1px solid var(--line);
            border-radius: 4px;
            padding: 0.4rem 0.6rem;
            font-family: 'Courier New', monospace;
            font-size: 0.6rem;
            display: none;
            pointer-events: none;
        }

        #debug-overlay.active {
            display: block;
        }

        .debug-line {
            margin-bottom: 0.15rem;
            display: flex;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .debug-label {
            color: var(--muted);
        }

        .debug-value {
            color: var(--good);
            font-weight: 600;
        }

        /* Environment Stats Display - COMPACT */
        #environment-stats {
            position: absolute;
            bottom: 180px;
            left: 8px;
            background: rgba(0,0,0,.85);
            backdrop-filter: blur(10px);
            border: 1px solid var(--line);
            border-radius: 4px;
            padding: 0.4rem 0.6rem;
            display: none;
        }

        #environment-stats.active {
            display: block;
        }

        .stat-bar {
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
            color: var(--muted);
        }

        .stat-progress {
            width: 200px;
            height: 8px;
            background: rgba(255,255,255,.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .stat-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, var(--mana), var(--good));
            transition: width 0.3s ease;
        }

        /* Level Up Notification */
        #level-up-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            border: 2px solid var(--gold);
            border-radius: 16px;
            padding: 2rem 3rem;
            text-align: center;
            z-index: 10000;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
        }

        #level-up-notification.active {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        #level-up-notification h2 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        #level-up-notification p {
            font-size: 1rem;
            color: var(--gold);
        }

        /* VectorLabs Button */
        #vectorlabs-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid var(--gold);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.75rem;
            text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
            transition: all 0.3s;
            pointer-events: all;
        }

        #vectorlabs-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.7);
        }

        #vectorlabs-btn.charging {
            animation: charge 2s ease-in-out;
        }

        @keyframes charge {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); box-shadow: 0 20px 60px rgba(102, 126, 234, 1); }
        }

        /* NEXUS Lab Overlay */
        #nexus-lab-overlay {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #nexus-lab-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        #nexus-lab-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Modal Base */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.85);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            pointer-events: all;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(10, 15, 23, 0.98) 0%, rgba(16, 24, 59, 0.98) 100%);
            border: 1px solid var(--line);
            border-radius: 16px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            margin-bottom: 1rem;
            color: var(--ink);
        }

        .modal-content p {
            margin-bottom: 1rem;
            line-height: 1.6;
            color: var(--muted);
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .modal-actions button {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--line);
            background: rgba(255,255,255,.1);
            color: var(--ink);
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-actions button:hover {
            background: rgba(255,255,255,.15);
        }

        .modal-actions button.primary {
            background: var(--mana);
            border-color: var(--mana);
        }

        /* Construction Room */
        #construction-room {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: auto;
            background: transparent;
            display: none;
            flex-direction: column;
            pointer-events: none;
            z-index: 100;
        }

        #construction-room.active {
            display: flex;
        }

        #construction-room.active .construction-toolbar {
            pointer-events: all;
        }

        .construction-toolbar {
            background: rgba(0,0,0,.6);
            border-bottom: 1px solid var(--line);
            padding: 1rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,.1);
            border: 1px solid var(--line);
            border-radius: 6px;
            color: var(--ink);
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: rgba(255,255,255,.15);
        }

        .tool-btn.active {
            background: var(--mana);
            border-color: var(--mana);
        }

        /* Notification Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0,0,0,.9);
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 1rem 1.5rem;
            color: var(--ink);
            opacity: 0;
            transition: all 0.3s;
            z-index: 10001;
            pointer-events: none;
        }

        .toast.active {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--good);
        }

        .toast.error {
            border-color: var(--bad);
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,.3);
        }

        /* Badge Styles (used in various panels) */
        .badge {
            padding: 2px 6px;
            border: 1px solid #274064;
            border-radius: 999px;
            background: #0f1a2b;
            color: #9ad7ff;
            font: 12px system-ui;
        }

        .badge.ok {
            background: #0f2b1a;
            border-color: #2a7a4f;
            color: #9dffc9;
        }

        .badge.off {
            opacity: 0.6;
        }

        #op-status.okText {
            color: #9dffc9;
        }

        #op-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        /* Bulk Tools Modal */
        #bulkModal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 10000;
            background: rgba(0,0,0,.55);
            backdrop-filter: blur(2px);
        }

        #bulkModal .modal-content {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            width: min(980px,96vw);
            max-height: 90vh;
            overflow: auto;
            background: #121722;
            border: 1px solid #2a2f3a;
            border-radius: 14px;
            padding: 14px;
        }

        #bulkModal h3 {
            margin: 0;
            color: var(--ink);
        }

        #bulkDrop {
            border: 1px dashed #3a82ff55;
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        #bulkDrop:hover,
        #bulkDrop.dragover {
            border-color: #3a82ff;
            background: rgba(58,130,255,0.05);
        }

        #bulkList {
            margin-top: 10px;
            border: 1px solid #2a2f3a;
            border-radius: 8px;
            padding: 8px;
            max-height: 38vh;
            overflow: auto;
            font-size: 0.875rem;
        }

        .bulk-controls {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 6px 10px;
            align-items: center;
            font-size: 0.875rem;
        }

        #bulkStatus {
            font-size: 0.875rem;
            margin-top: 8px;
            opacity: 0.85;
        }

        .flex-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 1rem;
        }

        .bulk-layout {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .bulk-section {
            flex: 1;
            min-width: 320px;
        }

        .bulk-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        /* Avatar Hub - hidden video element */
        #cam {
            display: none;
        }

        /* GLB Gallery */
        #glbGallery {
            position: fixed;
            inset: 0;
            z-index: 10000;
            background: rgba(0,0,0,.55);
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .gallery-item {
            background: #1a1f2e;
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .gallery-item:hover {
            border-color: var(--mana);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }

        .gallery-item-thumb {
            width: 100%;
            height: 150px;
            background: #0a0f17;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            opacity: 0.6;
        }

        .gallery-item-name {
            font-size: 0.875rem;
            color: var(--ink);
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .gallery-item-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .gallery-item-actions button {
            flex: 1;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid var(--mana);
            color: var(--ink);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .gallery-item-actions button:hover {
            background: var(--mana);
        }

        .gallery-item-actions button.danger {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--bad);
        }

        .gallery-item-actions button.danger:hover {
            background: var(--bad);
        }

        /* Rotation Control Panel - COMPACT */
        #rotation-panel {
            position: fixed;
            top: 40px;
            right: 10px;
            background: rgba(10, 15, 23, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--line);
            border-radius: 6px;
            padding: 0.5rem;
            z-index: 999;
            display: none;
            min-width: 150px;
        }

        #rotation-panel h4 {
            margin-bottom: 0.4rem;
            color: var(--ink);
            font-size: 0.7rem;
        }

        #rotation-panel button {
            width: 100%;
            padding: 0.3rem;
            margin-bottom: 0.3rem;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid var(--mana);
            color: var(--ink);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.7rem;
        }

        #rotation-panel button:hover {
            background: var(--mana);
        }

        #rotation-panel button.active {
            background: var(--mana);
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
        }

        /* Terrain Builder Modal */
        #terrain-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 998;
            align-items: center;
            justify-content: center;
        }

        #terrain-modal.active {
            display: flex;
        }

        .terrain-content {
            background: rgba(10, 15, 23, 0.98);
            border: 1px solid var(--line);
            border-radius: 16px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
        }

        .terrain-content h2 {
            margin-bottom: 1.5rem;
            color: var(--ink);
            font-size: 1.5rem;
        }

        .terrain-grid {
            display: grid;
            grid-template-columns: 140px 1fr 60px;
            gap: 0.75rem;
            align-items: center;
            margin-bottom: 1rem;
        }

        .terrain-grid label {
            color: var(--muted);
            font-size: 0.875rem;
        }

        .terrain-grid input[type="range"] {
            width: 100%;
        }

        .terrain-grid input[type="number"] {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--line);
            color: var(--ink);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }

        .terrain-grid span {
            text-align: right;
            color: var(--ink);
            font-size: 0.875rem;
            font-weight: 600;
        }

        .terrain-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .terrain-actions button {
            flex: 1;
            padding: 0.75rem;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid var(--mana);
            color: var(--ink);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }

        .terrain-actions button:hover {
            background: var(--mana);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .terrain-actions button.primary {
            background: var(--mana);
        }

        .terrain-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--line);
        }

        .terrain-section:last-child {
            border-bottom: none;
        }

        .terrain-section h3 {
            color: var(--ink);
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        /* Graph Manager Panel */
        #graph-panel {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(10, 15, 23, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 1rem;
            z-index: 999;
            display: none;
            min-width: 220px;
            max-width: 280px;
        }

        #graph-panel h4 {
            margin-bottom: 0.75rem;
            color: var(--ink);
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #graph-panel button {
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid var(--mana);
            color: var(--ink);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        #graph-panel button:hover {
            background: var(--mana);
            transform: translateY(-1px);
        }

        #graph-panel button.active {
            background: var(--mana);
            box-shadow: 0 0 12px rgba(59, 130, 246, 0.5);
        }

        #graph-panel button.danger {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--bad);
        }

        #graph-panel button.danger:hover {
            background: var(--bad);
        }

        #graph-panel .section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--line);
        }

        #graph-panel .info {
            font-size: 0.75rem;
            color: var(--muted);
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #graph-panel .info-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        #graph-panel .info-line:last-child {
            margin-bottom: 0;
        }

        /* Graph visualization elements */
        .graph-node {
            width: 16px;
            height: 16px;
            background: var(--mana);
            border: 2px solid var(--ink);
            border-radius: 50%;
            position: absolute;
            cursor: move;
            z-index: 100;
            transition: transform 0.2s;
        }

        .graph-node:hover {
            transform: scale(1.3);
            background: var(--good);
        }

        .graph-node.selected {
            background: var(--gold);
            box-shadow: 0 0 12px var(--gold);
            transform: scale(1.4);
        }

        .graph-node.boundary {
            background: var(--bad);
        }

        /* Grid overlay */
        #grid-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }

        #grid-overlay.active {
            background-image:
                linear-gradient(rgba(170, 220, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(170, 220, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        /* Responsive Design - ULTRA COMPACT */
        @media (max-width: 1400px) {
            #nav-bar button {
                padding: 0.2rem 0.35rem;
                font-size: 0.6rem;
            }
            
            .logo {
                font-size: 0.7rem;
            }
        }

        @media (max-width: 1024px) {
            #nav-bar button {
                padding: 0.2rem 0.3rem;
                font-size: 0.55rem;
            }
            
            #nav-buttons {
                gap: 0.2rem;
            }
            
            .logo {
                font-size: 0.65rem;
            }
        }

        @media (max-width: 768px) {
            #nav-bar {
                padding: 0.2rem 0.35rem;
            }
            
            #nav-bar button {
                padding: 0.2rem 0.3rem;
                font-size: 0.5rem;
                border-radius: 3px;
            }
            
            #menu-toggle-btn {
                padding: 0.2rem 0.35rem;
                font-size: 0.8rem;
            }
            
            .logo {
                font-size: 0.6rem;
            }
        }

        /* Scrollbar for nav buttons when expanded */
        #nav-buttons::-webkit-scrollbar {
            height: 4px;
        }

        #nav-buttons::-webkit-scrollbar-track {
            background: rgba(0,0,0,.2);
        }

        #nav-buttons::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,.3);
            border-radius: 2px;
        }

        #nav-buttons::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,.5);
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Navigation Bar -->
        <nav id="nav-bar" class="collapsed">
            <div class="logo">GameLite</div>
            <button id="menu-toggle-btn" title="Toggle Menu">☰ <span style="font-size: 0.75rem;">Menu</span></button>
            <div id="nav-buttons">
                <button id="btn-animation" class="active">🎬 Animation</button>
                <button id="btn-construction">🏗️ Construction</button>
                <button id="btn-rigging">🦴 Rigging</button>
                <button id="btn-timeline">⏱️ Timeline</button>
                <button id="btn-debug">🐛 Debug</button>
                <button id="btn-docs">📚 Docs</button>
                <button id="btn-gallery">📦 Gallery</button>
                <button id="btn-bulk-tools">🔧 Bulk Tools</button>
                <button id="btn-avatar-hub">👤 Avatar Hub</button>
                <button id="btn-rotation-control">🔄 Rotation</button>
                <button id="btn-terrain-builder">🏔️ Terrain</button>
                <button id="btn-nexus-lab">🧬 Nexus Lab</button>
                <button id="btn-avatar-pipeline">� Avatar Pipeline</button>
                <button id="btn-city-sandbox">🏙️ City Sandbox</button>
                <button id="btn-vector-ik">🦾 Vector IK</button>
                <button id="btn-storage-manager">💾 Storage</button>
                <button id="btn-sandbox-store">🛒 Sandbox Store</button>
                <button id="btn-webstore">🎮 WebStore</button>
                <button id="btn-nexus-visualizer">🎵 Visualizer</button>
                <button id="btn-unified-studio">🎬 Studio</button>
                <button id="btn-game-builder">🎮 Game Builder</button>
            </div>
        </nav>

        <!-- Rotation Control Panel -->
        <div id="rotation-panel">
            <h4>🔄 Rotation Control</h4>
            <button id="btn-toggle-rotation" class="active">⏸️ Stop All Rotation</button>
            <button id="btn-rotate-selected">🎯 Rotate Selected Only</button>
            <button id="btn-rotate-speed">⚡ Speed: Normal</button>
        </div>

        <!-- Nexus Lab Modal (moved from main canvas) -->

        <!-- Grid Overlay -->
        <div id="grid-overlay"></div>

        <!-- Main Content Area -->
        <div id="content-area">
            <!-- Canvas Container -->
            <div id="canvas-container"></div>

            <!-- Reference Image Overlay -->
            <div id="reference-image-container">
                <img id="reference-image" alt="Reference">
            </div>

            <!-- Debug Overlay -->
            <div id="debug-overlay">
                <div class="debug-line">
                    <span class="debug-label">FPS:</span>
                    <span class="debug-value" id="debug-fps">60</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">Objects:</span>
                    <span class="debug-value" id="debug-objects">0</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">Vertices:</span>
                    <span class="debug-value" id="debug-vertices">0</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">Draw Calls:</span>
                    <span class="debug-value" id="debug-drawcalls">0</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">Memory:</span>
                    <span class="debug-value" id="debug-memory">0 MB</span>
                </div>
            </div>

            <!-- Environment Stats -->
            <div id="environment-stats">
                <div class="stat-bar">
                    <div class="stat-label">Environment Strain</div>
                    <div class="stat-progress">
                        <div class="stat-fill" id="strain-fill" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-bar">
                    <div class="stat-label">Level Progress</div>
                    <div class="stat-progress">
                        <div class="stat-fill" id="level-fill" style="width: 0%"></div>
                    </div>
                </div>
                <div style="font-size: 0.75rem; margin-top: 0.5rem; color: var(--muted);">
                    Current Level: <span id="current-level">1</span>
                </div>
            </div>

            <!-- VectorLabs/NEXUS Lab Button -->
            <button id="vectorlabs-btn" onclick="toggleNexusLab()">
                NEXUS<br>LAB
            </button>

            <!-- NEXUS Lab Overlay (Hidden by default) -->
            <div id="nexus-lab-overlay">
                <iframe id="nexus-lab-iframe" title="NEXUS Dashboard - Advanced Coding Environment"></iframe>
            </div>

            <!-- Timeline Panel -->
            <div id="timeline-panel">
                <div class="timeline-controls">
                    <button id="btn-play">▶ Play</button>
                    <button id="btn-pause">⏸ Pause</button>
                    <button id="btn-stop">⏹ Stop</button>
                    <button id="btn-add-keyframe">+ Keyframe</button>
                    <label>
                        Speed:
                        <input type="range" id="playback-speed" min="0.25" max="2" step="0.25" value="1" style="width: 100px;">
                        <span id="speed-display">1x</span>
                    </label>
                    <button id="btn-snapshot">📸 Snapshot</button>
                    <span id="current-time-display" style="margin-left: auto; color: var(--muted); font-size: 0.875rem;">0.00s / 10s</span>
                </div>
                <div id="timeline-track">
                    <div class="timeline-playhead" id="playhead"></div>
                </div>
            </div>

            <!-- Side Panel -->
            <div id="side-panel">
                <div class="panel-section">
                    <h3>Reference Image</h3>
                    <div class="control-group">
                        <label for="reference-upload" class="file-upload-btn">
                            📁 Upload Reference Image
                        </label>
                        <input type="file" id="reference-upload" accept="image/*">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="show-reference">
                            Show Reference
                        </label>
                    </div>
                    <div class="control-group">
                        <label>Opacity</label>
                        <input type="range" id="reference-opacity" min="0" max="1" step="0.1" value="0.5">
                    </div>
                </div>

                <div class="panel-section">
                    <h3>Object Properties</h3>
                    <div class="control-group">
                        <label>Position X</label>
                        <input type="number" id="prop-x" value="0" step="1">
                    </div>
                    <div class="control-group">
                        <label>Position Y</label>
                        <input type="number" id="prop-y" value="0" step="1">
                    </div>
                    <div class="control-group">
                        <label>Position Z</label>
                        <input type="number" id="prop-z" value="0" step="1">
                    </div>
                    <div class="control-group">
                        <label>Rotation</label>
                        <input type="range" id="prop-rotation" min="0" max="360" value="0">
                    </div>
                    <div class="control-group">
                        <label>Scale</label>
                        <input type="range" id="prop-scale" min="0.1" max="5" step="0.1" value="1">
                    </div>
                    <div class="control-group">
                        <label>Color</label>
                        <input type="color" id="prop-color" value="#667eea">
                    </div>
                </div>

                <div class="panel-section">
                    <h3>Quick Actions</h3>
                    <button class="tool-btn" id="btn-duplicate" style="width: 100%; margin-bottom: 0.5rem;">
                        📋 Duplicate (Shift+D)
                    </button>
                    <button class="tool-btn" id="btn-toggle-snap" style="width: 100%;">
                        🔲 Toggle Snap (X)
                    </button>
                </div>

                <div class="panel-section">
                    <h3>Scene Export</h3>
                    <button class="tool-btn" id="btn-export-json" style="width: 100%; margin-bottom: 0.5rem;">
                        💾 Export Scene (JSON)
                    </button>
                    <button class="tool-btn" id="btn-import-json" style="width: 100%;">
                        📂 Import Scene (JSON)
                    </button>
                    <input type="file" id="import-json-input" accept=".json" style="display: none;">
                </div>
            </div>

            <!-- Construction Room -->
            <div id="construction-room">
                <div class="construction-toolbar">
                    <button class="tool-btn" id="tool-select">Select</button>
                    <button class="tool-btn" id="tool-move">Move</button>
                    <button class="tool-btn" id="tool-rotate">Rotate</button>
                    <button class="tool-btn" id="tool-scale">Scale</button>
                    <button class="tool-btn" id="tool-cube">Add Cube</button>
                    <button class="tool-btn" id="tool-sphere">Add Sphere</button>
                    <button class="tool-btn" id="tool-cylinder">Add Cylinder</button>
                    <button class="tool-btn" id="tool-plane">Add Plane</button>
                    <button class="tool-btn" id="tool-delete">Delete</button>
                    <button class="tool-btn" id="tool-snap">Toggle Snap</button>
                    <button class="tool-btn" id="btn-exit-construction">← Back</button>
                </div>
                <div style="flex: 1; position: relative; background: #000;">
                    <div id="construction-canvas-container"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Level Up Notification -->
    <div id="level-up-notification">
        <h2>🎉 LEVEL UP! 🎉</h2>
        <p id="level-up-text">You've reached Level 2!</p>
    </div>

    <!-- Documentation Modal -->
    <div id="docs-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>📚 GameLite Documentation</h2>
            <h3>Welcome to GameLite!</h3>
            <p>GameLite is a comprehensive 3D animation and modeling platform built with native web technologies.</p>

            <h3>Features:</h3>
            <ul style="margin-left: 1.5rem; line-height: 2;">
                <li><strong>Animation Timeline:</strong> Create keyframe animations with timeline controls</li>
                <li><strong>Reference Tracing:</strong> Import reference images and trace over them</li>
                <li><strong>Construction Room:</strong> Build 3D scenes with primitive shapes</li>
                <li><strong>Character Rigging:</strong> Rig and animate characters</li>
                <li><strong>Environment Leveling:</strong> Dynamic performance-based progression system</li>
                <li><strong>Debug Tools:</strong> Real-time performance monitoring</li>
            </ul>

            <h3>Create Your Own Level System</h3>
            <p>The environment leveling system tracks performance metrics and unlocks features based on usage:</p>
            <ul style="margin-left: 1.5rem; line-height: 2;">
                <li>Object Count: More objects = higher strain</li>
                <li>Animation Complexity: Complex animations increase strain</li>
                <li>Render Performance: FPS affects level progression</li>
            </ul>

            <p><strong>Customize Your System:</strong> Edit the EnvironmentStats object in the source code to adjust thresholds, unlock conditions, and progression rules.</p>

            <div class="modal-actions">
                <button id="btn-close-docs">Close</button>
            </div>
        </div>
    </div>

    <!-- Toast Notifications -->
    <div id="toast" class="toast"></div>

    <!-- GLB Gallery Modal -->
    <div id="glbGallery" style="display: none;">
        <div class="modal-content">
            <div class="flex-between">
                <h3>📦 GLB Gallery — Your Saved Models</h3>
                <button id="galleryClose" class="tool-btn">Close</button>
            </div>
            <div id="galleryGrid" class="gallery-grid"></div>
            <div id="galleryEmpty" style="text-align: center; padding: 2rem; opacity: 0.7;">
                No models in gallery yet. Generate models from Avatar Hub or Bulk Tools to populate your gallery.
            </div>
        </div>
    </div>

    <!-- Terrain Builder Modal -->
    <div id="terrain-modal">
        <div class="terrain-content">
            <h2>🏔️ Terrain Builder</h2>

            <div class="terrain-section" style="background: rgba(16, 224, 224, 0.1); border-left: 3px solid #10e0e0;">
                <h3>🧬 Nexus Boundary</h3>
                <div id="boundary-status" style="padding: 0.5rem; font-size: 0.9rem;">
                    <span id="boundary-info">No boundary selected. Create a boundary in Nexus Lab to constrain terrain.</span>
                </div>
            </div>

            <div class="terrain-section">
                <h3>📐 Base Dimensions</h3>
                <div class="terrain-grid">
                    <label>Width (m)</label>
                    <input type="range" id="terrain-width" min="10" max="500" value="100" step="10">
                    <span id="terrain-width-val">100</span>

                    <label>Height (m)</label>
                    <input type="range" id="terrain-height" min="10" max="500" value="100" step="10">
                    <span id="terrain-height-val">100</span>

                    <label>Resolution</label>
                    <input type="range" id="terrain-resolution" min="32" max="256" value="128" step="16">
                    <span id="terrain-resolution-val">128</span>
                </div>
            </div>

            <div class="terrain-section">
                <h3>🌄 Displacement</h3>
                <div class="terrain-grid">
                    <label>Max Height (m)</label>
                    <input type="range" id="terrain-max-height" min="0" max="50" value="10" step="0.5">
                    <span id="terrain-max-height-val">10</span>

                    <label>Noise Scale</label>
                    <input type="range" id="terrain-noise-scale" min="0.01" max="0.5" value="0.1" step="0.01">
                    <span id="terrain-noise-scale-val">0.1</span>

                    <label>Octaves</label>
                    <input type="range" id="terrain-octaves" min="1" max="8" value="4" step="1">
                    <span id="terrain-octaves-val">4</span>

                    <label>Persistence</label>
                    <input type="range" id="terrain-persistence" min="0.1" max="0.9" value="0.5" step="0.1">
                    <span id="terrain-persistence-val">0.5</span>

                    <label>Lacunarity</label>
                    <input type="range" id="terrain-lacunarity" min="1.5" max="3.5" value="2.0" step="0.1">
                    <span id="terrain-lacunarity-val">2.0</span>
                </div>
            </div>

            <div class="terrain-section">
                <h3>🎨 Texture & Color</h3>
                <div class="terrain-grid">
                    <label>Texture Type</label>
                    <select id="terrain-texture-type" style="grid-column: 2 / 4; padding: 0.5rem; background: rgba(0,0,0,0.3); border: 1px solid var(--line); color: var(--ink); border-radius: 4px;">
                        <option value="gradient">Height Gradient</option>
                        <option value="noise">Procedural Noise</option>
                        <option value="grass">Grass</option>
                        <option value="rock">Rock</option>
                        <option value="sand">Sand</option>
                        <option value="snow">Snow</option>
                    </select>

                    <label>Color Mix</label>
                    <input type="range" id="terrain-color-mix" min="0" max="1" value="0.5" step="0.1">
                    <span id="terrain-color-mix-val">0.5</span>

                    <label>Roughness</label>
                    <input type="range" id="terrain-roughness" min="0" max="1" value="0.8" step="0.1">
                    <span id="terrain-roughness-val">0.8</span>

                    <label>Metalness</label>
                    <input type="range" id="terrain-metalness" min="0" max="1" value="0.1" step="0.1">
                    <span id="terrain-metalness-val">0.1</span>
                </div>
            </div>

            <div class="terrain-section">
                <h3>✨ Advanced Noise</h3>
                <div class="terrain-grid">
                    <label>Noise Seed</label>
                    <input type="number" id="terrain-seed" value="12345" style="grid-column: 2 / 4;">

                    <label>Noise Type</label>
                    <select id="terrain-noise-type" style="grid-column: 2 / 4; padding: 0.5rem; background: rgba(0,0,0,0.3); border: 1px solid var(--line); color: var(--ink); border-radius: 4px;">
                        <option value="perlin">Perlin</option>
                        <option value="simplex">Simplex</option>
                        <option value="cellular">Cellular</option>
                        <option value="ridged">Ridged</option>
                    </select>

                    <label>Erosion</label>
                    <input type="range" id="terrain-erosion" min="0" max="1" value="0" step="0.1">
                    <span id="terrain-erosion-val">0</span>
                </div>
            </div>

            <div class="terrain-actions">
                <button id="btn-generate-terrain" class="primary">🏔️ Generate Terrain</button>
                <button id="btn-clear-terrain">🗑️ Clear</button>
                <button id="btn-close-terrain">✖️ Close</button>
            </div>
        </div>
    </div>

    <!-- Game Builder Modal -->
    <div id="game-builder-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 10000;">
        <div style="width: 100%; height: 100%; display: flex; flex-direction: column;">
            <!-- Header -->
            <div style="background: rgba(20,20,30,0.95); border-bottom: 1px solid rgba(255,255,255,0.1); padding: 1rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h2 style="color: white; font-size: 1.5rem; margin: 0;">🎮 3D Game Builder - Extended Canvas</h2>
                    <button id="game-builder-close" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer;">✖️ Close</button>
                </div>
                
                <!-- Prefab Buttons -->
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <button class="gb-prefab-btn" data-prefab="cube" style="background: #ff4757; border: none; color: white; padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer; font-weight: 500;">Cube</button>
                    <button class="gb-prefab-btn" data-prefab="sphere" style="background: #5352ed; border: none; color: white; padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer; font-weight: 500;">Sphere</button>
                    <button class="gb-prefab-btn" data-prefab="cylinder" style="background: #2ed573; border: none; color: white; padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer; font-weight: 500;">Cylinder</button>
                    <button class="gb-prefab-btn" data-prefab="cone" style="background: #ffa502; border: none; color: white; padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer; font-weight: 500;">Cone</button>
                    <button class="gb-prefab-btn" data-prefab="torus" style="background: #a55eea; border: none; color: white; padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer; font-weight: 500;">Torus</button>
                    <button class="gb-prefab-btn" data-prefab="pyramid" style="background: #fd79a8; border: none; color: white; padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer; font-weight: 500;">Pyramid</button>
                </div>
                
                <!-- Actions -->
                <div style="display: flex; gap: 0.5rem;">
                    <button id="game-builder-clear" style="background: #e74c3c; border: none; color: white; padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer; font-weight: 500;">Clear All</button>
                    <div id="game-builder-count" style="background: rgba(255,255,255,0.1); color: #999; padding: 0.5rem 1rem; border-radius: 8px;">Objects: 0</div>
                </div>
            </div>
            
            <!-- 3D Canvas Container -->
            <div id="game-builder-canvas" style="flex: 1; position: relative; background: #0a0a1a;">
                <!-- Controls Info -->
                <div style="position: absolute; top: 1rem; left: 1rem; background: rgba(20,20,30,0.9); color: white; padding: 0.75rem; border-radius: 8px; font-size: 0.875rem; z-index: 100;">
                    <div style="font-weight: bold; margin-bottom: 0.5rem;">Controls:</div>
                    <div>• Left Click: Place object</div>
                    <div>• Right Click + Drag: Rotate view</div>
                    <div>• Mouse Wheel: Zoom</div>
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: #999;">Grid: 200x200 units</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bulk Tools Modal -->
    <div id="bulkModal">
        <div class="modal-content">
            <div class="flex-between">
                <h3>Bulk Tools — ZIP → Pairs → Masks / GLBs</h3>
                <button id="bulkClose" class="tool-btn">Close</button>
            </div>
            <div class="bulk-layout">
                <div class="bulk-section">
                    <div id="bulkDrop">Drop a .zip of silhouettes here</div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem;">
                        <button id="bulkUploadZip" class="tool-btn" style="flex: 1;">📁 Upload ZIP</button>
                        <button id="bulkUploadSingle" class="tool-btn" style="flex: 1; background: var(--mana); color: white;">🖼️ Upload Single PNG</button>
                    </div>
                    <div id="bulkList"></div>
                </div>
                <div class="bulk-section">
                    <div class="bulk-controls">
                        <div>Preset</div>
                        <select id="bulkPreset">
                            <option value="auto">Auto (Otsu)</option>
                            <option value="baked">Baked 90/103</option>
                            <option value="high-quality">High Quality</option>
                            <option value="fast">Fast Preview</option>
                        </select>
                        <span></span>

                        <div>Auto-thr</div>
                        <input id="bulkAuto" type="checkbox" checked>
                        <span></span>

                        <div>Dual thr</div>
                        <input id="bulkDual" type="checkbox">
                        <span></span>

                        <div>Thr</div>
                        <input id="bulkThr" type="range" min="0" max="255" value="190">
                        <span id="bulkThrV">190</span>

                        <div>Clean px</div>
                        <input id="bulkKern" type="range" min="0" max="6" value="2">
                        <span id="bulkKernV">2</span>

                        <div>Res (N)</div>
                        <input id="bulkRes" type="range" min="48" max="192" value="128">
                        <span id="bulkResV">128</span>

                        <div>Iso</div>
                        <input id="bulkIso" type="range" min="0.1" max="0.9" step="0.01" value="0.50">
                        <span id="bulkIsoV">0.50</span>

                        <div>Height (m)</div>
                        <input id="bulkH" type="range" min="0.9" max="2.4" step="0.01" value="1.70">
                        <span id="bulkHV">1.70</span>

                        <div>Smooth</div>
                        <input id="bulkSubs" type="range" min="0" max="2" value="1">
                        <span id="bulkSubsV">1</span>

                        <div>Flip Side X</div>
                        <input id="bulkFlip" type="checkbox">
                        <span></span>
                    </div>
                    <div class="bulk-actions">
                        <button id="bulkRunBoth" class="tool-btn" style="grid-column: 1/4; background: var(--mana); color: white;">⚡ Batch Both (Masks + GLBs)</button>
                        <button id="bulkRunGLB" class="tool-btn">Batch Export (GLBs.zip)</button>
                        <button id="bulkRunMasks" class="tool-btn">Batch Masks (PNGs.zip)</button>
                    </div>
                    <div id="bulkStatus"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Storage Manager Modal -->
    <div id="storageModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 1000; overflow: auto;">
        <div style="max-width: 900px; margin: 2rem auto; background: rgba(10,15,23,0.95); border: 1px solid var(--line); border-radius: 12px; padding: 2rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <h2 style="margin: 0;">💾 Storage Manager</h2>
                <button id="storageClose" style="padding: 0.5rem 1rem; background: rgba(255,60,60,0.8); color: white; border: none; border-radius: 6px; cursor: pointer;">✕ Close</button>
            </div>

            <!-- Storage Usage Info -->
            <div style="background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem;">
                <h3 style="margin: 0 0 1rem 0; color: var(--mana);">📊 Usage Statistics</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                    <div>
                        <div style="font-size: 0.875rem; color: var(--muted);">Total Storage</div>
                        <div id="storage-total" style="font-size: 1.5rem; font-weight: bold; color: var(--ink);">0 KB</div>
                    </div>
                    <div>
                        <div style="font-size: 0.875rem; color: var(--muted);">Items Saved</div>
                        <div id="storage-count" style="font-size: 1.5rem; font-weight: bold; color: var(--ink);">0</div>
                    </div>
                    <div>
                        <div style="font-size: 0.875rem; color: var(--muted);">Space Used</div>
                        <div id="storage-percent" style="font-size: 1.5rem; font-weight: bold; color: var(--good);">0%</div>
                    </div>
                </div>
                <div style="margin-top: 1rem; height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; overflow: hidden;">
                    <div id="storage-bar" style="height: 100%; background: linear-gradient(90deg, var(--mana), var(--good)); width: 0%; transition: width 0.3s;"></div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                <button id="storage-export" style="padding: 1rem; background: var(--mana); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                    📤 Export All Data
                </button>
                <button id="storage-import" style="padding: 1rem; background: var(--good); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                    📥 Import Data
                </button>
                <button id="storage-clear" style="padding: 1rem; background: var(--bad); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                    🗑️ Clear All
                </button>
            </div>

            <!-- Saved Items List -->
            <div style="background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 8px; padding: 1.5rem;">
                <h3 style="margin: 0 0 1rem 0; color: var(--mana);">📦 Saved Items</h3>
                <div id="storage-items" style="max-height: 400px; overflow-y: auto;">
                    <!-- Items will be populated here -->
                </div>
            </div>

            <!-- Projects Section -->
            <div style="background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 8px; padding: 1.5rem; margin-top: 1.5rem;">
                <h3 style="margin: 0 0 1rem 0; color: var(--gold);">📁 Saved Projects</h3>
                <div id="storage-projects" style="max-height: 300px; overflow-y: auto;">
                    <!-- Projects will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Nexus Lab Modal -->
    <div id="nexus-lab-modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 1000; overflow: auto;">
        <div style="position: relative; width: 100%; height: 100%;">
            <!-- Close button -->
            <button id="nexus-lab-close" style="position: absolute; top: 20px; right: 20px; z-index: 10; padding: 10px 20px; background: rgba(255,60,60,0.9); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                ✕ Close Nexus Lab
            </button>

            <!-- Nexus Lab Canvas Container -->
            <div id="nexus-canvas-container" style="width: 100%; height: 100%;"></div>
        </div>
    </div>

    <!-- THREE.js Library -->
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
          }
        }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { TransformControls } from 'three/examples/jsm/controls/TransformControls.js';
    import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';
    import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';

    // Expose THREE to global scope for Bulk Tools
    window.THREE = THREE;
    window.MarchingCubes = MarchingCubes;
    window.GLTFExporter = GLTFExporter;
    console.log('✅ THREE.js, MarchingCubes, and GLTFExporter exposed to window:', {
        THREE: !!THREE,
        MarchingCubes: !!MarchingCubes,
        GLTFExporter: !!GLTFExporter
    });

    // ============================================
    // CORE APPLICATION STATE
    // ============================================
    const AppState = {
        scene: null,
        camera: null,
        renderer: null,
        controls: null,
        transformControls: null,
        clock: new THREE.Clock(),
        raycaster: new THREE.Raycaster(),
        mouse: new THREE.Vector2(),
        currentMode: 'animation',
        currentTool: 'select',
        objects: [],
        selectedObject: null,
        hoveredObject: null,
        snapToGrid: false,
        rotationEnabled: true,
        rotationSpeed: 0.2,
        rotateSelectedOnly: false,
        terrainMesh: null,
        nexusGraph: {
            nodes: [],           // {id, x, y, mesh3D (cube marker)}
            edges: [],           // {id, nodeA, nodeB, line3D}
            boundaries: [],      // {id, nodes[], mesh3D (plane)}
            selectedBoundary: null,
            gridSize: 48,        // Match main grid spacing
            nodeIdCounter: 0
        },
        masterGrid: {
            cellSize: 480,       // Each region is 480 units (10 grid cells)
            gridWidth: 5,        // 5x5 grid = 25 regions
            gridHeight: 5,
            currentRegion: { x: 2, y: 2 }, // Center cell (where cube starts)
            targetRegion: { x: 2, y: 2 },  // Where to import terrain
            regions: {},         // Stored terrain data per region: { "2,2": { nodes, edges, boundaries } }
            showPreviewGrid: false
        },
        animationState: {
            isPlaying: false,
            currentTime: 0,
            duration: 10,
            playbackSpeed: 1,
            keyframes: []
        },
        referenceImage: null,
        referenceImageOpacity: 0.5,
        showReference: false,
        environmentStats: {
            level: 1,
            strain: 0,
            maxStrain: 100,
            objectCount: 0,
            vertexCount: 0,
            fps: 60,
            levelHistory: []
        },
        history: {
            undoStack: [],
            redoStack: [],
            maxHistorySize: 50
        }
    };

    // ============================================
    // UNDO/REDO SYSTEM
    // ============================================
    function saveState(actionName) {
        const state = {
            action: actionName,
            timestamp: Date.now(),
            objects: AppState.objects.map(obj => ({
                type: obj.type,
                keyframes: obj.keyframes.map(kf => ({...kf})),
                properties: {
                    position: obj.mesh.position.clone(),
                    rotation: obj.mesh.rotation.clone(),
                    scale: obj.mesh.scale.clone()
                },
                color: obj.mesh.material.color.getHex(),
                uuid: obj.mesh.uuid
            })),
            selectedObjectUuid: AppState.selectedObject?.mesh.uuid || null,
            animationState: {
                currentTime: AppState.animationState.currentTime,
                duration: AppState.animationState.duration,
                keyframes: [...AppState.animationState.keyframes]
            }
        };

        AppState.history.undoStack.push(state);

        // Limit stack size
        if (AppState.history.undoStack.length > AppState.history.maxHistorySize) {
            AppState.history.undoStack.shift();
        }

        // Clear redo stack when new action is performed
        AppState.history.redoStack = [];

        console.log(`📝 Saved state: ${actionName}`);
    }

    function undo() {
        if (AppState.history.undoStack.length === 0) {
            showToast('Nothing to undo', 'error');
            return;
        }

        // Save current state to redo stack before undoing
        const currentState = {
            action: 'current',
            timestamp: Date.now(),
            objects: AppState.objects.map(obj => ({
                type: obj.type,
                keyframes: obj.keyframes.map(kf => ({...kf})),
                properties: {
                    position: obj.mesh.position.clone(),
                    rotation: obj.mesh.rotation.clone(),
                    scale: obj.mesh.scale.clone()
                },
                color: obj.mesh.material.color.getHex(),
                uuid: obj.mesh.uuid
            })),
            selectedObjectUuid: AppState.selectedObject?.mesh.uuid || null,
            animationState: {
                currentTime: AppState.animationState.currentTime,
                duration: AppState.animationState.duration,
                keyframes: [...AppState.animationState.keyframes]
            }
        };
        AppState.history.redoStack.push(currentState);

        // Restore previous state
        const previousState = AppState.history.undoStack.pop();
        restoreState(previousState);

        showToast(`⟲ Undid: ${previousState.action}`, 'success');
    }

    function redo() {
        if (AppState.history.redoStack.length === 0) {
            showToast('Nothing to redo', 'error');
            return;
        }

        // Save current state to undo stack before redoing
        const currentState = {
            action: 'redo_point',
            timestamp: Date.now(),
            objects: AppState.objects.map(obj => ({
                type: obj.type,
                keyframes: obj.keyframes.map(kf => ({...kf})),
                properties: {
                    position: obj.mesh.position.clone(),
                    rotation: obj.mesh.rotation.clone(),
                    scale: obj.mesh.scale.clone()
                },
                color: obj.mesh.material.color.getHex(),
                uuid: obj.mesh.uuid
            })),
            selectedObjectUuid: AppState.selectedObject?.mesh.uuid || null,
            animationState: {
                currentTime: AppState.animationState.currentTime,
                duration: AppState.animationState.duration,
                keyframes: [...AppState.animationState.keyframes]
            }
        };
        AppState.history.undoStack.push(currentState);

        // Restore next state
        const nextState = AppState.history.redoStack.pop();
        restoreState(nextState);

        showToast(`⟳ Redid: ${nextState.action}`, 'success');
    }

    function restoreState(state) {
        // Clear current objects
        AppState.objects.forEach(obj => {
            AppState.scene.remove(obj.mesh);
            obj.mesh.geometry.dispose();
            obj.mesh.material.dispose();
        });
        AppState.objects = [];

        // Restore objects from state
        state.objects.forEach(objData => {
            let geometry, material, mesh;

            // Recreate geometry
            switch(objData.type.toLowerCase()) {
                case 'cube':
                case 'box':
                    geometry = new THREE.BoxGeometry(2, 2, 2);
                    break;
                case 'sphere':
                case 'ball':
                    geometry = new THREE.SphereGeometry(1, 32, 32);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(1, 2, 32);
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
                    break;
                case 'plane':
                    geometry = new THREE.PlaneGeometry(5, 5);
                    break;
                default:
                    geometry = new THREE.BoxGeometry(2, 2, 2);
            }

            material = new THREE.MeshStandardMaterial({
                color: objData.color,
                roughness: 0.5,
                metalness: 0.5
            });

            mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(objData.properties.position);
            mesh.rotation.copy(objData.properties.rotation);
            mesh.scale.copy(objData.properties.scale);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.uuid = objData.uuid;

            AppState.scene.add(mesh);
            AppState.objects.push({
                mesh: mesh,
                type: objData.type,
                keyframes: objData.keyframes,
                properties: objData.properties
            });
        });

        // Restore selection
        if (state.selectedObjectUuid) {
            const selectedObj = AppState.objects.find(obj => obj.mesh.uuid === state.selectedObjectUuid);
            if (selectedObj) {
                AppState.selectedObject = selectedObj;
                if (AppState.transformControls) {
                    AppState.transformControls.attach(selectedObj.mesh);
                }
            }
        } else {
            AppState.selectedObject = null;
            if (AppState.transformControls) {
                AppState.transformControls.detach();
            }
        }

        // Restore animation state
        AppState.animationState.currentTime = state.animationState.currentTime;
        AppState.animationState.duration = state.animationState.duration;
        AppState.animationState.keyframes = state.animationState.keyframes;

        updateEnvironmentStats();
    }

    // ============================================
    // GLYPHIC SHADER - 4-LAYER NEON
    // ============================================
    function createGlyphicShader() {
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                audioLevel: { value: 0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                speed: { value: 1.0 },
                zoom: { value: 1.0 },
                distortion: { value: 0.5 },
                complexity: { value: 16.0 },
                colorA: { value: new THREE.Color(0x667eea) },
                colorB: { value: new THREE.Color(0x764ba2) },
                colorC: { value: new THREE.Color(0x3a82ff) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                precision highp float;
                uniform float time;
                uniform float audioLevel;
                uniform vec2 resolution;
                uniform float speed;
                uniform float zoom;
                uniform float distortion;
                uniform float complexity;
                uniform vec3 colorA;
                uniform vec3 colorB;
                uniform vec3 colorC;
                varying vec2 vUv;

                float sat(float x) { return clamp(x, 0.0, 1.0); }

                float ring(vec2 p, float r, float w) {
                    return 1.0 - smoothstep(r - w, r, length(p)) + smoothstep(r, r + w, length(p));
                }

                float spoke(vec2 p, float ang, float w) {
                    float a = atan(p.y, p.x);
                    float d = abs(sin((a - ang) * 0.5));
                    return 1.0 - smoothstep(0.0, w, d);
                }

                float glow(float d, float i) { return exp(-d * i); }

                vec3 cyc(float t) {
                    return 0.5 + 0.5 * cos(6.28318 * (vec3(0.30, 0.60, 0.90) * t + vec3(0.0, 0.2, 0.4)));
                }

                void main() {
                    vec2 uv = (vUv - 0.5) * 2.0;
                    uv.x *= resolution.x / resolution.y;
                    uv *= 1.0 / zoom;

                    float N = floor(max(6.0, complexity));
                    float w = mix(0.025, 0.008, sat(N / 20.0));
                    float R = 0.75;

                    // Spokes
                    float spokes = 0.0;
                    for (float i = 0.0; i < 32.0; i += 1.0) {
                        if (i >= N) break;
                        float ang = (i / N) * 6.28318 + time * 0.05 * speed;
                        float wob = sin(time * 0.6 + i * 3.1) * 0.02 * (0.2 + audioLevel * 0.8);
                        spokes += spoke(uv, ang + wob, w);
                    }

                    float rim = ring(uv, R, 0.015);
                    float base = sat(spokes * 0.85 + rim * 1.2);
                    float dToR = abs(length(uv) - R);
                    float halo = glow(dToR * 18.0, 1.6);

                    // Nodes
                    float nodes = 0.0;
                    float nodeW = 0.035;
                    for (float i = 0.0; i < 32.0; i += 1.0) {
                        if (i >= N) break;
                        float ang = (i / N) * 6.28318;
                        vec2 pt = vec2(cos(ang), sin(ang)) * R;
                        float d = length(uv - pt);
                        float pulse = 0.5 + 0.5 * sin(time * 5.0 * speed + i * 2.0 + audioLevel * 8.0);
                        nodes += smoothstep(nodeW, 0.0, d) * pulse;
                    }

                    // Color palette
                    vec3 palShift = cyc(time * 0.10);
                    vec3 A = mix(colorA, palShift, 0.25);
                    vec3 B = mix(colorB, palShift, 0.25);
                    vec3 C = mix(colorC, palShift, 0.25);

                    vec3 col = vec3(0.0);
                    col += A * base;
                    col += B * halo * (0.6 + 0.4 * audioLevel);
                    col += C * nodes * (0.7 + 0.6 * audioLevel);

                    // Strobe effect
                    float strobe = step(0.87, fract(sin(time * 4.0 * speed + audioLevel * 6.0) * 0.5 + 0.5));
                    col += strobe * 0.15 * (A + B + C);

                    // Vignette
                    float vig = smoothstep(1.4, 0.2, length(uv));
                    col *= vig;

                    // Gamma correction
                    col = pow(col, vec3(0.4545));

                    gl_FragColor = vec4(col, 1.0);
                }
            `,
            depthWrite: false,
            depthTest: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.renderOrder = -1; // Render first (background)
        mesh.frustumCulled = false;

        return mesh;
    }

    // Toggle Glyphic Shader
    function toggleGlyphicShader() {
        if (!AppState.glyphicShader) return;

        AppState.glyphicShader.visible = !AppState.glyphicShader.visible;

        if (AppState.glyphicShader.visible) {
            // Add to scene if not already there
            if (!AppState.scene.children.includes(AppState.glyphicShader)) {
                AppState.scene.add(AppState.glyphicShader);
            }
            // Disable default background
            AppState.scene.background = null;
            showToast('Glyphic Shader Enabled 🌀', 'success');
        } else {
            // Re-enable default background
            AppState.scene.background = new THREE.Color(0x0a0f17);
            showToast('Glyphic Shader Disabled', 'info');
        }
    }

    // Update Glyphic Shader uniforms
    function updateGlyphicShader(deltaTime) {
        if (!AppState.glyphicShader || !AppState.glyphicShader.visible) return;

        const material = AppState.glyphicShader.material;
        material.uniforms.time.value += deltaTime;
        material.uniforms.audioLevel.value = Math.random() * 0.3 + 0.2; // Placeholder for audio
        material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    function init() {
        initScene();
        initControls();
        initEventListeners();
        initEnvironmentStats();
        BulkTools.init();
        GLBGallery.init();
        animate();
        showToast('Welcome to GameLite! 🎮 Gallery: ' + GLBGallery.models.length + ' models', 'success');
    }

    function initScene() {
        const container = document.getElementById('canvas-container');

        // Scene
        AppState.scene = new THREE.Scene();
        AppState.scene.background = new THREE.Color(0x0a0f17);
        AppState.scene.fog = new THREE.Fog(0x0a0f17, 50, 200);

        // Camera
        AppState.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        AppState.camera.position.set(0, 10, 20);

        // Renderer
        AppState.renderer = new THREE.WebGLRenderer({ antialias: true });
        AppState.renderer.setSize(window.innerWidth, window.innerHeight);
        AppState.renderer.setPixelRatio(window.devicePixelRatio);
        AppState.renderer.shadowMap.enabled = true;
        AppState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(AppState.renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        AppState.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        AppState.scene.add(directionalLight);

        // Floor Mesh
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1f2e,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        AppState.scene.add(floor);

        // Grid on top of floor
        const gridHelper = new THREE.GridHelper(50, 50, 0x667eea, 0x334477);
        gridHelper.position.y = 0.01; // Slightly above floor
        AppState.scene.add(gridHelper);

        // Glyphic Shader Background (optional)
        AppState.glyphicShader = createGlyphicShader();
        AppState.glyphicShader.visible = false; // Hidden by default

        // Orbit Controls
        AppState.controls = new OrbitControls(AppState.camera, AppState.renderer.domElement);
        AppState.controls.enableDamping = true;
        AppState.controls.dampingFactor = 0.05;

        // Transform Controls for moving/rotating/scaling objects
        AppState.transformControls = new TransformControls(AppState.camera, AppState.renderer.domElement);
        AppState.transformControls.addEventListener('dragging-changed', (event) => {
            AppState.controls.enabled = !event.value; // Disable orbit when dragging object
        });
        AppState.transformControls.addEventListener('objectChange', () => {
            if (AppState.selectedObject) {
                updatePropertyPanel();
            }
        });
        AppState.scene.add(AppState.transformControls);

        // Add a default cube
        addDefaultCube();
    }

    function addDefaultCube() {
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshStandardMaterial({
            color: 0x667eea,
            roughness: 0.5,
            metalness: 0.5
        });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 1, 0);
        cube.castShadow = true;
        cube.receiveShadow = true;
        AppState.scene.add(cube);
        AppState.objects.push({
            mesh: cube,
            type: 'cube',
            keyframes: [],
            properties: {
                position: cube.position.clone(),
                rotation: cube.rotation.clone(),
                scale: cube.scale.clone()
            }
        });
        updateEnvironmentStats();
    }

    function initControls() {
        // Window resize
        window.addEventListener('resize', onWindowResize);

        // Mouse click for object selection
        AppState.renderer.domElement.addEventListener('click', onCanvasClick);

        // Mouse move for hover effects
        AppState.renderer.domElement.addEventListener('mousemove', onCanvasHover);
    }

    function onWindowResize() {
        AppState.camera.aspect = window.innerWidth / window.innerHeight;
        AppState.camera.updateProjectionMatrix();
        AppState.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onCanvasClick(event) {
        // Calculate mouse position in normalized device coordinates (-1 to +1)
        const rect = AppState.renderer.domElement.getBoundingClientRect();
        AppState.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        AppState.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Update the raycaster
        AppState.raycaster.setFromCamera(AppState.mouse, AppState.camera);

        // Get all mesh objects
        const meshes = AppState.objects.map(obj => obj.mesh);

        // Check for intersections
        const intersects = AppState.raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
            // Deselect previous object
            if (AppState.selectedObject) {
                AppState.selectedObject.mesh.material.emissive.setHex(0x000000);
            }

            // Select new object
            const selectedMesh = intersects[0].object;
            const selectedObj = AppState.objects.find(obj => obj.mesh === selectedMesh);

            if (selectedObj) {
                AppState.selectedObject = selectedObj;
                // Highlight selected object
                selectedObj.mesh.material.emissive.setHex(0x444444);

                // Attach transform controls
                AppState.transformControls.attach(selectedObj.mesh);

                // Update property panel
                updatePropertyPanel();

                showToast(`Selected ${selectedObj.type} - Use toolbar to Move/Rotate/Scale`, 'success');
            }
        } else {
            // Clicked empty space - deselect
            if (AppState.selectedObject) {
                AppState.selectedObject.mesh.material.emissive.setHex(0x000000);
                AppState.transformControls.detach();
                AppState.selectedObject = null;
                showToast('Object deselected', 'success');
            }
        }
    }

    function updatePropertyPanel() {
        if (!AppState.selectedObject) return;

        const obj = AppState.selectedObject.mesh;
        document.getElementById('prop-x').value = obj.position.x.toFixed(2);
        document.getElementById('prop-y').value = obj.position.y.toFixed(2);
        document.getElementById('prop-z').value = obj.position.z.toFixed(2);
        document.getElementById('prop-rotation').value = Math.round(obj.rotation.y * 180 / Math.PI);
        document.getElementById('prop-scale').value = obj.scale.x.toFixed(2);

        // Update color picker to match object's current color
        const color = '#' + obj.material.color.getHexString();
        document.getElementById('prop-color').value = color;
    }

    function onCanvasHover(event) {
        // Only show hover effects when not dragging
        if (AppState.transformControls.dragging) return;

        // Calculate mouse position
        const rect = AppState.renderer.domElement.getBoundingClientRect();
        AppState.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        AppState.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Update raycaster
        AppState.raycaster.setFromCamera(AppState.mouse, AppState.camera);

        // Get all mesh objects
        const meshes = AppState.objects.map(obj => obj.mesh);

        // Check for intersections
        const intersects = AppState.raycaster.intersectObjects(meshes);

        // Remove previous hover effect
        if (AppState.hoveredObject && AppState.hoveredObject !== AppState.selectedObject) {
            AppState.hoveredObject.mesh.material.emissive.setHex(0x000000);
        }

        if (intersects.length > 0) {
            const hoveredMesh = intersects[0].object;
            const hoveredObj = AppState.objects.find(obj => obj.mesh === hoveredMesh);

            if (hoveredObj && hoveredObj !== AppState.selectedObject) {
                AppState.hoveredObject = hoveredObj;
                // Subtle hover highlight
                hoveredObj.mesh.material.emissive.setHex(0x222222);
                AppState.renderer.domElement.style.cursor = 'pointer';
            }
        } else {
            AppState.hoveredObject = null;
            AppState.renderer.domElement.style.cursor = 'default';
        }
    }

    // ============================================
    // EVENT LISTENERS
    // ============================================
    function initEventListeners() {
        // Menu toggle
        document.getElementById('menu-toggle-btn').addEventListener('click', () => {
            const navBar = document.getElementById('nav-bar');
            navBar.classList.toggle('collapsed');
            
            // Store preference in localStorage
            const isCollapsed = navBar.classList.contains('collapsed');
            localStorage.setItem('menuCollapsed', isCollapsed);
        });

        // Restore menu state from localStorage
        const savedState = localStorage.getItem('menuCollapsed');
        if (savedState === 'false') {
            document.getElementById('nav-bar').classList.remove('collapsed');
        }

        // Navigation
        document.getElementById('btn-animation').addEventListener('click', () => switchMode('animation'));
        document.getElementById('btn-construction').addEventListener('click', () => switchMode('construction'));
        document.getElementById('btn-timeline').addEventListener('click', toggleTimeline);
        document.getElementById('btn-debug').addEventListener('click', toggleDebug);
        document.getElementById('btn-docs').addEventListener('click', showDocs);

        // Timeline controls
        document.getElementById('btn-play').addEventListener('click', playAnimation);
        document.getElementById('btn-pause').addEventListener('click', pauseAnimation);
        document.getElementById('btn-stop').addEventListener('click', stopAnimation);
        document.getElementById('btn-add-keyframe').addEventListener('click', addKeyframe);
        document.getElementById('btn-snapshot').addEventListener('click', takeSnapshot);
        document.getElementById('playback-speed').addEventListener('input', updatePlaybackSpeed);

        // Reference image
        document.getElementById('reference-upload').addEventListener('change', handleReferenceUpload);
        document.getElementById('show-reference').addEventListener('change', toggleReferenceImage);
        document.getElementById('reference-opacity').addEventListener('input', updateReferenceOpacity);

        // NEXUS Lab button (handled by inline onclick="toggleNexusLab()")
        // Event listener removed to prevent conflict with inline handler

        // Modal controls
        document.getElementById('btn-close-docs').addEventListener('click', () => {
            document.getElementById('docs-modal').classList.remove('active');
        });

        // Construction tools
        document.getElementById('btn-exit-construction').addEventListener('click', () => switchMode('animation'));
        document.getElementById('tool-select').addEventListener('click', () => setTransformMode('select'));
        document.getElementById('tool-move').addEventListener('click', () => setTransformMode('translate'));
        document.getElementById('tool-rotate').addEventListener('click', () => setTransformMode('rotate'));
        document.getElementById('tool-scale').addEventListener('click', () => setTransformMode('scale'));
        document.getElementById('tool-cube').addEventListener('click', () => addShape('cube'));
        document.getElementById('tool-sphere').addEventListener('click', () => addShape('sphere'));
        document.getElementById('tool-cylinder').addEventListener('click', () => addShape('cylinder'));
        document.getElementById('tool-plane').addEventListener('click', () => addShape('plane'));
        document.getElementById('tool-delete').addEventListener('click', deleteSelectedObject);

        // Keyboard shortcuts
        window.addEventListener('keydown', handleKeyboard);

        // Export/Import
        document.getElementById('btn-export-json').addEventListener('click', exportScene);
        document.getElementById('btn-import-json').addEventListener('click', () => {
            document.getElementById('import-json-input').click();
        });
        document.getElementById('import-json-input').addEventListener('change', importScene);

        // Property controls
        document.getElementById('prop-x').addEventListener('input', updateSelectedObjectProperty);
        document.getElementById('prop-y').addEventListener('input', updateSelectedObjectProperty);
        document.getElementById('prop-z').addEventListener('input', updateSelectedObjectProperty);
        document.getElementById('prop-rotation').addEventListener('input', updateSelectedObjectProperty);
        document.getElementById('prop-scale').addEventListener('input', updateSelectedObjectProperty);
        document.getElementById('prop-color').addEventListener('input', updateObjectColor);

        // Quick action buttons
        document.getElementById('btn-duplicate').addEventListener('click', duplicateSelectedObject);
        document.getElementById('btn-toggle-snap').addEventListener('click', toggleSnapToGrid);
    }

    // ============================================
    // MODE SWITCHING
    // ============================================
    function switchMode(mode) {
        AppState.currentMode = mode;

        // Update button states
        document.querySelectorAll('#nav-bar button').forEach(btn => btn.classList.remove('active'));

        // Hide all modes
        document.getElementById('construction-room').classList.remove('active');

        switch(mode) {
            case 'animation':
                document.getElementById('btn-animation').classList.add('active');
                document.getElementById('canvas-container').style.display = 'block';
                break;
            case 'construction':
                document.getElementById('btn-construction').classList.add('active');
                document.getElementById('construction-room').classList.add('active');
                // Keep canvas visible in construction mode too!
                document.getElementById('canvas-container').style.display = 'block';
                break;
        }

        showToast(`Switched to ${mode} mode`, 'success');
    }

    // ============================================
    // TRANSFORM CONTROLS
    // ============================================
    function setTransformMode(mode) {
        AppState.currentTool = mode;

        // Update button states
        document.querySelectorAll('.construction-toolbar .tool-btn').forEach(btn => {
            btn.style.background = 'rgba(255,255,255,.1)';
        });

        if (mode === 'select') {
            AppState.transformControls.detach();
            document.getElementById('tool-select').style.background = 'rgba(102, 126, 234, 0.5)';
            showToast('Select mode - Click objects to select', 'success');
        } else if (AppState.selectedObject) {
            if (mode === 'translate') {
                AppState.transformControls.setMode('translate');
                document.getElementById('tool-move').style.background = 'rgba(102, 126, 234, 0.5)';
                showToast('Move mode - Drag arrows to move object', 'success');
            } else if (mode === 'rotate') {
                AppState.transformControls.setMode('rotate');
                document.getElementById('tool-rotate').style.background = 'rgba(102, 126, 234, 0.5)';
                showToast('Rotate mode - Drag circles to rotate object', 'success');
            } else if (mode === 'scale') {
                AppState.transformControls.setMode('scale');
                document.getElementById('tool-scale').style.background = 'rgba(102, 126, 234, 0.5)';
                showToast('Scale mode - Drag handles to scale object', 'success');
            }
        } else {
            showToast('Select an object first!', 'error');
        }
    }

    function deleteSelectedObject() {
        if (!AppState.selectedObject) {
            showToast('No object selected to delete', 'error');
            return;
        }

        saveState('Delete object');

        // Remove from scene
        AppState.scene.remove(AppState.selectedObject.mesh);

        // Dispose geometry and material
        AppState.selectedObject.mesh.geometry.dispose();
        AppState.selectedObject.mesh.material.dispose();

        // Remove from objects array
        const index = AppState.objects.indexOf(AppState.selectedObject);
        if (index > -1) {
            AppState.objects.splice(index, 1);
        }

        // Detach transform controls
        AppState.transformControls.detach();

        showToast('Object deleted', 'success');
        AppState.selectedObject = null;

        updateEnvironmentStats();
    }

    function duplicateSelectedObject() {
        if (!AppState.selectedObject) {
            showToast('No object selected to duplicate', 'error');
            return;
        }

        const original = AppState.selectedObject;

        // Create new geometry and material (clone them)
        const geometry = original.mesh.geometry.clone();
        const material = original.mesh.material.clone();
        const mesh = new THREE.Mesh(geometry, material);

        // Copy transform properties with slight offset
        mesh.position.copy(original.mesh.position);
        mesh.position.x += 2; // Offset to the right
        mesh.rotation.copy(original.mesh.rotation);
        mesh.scale.copy(original.mesh.scale);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // Add to scene
        AppState.scene.add(mesh);

        // Add to objects array
        const newObj = {
            mesh: mesh,
            type: original.type,
            keyframes: [],
            properties: {
                position: mesh.position.clone(),
                rotation: mesh.rotation.clone(),
                scale: mesh.scale.clone()
            }
        };
        AppState.objects.push(newObj);

        // Select the new object
        if (AppState.selectedObject) {
            AppState.selectedObject.mesh.material.emissive.setHex(0x000000);
        }
        AppState.selectedObject = newObj;
        newObj.mesh.material.emissive.setHex(0x444444);
        AppState.transformControls.attach(newObj.mesh);
        updatePropertyPanel();

        updateEnvironmentStats();
        saveState('Duplicate object');
        showToast(`Duplicated ${original.type}! (Shift+D)`, 'success');
    }

    function toggleSnapToGrid() {
        AppState.snapToGrid = !AppState.snapToGrid;

        if (AppState.transformControls) {
            AppState.transformControls.setTranslationSnap(AppState.snapToGrid ? 1 : null);
            AppState.transformControls.setRotationSnap(AppState.snapToGrid ? THREE.MathUtils.degToRad(15) : null);
            AppState.transformControls.setScaleSnap(AppState.snapToGrid ? 0.25 : null);
        }

        const status = AppState.snapToGrid ? 'enabled' : 'disabled';
        showToast(`Snap to grid ${status} (X to toggle)`, 'success');
    }

    function handleKeyboard(event) {
        // Ignore if typing in input fields
        if (event.target.tagName === 'INPUT') return;

        switch(event.key.toLowerCase()) {
            case 'g':
                setTransformMode('translate');
                break;
            case 'r':
                setTransformMode('rotate');
                break;
            case 's':
                setTransformMode('scale');
                break;
            case 'delete':
            case 'backspace':
                event.preventDefault();
                deleteSelectedObject();
                break;
            case 'escape': {
                // Check if NEXUS Lab is open
                const nexusOverlay = document.getElementById('nexus-lab-overlay');
                if (nexusOverlay && nexusOverlay.classList.contains('active')) {
                    toggleNexusLab();
                } else if (AppState.selectedObject) {
                    AppState.selectedObject.mesh.material.emissive.setHex(0x000000);
                    AppState.transformControls.detach();
                    AppState.selectedObject = null;
                    showToast('Deselected', 'success');
                }
                break;
            }
            case 'd':
                if (event.shiftKey && AppState.selectedObject) {
                    event.preventDefault();
                    duplicateSelectedObject();
                }
                break;
            case 'x':
                event.preventDefault();
                toggleSnapToGrid();
                break;
            case 'z':
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    if (event.shiftKey) {
                        redo(); // Ctrl+Shift+Z = Redo
                    } else {
                        undo(); // Ctrl+Z = Undo
                    }
                }
                break;
            case 'y':
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    redo(); // Ctrl+Y = Redo
                }
                break;
            case 'b':
                event.preventDefault();
                toggleGlyphicShader(); // B = Background shader
                break;
        }
    }

    // ============================================
    // TIMELINE FUNCTIONS
    // ============================================
    function toggleTimeline() {
        const panel = document.getElementById('timeline-panel');
        panel.classList.toggle('active');
        if (panel.classList.contains('active')) {
            document.getElementById('environment-stats').style.bottom = '220px';
            initializeTimeline();
            showToast('Timeline opened', 'success');
        } else {
            document.getElementById('environment-stats').style.bottom = '20px';
            showToast('Timeline closed', 'success');
        }
    }

    // Timeline scrubbing state
    let isScrubbingTimeline = false;

    function initializeTimeline() {
        const track = document.getElementById('timeline-track');
        const playhead = document.getElementById('playhead');

        // Add time markers every second
        track.querySelectorAll('.timeline-time-marker').forEach(el => el.remove());
        const duration = AppState.animationState.duration;
        for (let t = 0; t <= duration; t++) {
            const marker = document.createElement('div');
            marker.className = 'timeline-time-marker';
            marker.style.left = `${(t / duration) * 100}%`;
            marker.textContent = `${t}s`;
            track.appendChild(marker);
        }

        // Click to scrub
        track.addEventListener('click', handleTimelineClick);

        // Drag to scrub
        track.addEventListener('mousedown', startTimelineScrub);
        document.addEventListener('mousemove', handleTimelineScrub);
        document.addEventListener('mouseup', stopTimelineScrub);
    }

    function handleTimelineClick(e) {
        if (e.target.classList.contains('keyframe')) return;
        const track = document.getElementById('timeline-track');
        const rect = track.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const percentage = clickX / rect.width;
        const newTime = percentage * AppState.animationState.duration;

        AppState.animationState.currentTime = Math.max(0, Math.min(newTime, AppState.animationState.duration));
        updatePlayhead();
        showToast(`Jumped to ${AppState.animationState.currentTime.toFixed(2)}s`, 'success');
    }

    function startTimelineScrub(e) {
        if (e.target.classList.contains('keyframe')) return;
        isScrubbingTimeline = true;
        AppState.animationState.isPlaying = false;
        handleTimelineScrub(e);
    }

    function handleTimelineScrub(e) {
        if (!isScrubbingTimeline) return;

        const track = document.getElementById('timeline-track');
        const rect = track.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const percentage = Math.max(0, Math.min(1, mouseX / rect.width));
        const newTime = percentage * AppState.animationState.duration;

        AppState.animationState.currentTime = newTime;
        updatePlayhead();
    }

    function stopTimelineScrub() {
        isScrubbingTimeline = false;
    }

    function updatePlayhead() {
        const playhead = document.getElementById('playhead');
        if (!playhead) return;

        const percentage = (AppState.animationState.currentTime / AppState.animationState.duration) * 100;
        playhead.style.left = `${Math.max(0, Math.min(100, percentage))}%`;

        // Update time display if it exists
        const timeDisplay = document.getElementById('current-time-display');
        if (timeDisplay) {
            timeDisplay.textContent = `${AppState.animationState.currentTime.toFixed(2)}s / ${AppState.animationState.duration}s`;
        }
    }

    function playAnimation() {
        AppState.animationState.isPlaying = true;
        showToast('Animation playing', 'success');
    }

    function pauseAnimation() {
        AppState.animationState.isPlaying = false;
        showToast('Animation paused', 'success');
    }

    function stopAnimation() {
        AppState.animationState.isPlaying = false;
        AppState.animationState.currentTime = 0;
        showToast('Animation stopped', 'success');
    }

    function addKeyframe() {
        if (!AppState.selectedObject) {
            showToast('Please select an object first', 'error');
            return;
        }

        const keyframe = {
            time: AppState.animationState.currentTime,
            position: AppState.selectedObject.mesh.position.clone(),
            rotation: AppState.selectedObject.mesh.rotation.clone(),
            scale: AppState.selectedObject.mesh.scale.clone()
        };

        AppState.selectedObject.keyframes.push(keyframe);
        AppState.animationState.keyframes.push(keyframe);

        // Visual representation
        const keyframeEl = document.createElement('div');
        keyframeEl.className = 'keyframe';
        keyframeEl.style.left = `${(keyframe.time / AppState.animationState.duration) * 100}%`;
        document.getElementById('timeline-track').appendChild(keyframeEl);

        saveState('Add keyframe');
        showToast('Keyframe added', 'success');
    }

    function takeSnapshot() {
        // Create a snapshot of the current scene state
        const snapshot = {
            timestamp: Date.now(),
            objects: AppState.objects.map(obj => ({
                type: obj.type,
                position: obj.mesh.position.clone(),
                rotation: obj.mesh.rotation.clone(),
                scale: obj.mesh.scale.clone()
            }))
        };

        console.log('Snapshot taken:', snapshot);
        showToast('Snapshot captured! 📸', 'success');
    }

    function updatePlaybackSpeed(e) {
        AppState.animationState.playbackSpeed = parseFloat(e.target.value);
        document.getElementById('speed-display').textContent = `${AppState.animationState.playbackSpeed}x`;
    }

    // ============================================
    // REFERENCE IMAGE FUNCTIONS
    // ============================================
    function handleReferenceUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const img = document.getElementById('reference-image');
            img.src = event.target.result;
            AppState.referenceImage = event.target.result;
            document.getElementById('show-reference').checked = true;
            toggleReferenceImage({ target: { checked: true } });
            showToast('Reference image loaded', 'success');
        };
        reader.readAsDataURL(file);
    }

    function toggleReferenceImage(e) {
        AppState.showReference = e.target.checked;
        const container = document.getElementById('reference-image-container');
        if (AppState.showReference) {
            container.classList.add('active');
        } else {
            container.classList.remove('active');
        }
    }

    function updateReferenceOpacity(e) {
        AppState.referenceImageOpacity = parseFloat(e.target.value);
        document.getElementById('reference-image-container').style.opacity = AppState.referenceImageOpacity;
    }

    // ============================================
    // OBJECT COLOR CONTROL
    // ============================================
    function updateObjectColor(e) {
        if (!AppState.selectedObject) return;

        const color = e.target.value;
        AppState.selectedObject.mesh.material.color.setStyle(color);
        showToast('Color updated', 'success');
    }

    // ============================================
    // SHAPE CREATION
    // ============================================
    function addShape(type) {
        let geometry, material, mesh;

        switch(type) {
            case 'cube':
                geometry = new THREE.BoxGeometry(2, 2, 2);
                break;
            case 'sphere':
                geometry = new THREE.SphereGeometry(1, 32, 32);
                break;
            case 'cylinder':
                geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
                break;
            case 'plane':
                geometry = new THREE.PlaneGeometry(5, 5);
                break;
            default:
                return;
        }

        material = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff,
            roughness: 0.5,
            metalness: 0.5
        });

        mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(
            Math.random() * 10 - 5,
            1,
            Math.random() * 10 - 5
        );
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        AppState.scene.add(mesh);
        AppState.objects.push({
            mesh: mesh,
            type: type,
            keyframes: [],
            properties: {
                position: mesh.position.clone(),
                rotation: mesh.rotation.clone(),
                scale: mesh.scale.clone()
            }
        });

        updateEnvironmentStats();
        saveState(`Add ${type}`);
        showToast(`${type.charAt(0).toUpperCase() + type.slice(1)} added`, 'success');
    }

    // ============================================
    // ENVIRONMENT STATS & LEVELING
    // ============================================
    function initEnvironmentStats() {
        document.getElementById('environment-stats').classList.add('active');
        updateEnvironmentStats();
    }

    function updateEnvironmentStats() {
        const stats = AppState.environmentStats;

        // Calculate strain based on object count and complexity
        stats.objectCount = AppState.objects.length;
        stats.vertexCount = AppState.objects.reduce((total, obj) => {
            return total + (obj.mesh.geometry.attributes.position?.count || 0);
        }, 0);

        // Strain calculation
        const objectStrain = stats.objectCount * 5;
        const vertexStrain = stats.vertexCount * 0.01;
        const fpsStrain = (60 - stats.fps) * 0.5;

        stats.strain = Math.min(stats.maxStrain, objectStrain + vertexStrain + fpsStrain);

        // Update UI
        document.getElementById('strain-fill').style.width = `${(stats.strain / stats.maxStrain) * 100}%`;
        document.getElementById('current-level').textContent = stats.level;

        // Check for level up
        const levelThreshold = stats.level * 30;
        if (stats.strain >= levelThreshold && !stats.levelHistory.includes(stats.level + 1)) {
            levelUp();
        }

        const levelProgress = ((stats.strain % 30) / 30) * 100;
        document.getElementById('level-fill').style.width = `${levelProgress}%`;
    }

    function levelUp() {
        AppState.environmentStats.level++;
        AppState.environmentStats.levelHistory.push(AppState.environmentStats.level);

        // Show level up notification
        const notification = document.getElementById('level-up-notification');
        const text = document.getElementById('level-up-text');
        text.textContent = `You've reached Level ${AppState.environmentStats.level}!`;

        notification.classList.add('active');

        // Play sound effect (simulated)
        playLevelUpEffect();

        setTimeout(() => {
            notification.classList.remove('active');
        }, 3000);

        showToast(`🎉 Level ${AppState.environmentStats.level} Unlocked!`, 'success');
    }

    function playLevelUpEffect() {
        // Simulate audio with Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = 880;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
    }

    // ============================================
    // DEBUG FUNCTIONS
    // ============================================
    function toggleDebug() {
        document.getElementById('debug-overlay').classList.toggle('active');
        document.getElementById('side-panel').classList.toggle('active');
    }

    function updateDebugInfo() {
        const info = AppState.renderer.info;

        document.getElementById('debug-fps').textContent = Math.round(AppState.environmentStats.fps);
        document.getElementById('debug-objects').textContent = AppState.objects.length;
        document.getElementById('debug-vertices').textContent = AppState.environmentStats.vertexCount;
        document.getElementById('debug-drawcalls').textContent = info.render.calls;

        if (performance.memory) {
            const memoryMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
            document.getElementById('debug-memory').textContent = `${memoryMB} MB`;
        }
    }

    // ============================================
    // VECTORLABS TRANSITION
    // ============================================
    function activateVectorLabs() {
        const btn = document.getElementById('vectorlabs-btn');
        btn.classList.add('charging');

        // Create energy particles
        createEnergyParticles();

        setTimeout(() => {
            btn.classList.remove('charging');
            createTunnelTransition();
        }, 2000);
    }

    function createEnergyParticles() {
        const particleCount = 50;
        const particles = [];

        for (let i = 0; i < particleCount; i++) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0x667eea,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(geometry, material);

            const angle = (i / particleCount) * Math.PI * 2;
            const radius = 5 + Math.random() * 5;
            particle.position.set(
                Math.cos(angle) * radius,
                Math.random() * 10 - 5,
                Math.sin(angle) * radius
            );

            AppState.scene.add(particle);
            particles.push({ mesh: particle, velocity: new THREE.Vector3() });
        }

        // Animate particles toward camera
        const animateParticles = () => {
            let allGone = true;
            particles.forEach(p => {
                const dir = AppState.camera.position.clone().sub(p.mesh.position).normalize();
                p.velocity.add(dir.multiplyScalar(0.5));
                p.mesh.position.add(p.velocity);

                if (p.mesh.position.distanceTo(AppState.camera.position) > 1) {
                    allGone = false;
                } else {
                    AppState.scene.remove(p.mesh);
                }
            });

            if (!allGone) {
                requestAnimationFrame(animateParticles);
            }
        };

        animateParticles();
        showToast('VectorLabs activated! ⚡', 'success');
    }

    function createTunnelTransition() {
        // Create a wormhole/tunnel effect
        showToast('Entering Green Screen Room... 🌀', 'success');

        // Fade to black
        const fadeEl = document.createElement('div');
        fadeEl.style.cssText = `
            position: fixed;
            inset: 0;
            background: black;
            z-index: 9998;
            opacity: 0;
            transition: opacity 1s;
            pointer-events: none;
        `;
        document.body.appendChild(fadeEl);

        setTimeout(() => {
            fadeEl.style.opacity = '1';
        }, 100);

        setTimeout(() => {
            // Show green screen room message
            showToast('Green Screen Room (Under Construction) 🎬', 'success');
            fadeEl.style.opacity = '0';
            setTimeout(() => fadeEl.remove(), 1000);
        }, 2000);
    }

    // ============================================
    // EXPORT/IMPORT
    // ============================================
    function exportScene() {
        const sceneData = {
            version: '1.0',
            timestamp: new Date().toISOString(),
            objects: AppState.objects.map(obj => ({
                type: obj.type,
                position: { x: obj.mesh.position.x, y: obj.mesh.position.y, z: obj.mesh.position.z },
                rotation: { x: obj.mesh.rotation.x, y: obj.mesh.rotation.y, z: obj.mesh.rotation.z },
                scale: { x: obj.mesh.scale.x, y: obj.mesh.scale.y, z: obj.mesh.scale.z },
                color: '#' + obj.mesh.material.color.getHexString(),
                keyframes: obj.keyframes
            })),
            environmentStats: AppState.environmentStats
        };

        const dataStr = JSON.stringify(sceneData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `gamelite-scene-${Date.now()}.json`;
        link.click();

        URL.revokeObjectURL(url);
        showToast('Scene exported successfully! 💾', 'success');
    }

    function importScene(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const sceneData = JSON.parse(event.target.result);

                // Clear current scene
                AppState.objects.forEach(obj => {
                    AppState.scene.remove(obj.mesh);
                });
                AppState.objects = [];

                // Load objects
                sceneData.objects.forEach(objData => {
                    addShape(objData.type);
                    const obj = AppState.objects[AppState.objects.length - 1];
                    obj.mesh.position.set(objData.position.x, objData.position.y, objData.position.z);
                    obj.mesh.rotation.set(objData.rotation.x, objData.rotation.y, objData.rotation.z);
                    obj.mesh.scale.set(objData.scale.x, objData.scale.y, objData.scale.z);
                    obj.mesh.material.color.setHex(parseInt(objData.color.replace('#', '0x')));
                    obj.keyframes = objData.keyframes || [];
                });

                showToast('Scene imported successfully! 📂', 'success');
            } catch (error) {
                showToast('Error importing scene: ' + error.message, 'error');
            }
        };
        reader.readAsText(file);
    }

    // ============================================
    // PROPERTY UPDATES
    // ============================================
    function updateSelectedObjectProperty(e) {
        if (!AppState.selectedObject) return;

        const obj = AppState.selectedObject.mesh;
        const propX = parseFloat(document.getElementById('prop-x').value);
        const propY = parseFloat(document.getElementById('prop-y').value);
        const propZ = parseFloat(document.getElementById('prop-z').value);
        const rotation = parseFloat(document.getElementById('prop-rotation').value) * Math.PI / 180;
        const scale = parseFloat(document.getElementById('prop-scale').value);

        obj.position.set(propX, propY, propZ);
        obj.rotation.y = rotation;
        obj.scale.setScalar(scale);
    }

    // ============================================
    // DOCUMENTATION
    // ============================================
    function showDocs() {
        document.getElementById('docs-modal').classList.add('active');
    }

    // Expose to global scope for inline onclick handler
    window.showDocs = showDocs;

    // ============================================
    // NEXUS LAB TOGGLE
    // ============================================
    function toggleNexusLab() {
        const overlay = document.getElementById('nexus-lab-overlay');
        const iframe = document.getElementById('nexus-lab-iframe');

        if (!overlay.classList.contains('active')) {
            // Open NEXUS Lab
            overlay.classList.add('active');

            // Load the NEXUS Dashboard if not already loaded
            if (!iframe.src) {
                iframe.src = 'nexus-LAB-CORRECT.html';
            }

            // Pause 3D scene animation (optional - save performance)
            AppState.animationState.isPlaying = false;

            showToast('🚀 NEXUS Lab Activated', 'success');
        } else {
            // Close NEXUS Lab
            overlay.classList.remove('active');
            showToast('← Returned to 3D Scene', 'success');
        }
    }

    // Expose to global scope for inline onclick handler
    window.toggleNexusLab = toggleNexusLab;

    // ============================================
    // GAMELITE BRIDGE API - NEXUS LAB INTEGRATION
    // ============================================
    // This API allows NEXUS Lab to control the main GameLite scene
    const GameLiteBridge = {
        // Create objects in the scene from NEXUS Lab
        spawnObject(type, options = {}) {
            let geometry, material, mesh;

            const {
                x = Math.random() * 10 - 5,
                y = 2,
                z = Math.random() * 10 - 5,
                color = Math.random() * 0xffffff,
                scale = 1,
                name = `${type}_${Date.now()}`
            } = options;

            switch(type.toLowerCase()) {
                case 'cube':
                case 'box':
                    geometry = new THREE.BoxGeometry(2 * scale, 2 * scale, 2 * scale);
                    break;
                case 'sphere':
                case 'ball':
                    geometry = new THREE.SphereGeometry(1 * scale, 32, 32);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(1 * scale, 1 * scale, 2 * scale, 32);
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(1 * scale, 2 * scale, 32);
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(1 * scale, 0.4 * scale, 16, 100);
                    break;
                case 'plane':
                    geometry = new THREE.PlaneGeometry(5 * scale, 5 * scale);
                    break;
                default:
                    console.warn(`Unknown object type: ${type}`);
                    return null;
            }

            material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5,
                metalness: 0.5
            });

            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.name = name;

            AppState.scene.add(mesh);
            const obj = {
                mesh: mesh,
                type: type,
                keyframes: [],
                properties: {
                    position: mesh.position.clone(),
                    rotation: mesh.rotation.clone(),
                    scale: mesh.scale.clone()
                }
            };
            AppState.objects.push(obj);

            updateEnvironmentStats();
            showToast(`✨ ${name} spawned from NEXUS Lab`, 'success');

            return obj;
        },

        // Play audio in the main scene
        playAudio(frequency, duration = 1000, waveType = 'sine') {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = waveType;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration / 1000);

            showToast(`🎵 Playing ${frequency}Hz ${waveType}`, 'success');
            return { oscillator, gainNode, audioContext };
        },

        // Get scene information
        getSceneInfo() {
            return {
                objectCount: AppState.objects.length,
                objects: AppState.objects.map(obj => ({
                    type: obj.type,
                    name: obj.mesh.userData.name || 'unnamed',
                    position: obj.mesh.position.toArray(),
                    rotation: obj.mesh.rotation.toArray().slice(0, 3),
                    scale: obj.mesh.scale.toArray()
                })),
                camera: {
                    position: AppState.camera.position.toArray(),
                    rotation: AppState.camera.rotation.toArray().slice(0, 3)
                },
                animation: {
                    isPlaying: AppState.animationState.isPlaying,
                    currentTime: AppState.animationState.currentTime,
                    duration: AppState.animationState.duration
                }
            };
        },

        // Animate objects
        animateObject(objectIndex, property, value, duration = 1000) {
            if (objectIndex < 0 || objectIndex >= AppState.objects.length) {
                console.warn('Invalid object index');
                return;
            }

            const obj = AppState.objects[objectIndex];
            const mesh = obj.mesh;
            const start = performance.now();
            const startValue = { ...mesh[property] };

            function animate() {
                const elapsed = performance.now() - start;
                const progress = Math.min(elapsed / duration, 1);

                if (property === 'position' || property === 'scale') {
                    mesh[property].x = startValue.x + (value.x - startValue.x) * progress;
                    mesh[property].y = startValue.y + (value.y - startValue.y) * progress;
                    mesh[property].z = startValue.z + (value.z - startValue.z) * progress;
                } else if (property === 'rotation') {
                    mesh[property].x = startValue.x + (value.x - startValue.x) * progress;
                    mesh[property].y = startValue.y + (value.y - startValue.y) * progress;
                    mesh[property].z = startValue.z + (value.z - startValue.z) * progress;
                }

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
            showToast(`🎬 Animating object ${objectIndex}`, 'success');
        },

        // Clear all objects
        clearScene() {
            AppState.objects.forEach(obj => {
                AppState.scene.remove(obj.mesh);
                obj.mesh.geometry.dispose();
                obj.mesh.material.dispose();
            });
            AppState.objects = [];
            updateEnvironmentStats();
            showToast('🧹 Scene cleared from NEXUS Lab', 'success');
        },

        // Control camera
        setCameraPosition(x, y, z) {
            AppState.camera.position.set(x, y, z);
            showToast(`📷 Camera moved to (${x}, ${y}, ${z})`, 'success');
        },

        // Execute custom code
        executeCode(code) {
            try {
                // Provide a safe context with access to GameLite functions
                const result = new Function('THREE', 'scene', 'camera', 'objects', 'bridge', code)(
                    THREE,
                    AppState.scene,
                    AppState.camera,
                    AppState.objects,
                    GameLiteBridge
                );
                showToast('✅ Code executed successfully', 'success');
                return result;
            } catch (error) {
                showToast(`❌ Error: ${error.message}`, 'error');
                console.error('Code execution error:', error);
                return null;
            }
        },

        // Gallery operations
        async addToGallery(name, glbBlob, metadata = {}) {
            try {
                const base64 = await GLBGallery.blobToBase64(glbBlob);
                return GLBGallery.addModel(name, base64, metadata);
            } catch (error) {
                showToast(`❌ Failed to add to gallery: ${error.message}`, 'error');
                return null;
            }
        },

        getGalleryModels() {
            return GLBGallery.models.map(m => ({
                id: m.id,
                name: m.name,
                metadata: m.metadata
            }));
        },

        spawnFromGallery(id) {
            return GLBGallery.spawnToScene(id);
        }
    };

    // Expose GameLiteBridge to global scope and to iframe
    window.GameLiteBridge = GameLiteBridge;

    // Listen for messages from NEXUS Lab iframe
    window.addEventListener('message', (event) => {
        // Security: Check origin if deployed
        // if (event.origin !== window.location.origin) return;

        const { type, payload } = event.data;

        if (!type) return;

        switch(type) {
            case 'spawn':
                GameLiteBridge.spawnObject(payload.objectType, payload.options);
                break;
            case 'audio':
                GameLiteBridge.playAudio(payload.frequency, payload.duration, payload.waveType);
                break;
            case 'animate':
                GameLiteBridge.animateObject(payload.index, payload.property, payload.value, payload.duration);
                break;
            case 'execute':
                GameLiteBridge.executeCode(payload.code);
                break;
            case 'clear':
                GameLiteBridge.clearScene();
                break;
            case 'camera':
                GameLiteBridge.setCameraPosition(payload.x, payload.y, payload.z);
                break;
            case 'getInfo': {
                const info = GameLiteBridge.getSceneInfo();
                event.source.postMessage({ type: 'sceneInfo', payload: info }, event.origin);
                break;
            }
            case 'getGallery': {
                const models = GameLiteBridge.getGalleryModels();
                event.source.postMessage({ type: 'galleryModels', payload: models }, event.origin);
                break;
            }
            case 'spawnFromGallery':
                GameLiteBridge.spawnFromGallery(payload.id);
                break;
            case 'addToGallery':
                if (payload.glbData && payload.name) {
                    // Convert base64 to Blob
                    const byteString = atob(payload.glbData.split(',')[1]);
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    for (let i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    const blob = new Blob([ab], { type: 'model/gltf-binary' });
                    GameLiteBridge.addToGallery(payload.name, blob, payload.metadata || {});
                }
                break;
        }
    });

    // ============================================
    // AVATAR HUB UI HELPERS
    // ============================================
    const AvatarHubUI = {
        phase: (text) => {
            const el = document.getElementById('phase');
            if (el) el.textContent = text;
        },
        bar: (percent) => {
            const el = document.getElementById('bar');
            if (el) el.style.width = `${Math.max(0, Math.min(100, percent))}%`;
        },
        set: (id, ok, text) => {
            const el = document.getElementById(id);
            if (!el) return;
            if (text) el.textContent = text;
            el.classList.toggle('ok', !!ok);
            el.classList.toggle('off', !ok);
        },
        toast: (msg) => {
            const el = document.getElementById('op-status');
            if (el) {
                el.textContent = msg;
                el.className = 'deny';
            }
            console.warn('[Avatar Hub]', msg);
        },
        info: (msg) => {
            const el = document.getElementById('op-status');
            if (el) {
                el.textContent = msg;
                el.className = 'info';
            }
        },
        ok: (msg) => {
            const el = document.getElementById('op-status');
            if (el) {
                el.textContent = msg;
                el.className = 'okText';
            }
        }
    };

    const AvatarHubGuard = {
        requireRig(skinned) {
            if (!skinned || !skinned.skeleton) {
                AvatarHubUI.toast('Animation requires a skinned mesh with a bound armature.');
                AvatarHubUI.set('b-anim', false, 'Anim: —');
                AvatarHubUI.set('b-rig', false, 'Needs rig');
                return false;
            }
            AvatarHubUI.set('b-rig', true, 'Ready');
            return true;
        },
        requireExportGroup(group) {
            if (!group || !group.children || group.children.length === 0) {
                AvatarHubUI.toast('Nothing to export: scene group is empty.');
                AvatarHubUI.set('b-export', false, 'Export: —');
                return false;
            }
            AvatarHubUI.set('b-export', true, 'Export: armed');
            return true;
        }
    };

    // Avatar Hub button now opens the separate Avatar Pipeline (handled in setupExternalTools)

    // ============================================
    // BULK TOOLS MODAL WITH BATCH PROCESSOR
    // ============================================
    const BulkTools = {
        files: [],
        pairs: [],
        zipFile: null,

        init() {
            const modal = document.getElementById('bulkModal');
            const closeBtn = document.getElementById('bulkClose');
            const openBtn = document.getElementById('btn-bulk-tools');
            const dropZone = document.getElementById('bulkDrop');

            // Open modal
            openBtn?.addEventListener('click', async () => {
                modal.style.display = 'block';
                this.updateStatus('Drop a ZIP file containing image pairs to begin.');
                
                // Preload JSZip when modal opens
                if (!window.JSZip) {
                    this.updateStatus('Loading JSZip library...');
                    try {
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
                        await new Promise((resolve, reject) => {
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        });
                        await new Promise(resolve => setTimeout(resolve, 100));
                        console.log('[bulk] JSZip loaded successfully');
                        this.updateStatus('Ready. Drop a ZIP file or upload single PNG.');
                    } catch (error) {
                        console.error('[bulk] Failed to load JSZip:', error);
                        this.updateStatus('Warning: JSZip failed to load. ZIP features may not work.');
                    }
                } else {
                    this.updateStatus('Ready. Drop a ZIP file or upload single PNG.');
                }
            });

            // Close modal
            closeBtn?.addEventListener('click', () => {
                modal.style.display = 'none';
            });

            // Close on backdrop click
            modal?.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });

            // Drag and drop
            dropZone?.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone?.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });

            dropZone?.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                const zipFile = files.find(f => f.name.endsWith('.zip'));
                if (zipFile) {
                    this.loadZip(zipFile);
                } else {
                    this.updateStatus('Please drop a .zip file');
                }
            });

            // Click to upload ZIP
            dropZone?.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.zip';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) this.loadZip(file);
                };
                input.click();
            });

            // Upload ZIP button
            document.getElementById('bulkUploadZip')?.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.zip';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) this.loadZip(file);
                };
                input.click();
            });

            // Upload Single PNG button
            document.getElementById('bulkUploadSingle')?.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/png,image/jpeg,image/jpg,image/webp';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) this.loadSingleImage(file);
                };
                input.click();
            });

            // Slider updates
            this.initSliders();

            // Action buttons
            document.getElementById('bulkRunBoth')?.addEventListener('click', () => {
                this.runBatchBoth();
            });

            document.getElementById('bulkRunGLB')?.addEventListener('click', () => {
                this.runBatchGLB();
            });

            document.getElementById('bulkRunMasks')?.addEventListener('click', () => {
                this.runBatchMasks();
            });
        },

        initSliders() {
            const sliders = {
                'bulkThr': 'bulkThrV',
                'bulkKern': 'bulkKernV',
                'bulkRes': 'bulkResV',
                'bulkIso': 'bulkIsoV',
                'bulkH': 'bulkHV',
                'bulkSubs': 'bulkSubsV'
            };

            Object.entries(sliders).forEach(([sliderId, displayId]) => {
                const slider = document.getElementById(sliderId);
                const display = document.getElementById(displayId);
                slider?.addEventListener('input', (e) => {
                    if (display) display.textContent = e.target.value;
                });
            });
        },

        async loadZip(file) {
            this.updateStatus(`Loading ${file.name}...`);
            this.zipFile = file;

            try {
                // Load JSZip dynamically
                if (!window.JSZip) {
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
                    await new Promise((resolve, reject) => {
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                    // Wait for JSZip to initialize
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                if (!window.JSZip) {
                    throw new Error('JSZip library failed to load');
                }

                const JSZip = window.JSZip;
                const zip = new JSZip();
                const contents = await zip.loadAsync(file);

                // Extract image files
                const imageFiles = [];
                for (const [path, zipEntry] of Object.entries(contents.files)) {
                    if (zipEntry.dir) continue;
                    if (!/\.(png|jpg|jpeg|gif|webp)$/i.test(path)) continue;

                    const arrayBuffer = await zipEntry.async('arraybuffer');
                    imageFiles.push({
                        name: path.split('/').pop(),
                        data: arrayBuffer
                    });
                }

                // Pair images
                this.pairs = this.pairImages(imageFiles);
                this.files = imageFiles;

                // Display results
                const list = document.getElementById('bulkList');
                if (list) {
                    list.innerHTML = `
                        <div style="color: var(--mana);">✅ Found ${this.pairs.length} pairs (${imageFiles.length} images total)</div>
                        <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">
                            ${this.pairs.map(p => `${p.stem}`).join(', ')}
                        </div>
                    `;
                }

                this.updateStatus(`Ready: ${this.pairs.length} pairs detected. Select preset and click a batch button.`);
            } catch (error) {
                console.error('Error loading ZIP:', error);
                this.updateStatus(`Error loading ZIP: ${error.message}`);
            }
        },

        async loadSingleImage(file) {
            this.updateStatus(`Loading ${file.name}...`);
            
            try {
                // Read image file
                const arrayBuffer = await file.arrayBuffer();
                const stem = file.name.replace(/\.(png|jpg|jpeg|webp)$/i, '');
                
                // Create a "pair" with the same image as both front and side
                this.files = [{ name: file.name, data: arrayBuffer }];
                this.pairs = [{
                    front: { name: file.name, data: arrayBuffer },
                    side: { name: file.name, data: arrayBuffer },
                    stem: stem
                }];
                
                // Display result
                const list = document.getElementById('bulkList');
                if (list) {
                    list.innerHTML = `
                        <div style="color: var(--mana);">✅ Single image loaded: ${file.name}</div>
                        <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">
                            Name: ${stem}<br>
                            Size: ${(file.size / 1024).toFixed(1)} KB<br>
                            Mode: Single front view (will use same image for depth calculation)
                        </div>
                    `;
                }
                
                this.updateStatus(`Ready: 1 image loaded. Select preset and click a batch button to generate GLB.`);
                console.log('[bulk] Single image loaded:', stem);
            } catch (error) {
                console.error('Error loading single image:', error);
                this.updateStatus(`Error loading image: ${error.message}`);
            }
        },

        pairImages(files) {
            const pairs = [];
            const used = new Set();

            const PAIR_HINTS = {
                front: ['front', 'f', 'fnt'],
                side: ['side', 'profile', 'lateral', 's', 'sde']
            };

            const cleanName = (name) => {
                return name.toLowerCase()
                    .replace(/\.(png|jpg|jpeg|gif|webp)$/i, '')
                    .replace(/[_\-\s]+/g, ' ')
                    .trim();
            };

            const getHint = (name) => {
                const lower = name.toLowerCase();
                if (PAIR_HINTS.front.some(h => lower.includes(h))) return 'front';
                if (PAIR_HINTS.side.some(h => lower.includes(h))) return 'side';
                return null;
            };

            const getStem = (name) => {
                let stem = cleanName(name);
                for (const hints of Object.values(PAIR_HINTS)) {
                    for (const hint of hints) {
                        stem = stem.replace(new RegExp(`\\b${hint}\\b`, 'gi'), '').trim();
                    }
                }
                return stem;
            };

            files.forEach((file, idx) => {
                if (used.has(idx)) return;

                const hint = getHint(file.name);
                if (!hint) return;

                const stem = getStem(file.name);
                const target = hint === 'front' ? 'side' : 'front';

                for (let j = 0; j < files.length; j++) {
                    if (j === idx || used.has(j)) continue;
                    const otherHint = getHint(files[j].name);
                    if (otherHint === target && getStem(files[j].name) === stem) {
                        const pair = hint === 'front'
                            ? { front: file, side: files[j], stem }
                            : { front: files[j], side: file, stem };
                        pairs.push(pair);
                        used.add(idx);
                        used.add(j);
                        break;
                    }
                }
            });

            return pairs;
        },

        getConfig() {
            const preset = document.getElementById('bulkPreset').value;
            
            const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
            
            const config = {
                autoThreshold: document.getElementById('bulkAuto').checked,
                dualThreshold: document.getElementById('bulkDual').checked,
                threshold1: clamp(parseInt(document.getElementById('bulkThr').value, 10) || 0, 0, 255),
                threshold2: clamp(parseInt(document.getElementById('bulkThr')?.value, 10) || 0, 0, 255),
                kernelClean: clamp(parseInt(document.getElementById('bulkKern').value, 10) || 0, 0, 15),
                resolution: clamp(parseInt(document.getElementById('bulkRes').value, 10) || 64, 16, 256),
                isoValue: clamp(parseFloat(document.getElementById('bulkIso').value) || 0.5, 0, 1),
                heightScale: clamp(parseFloat(document.getElementById('bulkH').value) || 1.7, 0.01, 100),
                smoothSubdivisions: clamp(parseInt(document.getElementById('bulkSubs').value, 10) || 0, 0, 10),
                flipSideX: document.getElementById('bulkFlip').checked
            };

            // Apply presets (optimized for 3D avatar generation)
            if (preset === 'baked') {
                config.autoThreshold = false;
                config.dualThreshold = true;
                config.threshold1 = 90;
                config.threshold2 = 103;
                config.resolution = 96;
                config.isoValue = 0.45;
            } else if (preset === 'auto') {
                config.autoThreshold = true;
                config.dualThreshold = false;
                config.resolution = 128;
                config.isoValue = 0.5;
            } else if (preset === 'high-quality') {
                config.autoThreshold = true;
                config.kernelClean = 3;
                config.resolution = 160;
                config.isoValue = 0.5;
                config.smoothSubdivisions = 2;
            } else if (preset === 'fast') {
                config.autoThreshold = true;
                config.resolution = 64;
                config.isoValue = 0.5;
                config.smoothSubdivisions = 0;
            } else if (config.dualThreshold && (!config.threshold2 || config.threshold2 < config.threshold1)) {
                // reasonable default band if user checks "dual" but leaves t2 empty
                config.threshold2 = Math.min(255, config.threshold1 + 12);
            }

            return config;
        },

        async runBatchBoth() {
            if (!this.pairs.length) {
                this.updateStatus('No pairs loaded. Drop a ZIP first.');
                return;
            }

            this.updateStatus('Starting batch processing (masks + meshes)...');
            const config = this.getConfig();

            try {
                const { maskFiles, glbFiles } = await this.processBatch(config, 'both');

                // Download masks
                await this.downloadZIP(maskFiles, 'masks.zip');
                await new Promise(resolve => setTimeout(resolve, 500));

                // Download GLBs
                await this.downloadZIP(glbFiles, 'meshes.zip');

                this.updateStatus(`✅ Complete! Downloaded masks.zip (${maskFiles.length}) and meshes.zip (${glbFiles.length})`);
                showToast(`Batch complete: ${this.pairs.length} models processed`, 'success');
            } catch (error) {
                console.error('Batch error:', error);
                this.updateStatus(`❌ Error: ${error.message}`);
                showToast(`Batch failed: ${error.message}`, 'error');
            }
        },

        async runBatchGLB() {
            if (!this.pairs.length) {
                this.updateStatus('No pairs loaded. Drop a ZIP first.');
                return;
            }

            this.updateStatus('Starting GLB batch export...');
            const config = this.getConfig();

            try {
                const { glbFiles } = await this.processBatch(config, 'glbs');
                await this.downloadZIP(glbFiles, 'meshes.zip');

                this.updateStatus(`✅ Complete! Downloaded meshes.zip (${glbFiles.length} models)`);
                showToast(`GLB batch complete: ${this.pairs.length} models`, 'success');
            } catch (error) {
                console.error('GLB batch error:', error);
                this.updateStatus(`❌ Error: ${error.message}`);
            }
        },

        async runBatchMasks() {
            if (!this.pairs.length) {
                this.updateStatus('No pairs loaded. Drop a ZIP first.');
                return;
            }

            this.updateStatus('Starting mask batch generation...');
            const config = this.getConfig();

            try {
                const { maskFiles } = await this.processBatch(config, 'masks');
                await this.downloadZIP(maskFiles, 'masks.zip');

                this.updateStatus(`✅ Complete! Downloaded masks.zip (${maskFiles.length} images)`);
                showToast(`Mask batch complete: ${maskFiles.length} masks`, 'success');
            } catch (error) {
                console.error('Mask batch error:', error);
                this.updateStatus(`❌ Error: ${error.message}`);
            }
        },

        async processBatch(config, mode) {
            const maskFiles = [];
            const glbFiles = [];

            // Validate THREE.js is loaded
            if (!window.THREE) {
                const error = 'THREE.js library not loaded. Cannot generate 3D meshes.';
                console.error('[bulk]', error);
                this.updateStatus(`❌ ${error}`);
                throw new Error(error);
            }

            console.log('[bulk] Starting batch:', {
                pairs: this.pairs.length,
                mode,
                config,
                hasTHREE: !!window.THREE,
                hasGLTFExporter: !!window.GLTFExporter
            });

            for (let i = 0; i < this.pairs.length; i++) {
                const pair = this.pairs[i];
                const progress = `(${i + 1}/${this.pairs.length})`;
                
                console.log(`[bulk] ${progress} Processing:`, pair.stem);
                this.updateStatus(`${progress} Loading ${pair.stem}...`);

                // Process images
                const frontImg = await this.loadImage(pair.front.data);
                const frontCanvas = this.imageToCanvas(frontImg);
                
                this.updateStatus(`${progress} ${pair.stem}: Converting to grayscale...`);
                this.canvasToGrayscale(frontCanvas);
                
                this.updateStatus(`${progress} ${pair.stem}: Applying threshold (${config.autoThreshold ? 'Otsu auto' : config.threshold1})...`);
                this.applyThreshold(frontCanvas, config);

                const sideImg = await this.loadImage(pair.side.data);
                const sideCanvas = this.imageToCanvas(sideImg);
                this.canvasToGrayscale(sideCanvas);
                this.applyThreshold(sideCanvas, config);

                // Generate masks
                if (mode === 'both' || mode === 'masks') {
                    this.updateStatus(`${progress} ${pair.stem}: Generating mask PNGs...`);
                    const frontMask = await this.canvasToPNG(frontCanvas, `${pair.stem}_front`);
                    const sideMask = await this.canvasToPNG(sideCanvas, `${pair.stem}_side`);
                    maskFiles.push(frontMask, sideMask);
                }

                // Generate mesh
                if (mode === 'both' || mode === 'glbs') {
                    let mesh;
                    
                    try {
                        this.updateStatus(`${progress} ${pair.stem}: Building 3D mesh (marching cubes res=${config.resolution})...`);
                        console.log(`[bulk] Calling heightFieldToMesh for ${pair.stem}`);
                        
                        const geometry = this.heightFieldToMesh(frontCanvas, sideCanvas, config);
                        
                        if (!geometry) {
                            throw new Error('heightFieldToMesh returned null/undefined');
                        }
                        
                        console.log(`[bulk] Geometry created:`, {
                            vertices: geometry.attributes?.position?.count || 0,
                            hasIndex: !!geometry.index
                        });
                        
                        this.updateStatus(`${progress} ${pair.stem}: Creating material...`);
                        const material = new THREE.MeshStandardMaterial({
                            color: 0x808080,
                            roughness: 0.8,
                            metalness: 0.2
                        });
                        mesh = new THREE.Mesh(geometry, material);
                        
                        console.log(`[bulk] Mesh created for ${pair.stem}`);
                    } catch (error) {
                        console.error(`[bulk] Error generating mesh for ${pair.stem}:`, error);
                        this.updateStatus(`${progress} ❌ Error: ${error.message}`);
                        throw error;
                    }

                    // Check if GLTFExporter is loaded
                    if (!window.GLTFExporter) {
                        const error = 'GLTFExporter not loaded. Please refresh the page.';
                        console.error('[bulk]', error);
                        this.updateStatus(`${progress} ❌ ${error}`);
                        throw new Error(error);
                    }

                    this.updateStatus(`${progress} ${pair.stem}: Exporting to GLB...`);
                    const glbFile = await this.exportMeshAsGLB(mesh, pair.stem);
                    glbFiles.push(glbFile);
                    
                    console.log(`[bulk] ✓ Completed ${pair.stem} (${(glbFile.blob.size / 1024).toFixed(1)} KB)`);
                }
            }

            return { maskFiles, glbFiles };
        },

        async loadImage(arrayBuffer) {
            return new Promise((resolve, reject) => {
                const blob = new Blob([arrayBuffer]);
                const url = URL.createObjectURL(blob);
                const img = new Image();
                img.onload = () => {
                    URL.revokeObjectURL(url);
                    resolve(img);
                };
                img.onerror = () => {
                    URL.revokeObjectURL(url);
                    reject(new Error('Failed to load image'));
                };
                img.src = url;
            });
        },

        imageToCanvas(img, maxSide = 640) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            let w = img.width, h = img.height;
            if (Math.max(w, h) > maxSide) {
                const scale = maxSide / Math.max(w, h);
                w *= scale;
                h *= scale;
            }
            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, w, h);
            return canvas;
        },

        canvasToGrayscale(canvas) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                const a = data[i + 3];
                const gray = a > 0 ? (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]) : 0;
                data[i] = data[i + 1] = data[i + 2] = gray;
                data[i + 3] = 255; // ensure opaque
            }
            ctx.putImageData(imgData, 0, 0);
        },

        applyThreshold(canvas, config) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;

            const t = config.autoThreshold ? this.otsuThreshold(canvas) : config.threshold1;
            const t2 = config.dualThreshold ? config.threshold2 : t;

            // band-pass: keep [t, t2), else 0
            for (let i = 0; i < data.length; i += 4) {
                const v = data[i];
                const on = config.dualThreshold ? (v >= t && v < t2) : (v >= t);
                const bin = on ? 255 : 0;
                data[i] = data[i + 1] = data[i + 2] = bin;
                data[i + 3] = 255;
            }

            ctx.putImageData(imgData, 0, 0);

            if (config.kernelClean > 0) {
                this.morphOpen(canvas, config.kernelClean);
            }
        },

        morphOpen(canvas, k = 1) {
            const eroded = this.morph(canvas, k, 'erode');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.putImageData(eroded, 0, 0);
            const dilated = this.morph(canvas, k, 'dilate');
            ctx.putImageData(dilated, 0, 0);
        },

        morph(canvas, k, mode) {
            const w = canvas.width, h = canvas.height;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const src = ctx.getImageData(0, 0, w, h);
            const dst = ctx.createImageData(w, h);
            const s = src.data, d = dst.data;
            const r = Math.max(1, k | 0);
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let val = (mode === 'erode') ? 255 : 0;
                    for (let dy = -r; dy <= r; dy++) {
                        const yy = y + dy;
                        if (yy < 0 || yy >= h) continue;
                        for (let dx = -r; dx <= r; dx++) {
                            const xx = x + dx;
                            if (xx < 0 || xx >= w) continue;
                            const p = (yy * w + xx) * 4;
                            const pv = s[p];
                            if (mode === 'erode') val = Math.min(val, pv);
                            else val = Math.max(val, pv);
                        }
                    }
                    const i = (y * w + x) * 4;
                    d[i] = d[i + 1] = d[i + 2] = val;
                    d[i + 3] = 255;
                }
            }
            return dst;
        },

        otsuThreshold(canvas) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            const hist = new Array(256).fill(0);

            for (let i = 0; i < data.length; i += 4) {
                hist[data[i]]++;
            }

            const total = canvas.width * canvas.height;
            let sum = 0;
            for (let i = 0; i < 256; i++) sum += i * hist[i];

            let sumB = 0, wB = 0, wF = 0, maxVar = 0, threshold = 0;
            for (let t = 0; t < 256; t++) {
                wB += hist[t];
                if (wB === 0) continue;
                wF = total - wB;
                if (wF === 0) break;

                sumB += t * hist[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const varBetween = wB * wF * (mB - mF) * (mB - mF);

                if (varBetween > maxVar) {
                    maxVar = varBetween;
                    threshold = t;
                }
            }

            return threshold;
        },

        readMask(canvas) {
            const { width: w, height: h } = canvas;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const img = ctx.getImageData(0, 0, w, h).data;
            const out = new Uint8Array(w * h);
            for (let i = 0, p = 0; i < out.length; i++, p += 4) {
                out[i] = img[p]; // red channel
            }
            return out;
        },

        heightFieldToMesh(frontCanvas, sideCanvas, config) {
            const res = config.resolution || 128;
            const iso = config.isoValue || 0.5;
            const height = config.heightScale || 1.7;
            const smooth = config.smoothSubdivisions || 0;
            const useVoxelMode = true; // NEW: Use direct voxel cube geometry
            
            console.log(`[bulk] Generating 3D mesh: res=${res}, iso=${iso}, height=${height}m, smooth=${smooth}, mode=${useVoxelMode ? 'VOXELS' : 'MARCHING_CUBES'}`);
            
            // Check if front and side are actually different images
            const frontMask = this.readMask(frontCanvas);
            const sideMask = this.readMask(sideCanvas);
            
            const fw = frontCanvas.width, fh = frontCanvas.height;
            const sw = sideCanvas.width, sh = sideCanvas.height;
            
            // Detect if using same image for both views (single image upload)
            let isSameImage = (fw === sw && fh === sh);
            if (isSameImage) {
                // Compare first 100 pixels to confirm
                for (let i = 0; i < Math.min(100, frontMask.length); i++) {
                    if (frontMask[i] !== sideMask[i]) {
                        isSameImage = false;
                        break;
                    }
                }
            }
            
            console.log(`[bulk] Using ${isSameImage ? 'SINGLE view (voxel extrusion)' : 'DUAL view (intersection)'} mode`);
            
            // Optionally flip side mask
            if (!isSameImage && config.flipSideX) {
                const ctx = sideCanvas.getContext('2d');
                ctx.translate(sideCanvas.width, 0);
                ctx.scale(-1, 1);
                ctx.drawImage(sideCanvas, 0, 0);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                // Re-read after flip
                const flipped = this.readMask(sideCanvas);
                sideMask.set(flipped);
            }
            
            // NEW VOXEL MODE: Create geometry from individual cubes
            if (useVoxelMode) {
                return this.createVoxelGeometry(frontMask, sideMask, fw, fh, sw, sh, isSameImage, config);
            }
            
            // OLD MARCHING CUBES MODE (fallback)
            // Create 3D voxel grid
            const gridSize = res;
            const grid = new Float32Array(gridSize * gridSize * gridSize);
            
            if (isSameImage) {
                // SINGLE IMAGE MODE: Create 3D volume by extruding silhouette with radial falloff
                console.log('[bulk] Single image mode: Creating 3D volume with radial depth');
                
                // First pass: calculate distance field from edges in 2D
                const distField = new Float32Array(fw * fh);
                for (let y = 0; y < fh; y++) {
                    for (let x = 0; x < fw; x++) {
                        const idx = y * fw + x;
                        const maskVal = frontMask[idx];
                        
                        if (maskVal > 0) {
                            // Find distance to nearest edge (empty pixel)
                            let minDist = Math.max(fw, fh);
                            const searchR = 20;
                            
                            for (let dy = -searchR; dy <= searchR; dy++) {
                                const sy = y + dy;
                                if (sy < 0 || sy >= fh) continue;
                                for (let dx = -searchR; dx <= searchR; dx++) {
                                    const sx = x + dx;
                                    if (sx < 0 || sx >= fw) continue;
                                    if (frontMask[sy * fw + sx] === 0) {
                                        const dist = Math.sqrt(dx * dx + dy * dy);
                                        minDist = Math.min(minDist, dist);
                                    }
                                }
                            }
                            
                            distField[idx] = minDist;
                        }
                    }
                }
                
                // Second pass: extrude with depth based on distance field
                for (let z = 0; z < gridSize; z++) {
                    const d = z / (gridSize - 1); // 0 to 1
                    const zCenter = Math.abs(d - 0.5) * 2; // 0 at center (z=0.5), 1 at edges
                    
                    for (let y = 0; y < gridSize; y++) {
                        const v = y / (gridSize - 1);
                        const iy = Math.min(fh - 1, Math.floor(v * (fh - 1)));
                        
                        for (let x = 0; x < gridSize; x++) {
                            const u = x / (gridSize - 1);
                            const ix = Math.min(fw - 1, Math.floor(u * (fw - 1)));
                            const idx2d = iy * fw + ix;
                            
                            const maskValue = frontMask[idx2d] / 255;
                            
                            if (maskValue > 0) {
                                // Use distance field to create depth variation
                                const distFromEdge = distField[idx2d];
                                const normalizedDist = Math.min(1, distFromEdge / 15); // Normalize to 0-1
                                
                                // Create rounded depth profile
                                const depthProfile = Math.pow(normalizedDist, 0.8); // Slightly rounded
                                const zFalloff = 1 - Math.pow(zCenter, 1.5); // Stronger falloff at edges
                                
                                grid[z * gridSize * gridSize + y * gridSize + x] = maskValue * depthProfile * zFalloff;
                            }
                        }
                    }
                }
            } else {
                // DUAL IMAGE MODE: Intersect front and side silhouettes
                for (let z = 0; z < gridSize; z++) {
                    const d = z / (gridSize - 1);
                    for (let y = 0; y < gridSize; y++) {
                        const v = y / (gridSize - 1);
                        const iy_front = Math.min(fh - 1, Math.floor(v * (fh - 1)));
                        const iy_side = Math.min(sh - 1, Math.floor(v * (sh - 1)));
                        
                        for (let x = 0; x < gridSize; x++) {
                            const u = x / (gridSize - 1);
                            
                            // Front view: X-Y projection
                            const ix_front = Math.min(fw - 1, Math.floor(u * (fw - 1)));
                            const aFront = frontMask[iy_front * fw + ix_front] / 255;
                            
                            // Side view: Z-Y projection (depth maps to side's X)
                            const ix_side = Math.min(sw - 1, Math.floor(d * (sw - 1)));
                            const aSide = sideMask[iy_side * sw + ix_side] / 255;
                            
                            // Combine as intersection (logical AND)
                            grid[z * gridSize * gridSize + y * gridSize + x] = Math.min(aFront, aSide);
                        }
                    }
                }
            }
            
            // Use THREE's proper MarchingCubes algorithm
            console.log('[bulk] Using THREE.MarchingCubes for isosurface extraction...');
            
            if (!window.MarchingCubes) {
                console.error('[bulk] MarchingCubes not loaded!');
                return new THREE.BoxGeometry(0.5, height, 0.3);
            }
            
            // Create MarchingCubes mesh (it's a mesh object, not just geometry)
            const material = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const mc = new window.MarchingCubes(gridSize, material, true, true);
            
            // Set isolation value (threshold) - MarchingCubes expects 0-255 range
            mc.isolation = iso * 255;
            
            // Initialize and reset the field
            mc.init(gridSize);
            mc.reset();
            
            // Fill the voxel field - MarchingCubes uses addBall() or direct field access
            // Copy our grid data into the MarchingCubes field
            let maxVal = 0, minVal = 999, nonZero = 0;
            for (let i = 0; i < grid.length; i++) {
                const val = grid[i] * 255; // Scale to 0-255 range
                mc.field[i] = val;
                if (val > 0) {
                    nonZero++;
                    maxVal = Math.max(maxVal, val);
                    minVal = Math.min(minVal, val);
                }
            }
            console.log(`[bulk] Field stats: ${nonZero} non-zero voxels, range [${minVal.toFixed(2)}, ${maxVal.toFixed(2)}], iso=${(iso*255).toFixed(2)}`);
            
            // Update the mesh to generate geometry from the field
            mc.update();
            
            // Extract the geometry from the MarchingCubes mesh
            const geometry = mc.geometry.clone();
            
            if (!geometry || !geometry.attributes.position || geometry.attributes.position.count === 0) {
                console.warn('[bulk] No geometry generated by MarchingCubes - using fallback box');
                return new THREE.BoxGeometry(0.5, height, 0.3);
            }
            
            console.log(`[bulk] ✓ MarchingCubes generated ${geometry.attributes.position.count.toLocaleString()} vertices`);
            geometry.computeVertexNormals();
            
            // Center and scale to target height
            geometry.center();
            const bbox = new THREE.Box3().setFromBufferAttribute(geometry.attributes.position);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim > 0) {
                const targetScale = height / maxDim;
                geometry.scale(targetScale, targetScale, targetScale);
            }
            
            // Apply Laplacian smoothing if requested
            if (smooth > 0) {
                console.log(`[bulk] Applying ${smooth} iteration(s) of Laplacian smoothing...`);
                this.laplacianSmooth(geometry, smooth);
                console.log(`[bulk] ✓ Mesh smoothed`);
            }
            
            // Compute smooth normals for better appearance
            geometry.computeVertexNormals();
            console.log(`[bulk] ✓ Computed vertex normals for smooth shading`);
            
            const finalVertexCount = geometry.attributes.position.count;
            console.log(`[bulk] ✓ Final mesh: ${finalVertexCount.toLocaleString()} vertices`);
            return geometry;
        },

        createVoxelGeometry(frontMask, sideMask, fw, fh, sw, sh, isSameImage, config) {
            console.log('[bulk] 🧊 Creating VOXEL-based geometry...');
            
            const VOXEL_SIZE = 0.05; // Smaller voxels for better detail
            const depth = isSameImage ? Math.floor(Math.max(fw, fh) * 0.6) : sw; // Deeper extrusion (60% instead of 30%)
            const maxVoxels = 100000; // Higher limit for better quality
            
            // Step 1: Collect all voxel positions
            const voxels = [];
            
            if (isSameImage) {
                // SINGLE IMAGE: Extrude with depth variation based on distance from edge
                console.log(`[bulk] Single image: extruding ${fw}x${fh} to depth ${depth}`);
                
                // Calculate distance field for depth variation
                const distField = new Float32Array(fw * fh);
                const maxSearchDist = Math.max(fw, fh);
                
                for (let y = 0; y < fh; y++) {
                    for (let x = 0; x < fw; x++) {
                        const idx = y * fw + x;
                        if (frontMask[idx] > 0) {
                            let minDist = maxSearchDist;
                            const searchR = 30; // Larger search radius for better depth calculation
                            
                            for (let dy = -searchR; dy <= searchR; dy++) {
                                const sy = y + dy;
                                if (sy < 0 || sy >= fh) continue;
                                for (let dx = -searchR; dx <= searchR; dx++) {
                                    const sx = x + dx;
                                    if (sx < 0 || sx >= fw) continue;
                                    if (frontMask[sy * fw + sx] === 0) {
                                        const dist = Math.sqrt(dx * dx + dy * dy);
                                        minDist = Math.min(minDist, dist);
                                    }
                                }
                            }
                            distField[idx] = minDist;
                        }
                    }
                }
                
                // Find max distance for normalization
                let maxDist = 0;
                for (let i = 0; i < distField.length; i++) {
                    maxDist = Math.max(maxDist, distField[i]);
                }
                console.log(`[bulk] Distance field: max=${maxDist.toFixed(1)}`);
                
                // Create voxels with varying depth - better depth profile
                for (let y = 0; y < fh; y++) {
                    for (let x = 0; x < fw; x++) {
                        const idx = y * fw + x;
                        if (frontMask[idx] > 0) {
                            const distFromEdge = distField[idx];
                            // Better normalization: use actual max distance
                            const normalizedDist = maxDist > 0 ? Math.min(1, distFromEdge / (maxDist * 0.5)) : 0.5;
                            // Use power curve for more volume in center
                            const depthCurve = Math.pow(normalizedDist, 0.6); // Less aggressive falloff
                            const voxelDepth = Math.max(1, Math.floor(depth * depthCurve)); // At least 1 voxel deep
                            
                            for (let z = 0; z < voxelDepth; z++) {
                                voxels.push({ x, y, z });
                                if (voxels.length >= maxVoxels) break;
                            }
                        }
                        if (voxels.length >= maxVoxels) break;
                    }
                    if (voxels.length >= maxVoxels) break;
                }
            } else {
                // DUAL IMAGE: Intersect front and side silhouettes with better logic
                console.log(`[bulk] Dual image: intersecting ${fw}x${fh} × ${sw}x${sh}`);
                
                // Build occupancy maps for better intersection
                for (let y = 0; y < fh; y++) {
                    const rowHasFront = [];
                    const rowHasSide = [];
                    
                    // Collect which X positions have front view pixels
                    for (let x = 0; x < fw; x++) {
                        if (frontMask[y * fw + x] > 0) {
                            rowHasFront.push(x);
                        }
                    }
                    
                    // Collect which Z positions have side view pixels
                    for (let z = 0; z < sw; z++) {
                        if (sideMask[y * sw + z] > 0) {
                            rowHasSide.push(z);
                        }
                    }
                    
                    // Create voxels where both views have pixels
                    if (rowHasFront.length > 0 && rowHasSide.length > 0) {
                        for (const x of rowHasFront) {
                            for (const z of rowHasSide) {
                                voxels.push({ x, y, z });
                                if (voxels.length >= maxVoxels) break;
                            }
                            if (voxels.length >= maxVoxels) break;
                        }
                    }
                    if (voxels.length >= maxVoxels) break;
                }
            }
            
            console.log(`[bulk] Generated ${voxels.length} voxels`);
            
            if (voxels.length === 0) {
                console.warn('[bulk] No voxels generated - using fallback box');
                return new THREE.BoxGeometry(0.5, config.heightScale || 1.7, 0.3);
            }
            
            // Step 2: Merge all voxel cubes into single geometry
            const geometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);
            const mergedGeometry = new THREE.BufferGeometry();
            
            const positions = [];
            const normals = [];
            const indices = [];
            let vertexOffset = 0;
            
            // Calculate center offset
            const w = isSameImage ? fw : fw;
            const h = fh;
            const d = isSameImage ? depth : sw;
            const sx = (w * VOXEL_SIZE) * 0.5;
            const sy = (h * VOXEL_SIZE) * 0.5;
            const sz = (d * VOXEL_SIZE) * 0.5;
            
            // Create transform matrix for each voxel
            const matrix = new THREE.Matrix4();
            const tempGeometry = geometry.clone();
            
            voxels.forEach((cell) => {
                const px = cell.x * VOXEL_SIZE - sx + VOXEL_SIZE * 0.5;
                const py = -(cell.y * VOXEL_SIZE) + sy - VOXEL_SIZE * 0.5;
                const pz = cell.z * VOXEL_SIZE - sz + VOXEL_SIZE * 0.5;
                
                matrix.makeTranslation(px, py, pz);
                tempGeometry.applyMatrix4(matrix);
                
                // Copy positions
                const pos = tempGeometry.attributes.position.array;
                for (let i = 0; i < pos.length; i++) {
                    positions.push(pos[i]);
                }
                
                // Copy normals
                const norm = tempGeometry.attributes.normal.array;
                for (let i = 0; i < norm.length; i++) {
                    normals.push(norm[i]);
                }
                
                // Copy indices with offset
                const idx = tempGeometry.index.array;
                for (let i = 0; i < idx.length; i++) {
                    indices.push(idx[i] + vertexOffset);
                }
                
                vertexOffset += pos.length / 3;
                
                // Reset geometry for next iteration
                matrix.makeTranslation(-px, -py, -pz);
                tempGeometry.applyMatrix4(matrix);
            });
            
            // Build final geometry
            mergedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            mergedGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            mergedGeometry.setIndex(indices);
            
            // Scale to target height (typically 1.7m for human)
            const bbox = new THREE.Box3().setFromBufferAttribute(mergedGeometry.attributes.position);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            
            console.log(`[bulk] Pre-scale dimensions: ${size.x.toFixed(2)}×${size.y.toFixed(2)}×${size.z.toFixed(2)}`);
            
            // Scale based on HEIGHT (Y axis) to preserve proportions
            const targetHeight = config.heightScale || 1.7;
            if (size.y > 0) {
                const heightScale = targetHeight / size.y;
                mergedGeometry.scale(heightScale, heightScale, heightScale);
                
                // Get new size after scaling
                bbox.setFromBufferAttribute(mergedGeometry.attributes.position);
                bbox.getSize(size);
                console.log(`[bulk] Post-scale dimensions: ${size.x.toFixed(2)}×${size.y.toFixed(2)}×${size.z.toFixed(2)}`);
            }
            
            // Center the mesh at origin
            bbox.getCenter(size); // reuse size vector as center
            mergedGeometry.translate(-size.x, -size.y + targetHeight / 2, -size.z);
            
            console.log(`[bulk] ✓ Voxel mesh created: ${voxels.length} cubes, ${vertexOffset} vertices, height=${targetHeight}m`);
            mergedGeometry.computeVertexNormals();
            
            return mergedGeometry;
        },

        laplacianSmooth(geometry, iterations) {
            const positions = geometry.attributes.position.array;
            const vertexCount = positions.length / 3;
            
            // Build adjacency list
            const neighbors = Array.from({ length: vertexCount }, () => []);
            
            if (geometry.index) {
                const indices = geometry.index.array;
                for (let i = 0; i < indices.length; i += 3) {
                    const a = indices[i];
                    const b = indices[i + 1];
                    const c = indices[i + 2];
                    
                    neighbors[a].push(b, c);
                    neighbors[b].push(a, c);
                    neighbors[c].push(a, b);
                }
            }
            
            // Smooth
            for (let iter = 0; iter < iterations; iter++) {
                const newPositions = new Float32Array(positions);
                
                for (let i = 0; i < vertexCount; i++) {
                    const nbrs = [...new Set(neighbors[i])]; // unique neighbors
                    if (nbrs.length === 0) continue;
                    
                    let avgX = 0, avgY = 0, avgZ = 0;
                    for (const n of nbrs) {
                        avgX += positions[n * 3 + 0];
                        avgY += positions[n * 3 + 1];
                        avgZ += positions[n * 3 + 2];
                    }
                    
                    const lambda = 0.5; // smoothing factor
                    newPositions[i * 3 + 0] = positions[i * 3 + 0] * (1 - lambda) + (avgX / nbrs.length) * lambda;
                    newPositions[i * 3 + 1] = positions[i * 3 + 1] * (1 - lambda) + (avgY / nbrs.length) * lambda;
                    newPositions[i * 3 + 2] = positions[i * 3 + 2] * (1 - lambda) + (avgZ / nbrs.length) * lambda;
                }
                
                positions.set(newPositions);
            }
            
            geometry.attributes.position.needsUpdate = true;
        },

        async exportMeshAsGLB(mesh, name) {
            return new Promise((resolve, reject) => {
                console.log(`[bulk] Starting GLB export for ${name}...`);
                
                if (!window.GLTFExporter) {
                    const error = new Error('GLTFExporter not loaded');
                    console.error('[bulk] Export failed:', error);
                    reject(error);
                    return;
                }
                
                const exporter = new window.GLTFExporter();
                exporter.parse(
                    mesh,
                    (result) => {
                        console.log(`[bulk] GLB export success for ${name}:`, {
                            resultType: typeof result,
                            resultSize: result?.byteLength || result?.length || 0
                        });
                        const blob = new Blob([result], { type: 'model/gltf-binary' });
                        console.log(`[bulk] Created blob:`, { size: blob.size, type: blob.type });
                        resolve({ name: `${name}.glb`, blob });
                    },
                    (error) => {
                        console.error(`[bulk] GLB export error for ${name}:`, error);
                        reject(error);
                    },
                    { binary: true }
                );
            });
        },

        async canvasToPNG(canvas, name) {
            return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                    resolve({ name: `${name}.png`, blob });
                }, 'image/png');
            });
        },

        async downloadZIP(files, zipName) {
            // Ensure JSZip is loaded
            if (!window.JSZip) {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
                // Wait a bit for JSZip to initialize
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            const JSZip = window.JSZip;
            if (!JSZip) {
                throw new Error('Failed to load JSZip library');
            }
            
            const zip = new JSZip();
            files.forEach(({ name, blob }) => {
                zip.file(name, blob);
            });

            const content = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = zipName;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        },

        updateStatus(message) {
            const status = document.getElementById('bulkStatus');
            if (status) status.textContent = message;
        }
    };

    // ============================================
    // GLB GALLERY SYSTEM
    // ============================================
    const GLBGallery = {
        storageKey: 'gamelite_glb_gallery',
        models: [],

        init() {
            this.loadFromStorage();
            this.setupUI();
            this.render();
        },

        loadFromStorage() {
            try {
                const data = localStorage.getItem(this.storageKey);
                if (data) {
                    this.models = JSON.parse(data);
                }
            } catch (e) {
                console.error('Failed to load gallery:', e);
                this.models = [];
            }
        },

        saveToStorage() {
            try {
                localStorage.setItem(this.storageKey, JSON.stringify(this.models));
            } catch (e) {
                console.error('Failed to save gallery:', e);
                showToast('Gallery save failed - storage limit reached', 'error');
            }
        },

        setupUI() {
            const modal = document.getElementById('glbGallery');
            const closeBtn = document.getElementById('galleryClose');
            const openBtn = document.getElementById('btn-gallery');

            openBtn?.addEventListener('click', () => {
                this.render();
                modal.style.display = 'block';
            });

            closeBtn?.addEventListener('click', () => {
                modal.style.display = 'none';
            });

            modal?.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });
        },

        addModel(name, glbData, metadata = {}) {
            const model = {
                id: Date.now() + Math.random(),
                name,
                glbData, // Base64 encoded GLB
                metadata: {
                    created: new Date().toISOString(),
                    source: metadata.source || 'manual',
                    ...metadata
                }
            };
            this.models.unshift(model); // Add to beginning
            this.saveToStorage();
            this.render();
            showToast(`"${name}" added to gallery`, 'success');
            return model.id;
        },

        removeModel(id) {
            const model = this.models.find(m => m.id === id);
            if (!model) return;

            if (confirm(`Delete "${model.name}" from gallery?`)) {
                this.models = this.models.filter(m => m.id !== id);
                this.saveToStorage();
                this.render();
                showToast(`"${model.name}" removed`, 'success');
            }
        },

        async spawnToScene(id) {
            const model = this.models.find(m => m.id === id);
            if (!model) return;

            try {
                // Convert base64 to blob
                const byteString = atob(model.glbData.split(',')[1]);
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                const blob = new Blob([ab], { type: 'model/gltf-binary' });
                const url = URL.createObjectURL(blob);

                // Load GLB using GLTFLoader
                const { GLTFLoader } = await import('three/examples/jsm/loaders/GLTFLoader.js');
                const loader = new GLTFLoader();

                loader.load(url, (gltf) => {
                    const loadedModel = gltf.scene;
                    loadedModel.position.set(0, 0, 0);
                    loadedModel.scale.set(1, 1, 1);

                    // Add to scene
                    AppState.scene.add(loadedModel);

                    // Add to objects array
                    AppState.objects.push({
                        mesh: loadedModel,
                        type: 'glb',
                        keyframes: [],
                        properties: {
                            position: loadedModel.position.clone(),
                            rotation: loadedModel.rotation.clone(),
                            scale: loadedModel.scale.clone()
                        },
                        metadata: model.metadata
                    });

                    // Save state for undo/redo
                    saveState(`Spawn ${model.name}`);

                    // Select the spawned model
                    selectObject(AppState.objects[AppState.objects.length - 1]);

                    URL.revokeObjectURL(url);
                    showToast(`"${model.name}" spawned into scene!`, 'success');
                    document.getElementById('glbGallery').style.display = 'none';
                }, undefined, (error) => {
                    console.error('Error loading GLB:', error);
                    showToast('Failed to load model', 'error');
                    URL.revokeObjectURL(url);
                });
            } catch (e) {
                console.error('Error spawning model:', e);
                showToast('Failed to spawn model', 'error');
            }
        },

        downloadModel(id) {
            const model = this.models.find(m => m.id === id);
            if (!model) return;

            const a = document.createElement('a');
            a.href = model.glbData;
            a.download = `${model.name}.glb`;
            a.click();
            showToast(`Downloading "${model.name}"`, 'success');
        },

        render() {
            const grid = document.getElementById('galleryGrid');
            const empty = document.getElementById('galleryEmpty');

            if (!grid || !empty) return;

            if (this.models.length === 0) {
                grid.innerHTML = '';
                empty.style.display = 'block';
                return;
            }

            empty.style.display = 'none';
            grid.innerHTML = this.models.map(model => `
                <div class="gallery-item" data-id="${model.id}">
                    <div class="gallery-item-thumb">🎁</div>
                    <div class="gallery-item-name" title="${model.name}">${model.name}</div>
                    <div style="font-size: 0.7rem; opacity: 0.6;">
                        ${model.metadata.source || 'unknown'} • ${new Date(model.metadata.created).toLocaleDateString()}
                    </div>
                    <div class="gallery-item-actions">
                        <button onclick="GLBGallery.spawnToScene(${model.id})">Spawn</button>
                        <button onclick="GLBGallery.downloadModel(${model.id})">Download</button>
                        <button class="danger" onclick="GLBGallery.removeModel(${model.id})">Delete</button>
                    </div>
                </div>
            `).join('');
        },

        // Helper to convert Blob/File to base64
        async blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        },

        // Export gallery as JSON (for backup)
        exportGallery() {
            const dataStr = JSON.stringify(this.models, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gamelite-gallery-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Gallery exported', 'success');
        },

        // Import gallery from JSON
        async importGallery(file) {
            try {
                const text = await file.text();
                const importedModels = JSON.parse(text);
                if (Array.isArray(importedModels)) {
                    this.models = [...importedModels, ...this.models];
                    this.saveToStorage();
                    this.render();
                    showToast(`Imported ${importedModels.length} models`, 'success');
                }
            } catch (e) {
                console.error('Import failed:', e);
                showToast('Failed to import gallery', 'error');
            }
        }
    };

    // Make GLBGallery globally accessible for inline onclick handlers
    window.GLBGallery = GLBGallery;

    // ============================================
    // TOAST NOTIFICATIONS
    // ============================================
    function showToast(message, type = 'success') {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.className = `toast ${type} active`;

        setTimeout(() => {
            toast.classList.remove('active');
        }, 3000);
    }

    // ============================================
    // ANIMATION LOOP
    // ============================================
    let lastTime = performance.now();
    let frameCount = 0;
    let fpsUpdateTime = 0;

    function animate() {
        requestAnimationFrame(animate);

        const currentTime = performance.now();
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // FPS calculation
        frameCount++;
        fpsUpdateTime += deltaTime;
        if (fpsUpdateTime >= 1) {
            AppState.environmentStats.fps = frameCount / fpsUpdateTime;
            frameCount = 0;
            fpsUpdateTime = 0;
        }

        // Update controls
        if (AppState.controls) {
            AppState.controls.update();
        }

        // Animation playback
        if (AppState.animationState.isPlaying) {
            AppState.animationState.currentTime += deltaTime * AppState.animationState.playbackSpeed;
            if (AppState.animationState.currentTime >= AppState.animationState.duration) {
                AppState.animationState.currentTime = 0;
            }

            // Update playhead position
            updatePlayhead();

            // Apply keyframe animations
            AppState.objects.forEach(obj => {
                if (obj.keyframes.length > 0) {
                    // Simple linear interpolation between keyframes
                    const currentFrame = obj.keyframes.find(kf =>
                        Math.abs(kf.time - AppState.animationState.currentTime) < 0.1
                    );
                    if (currentFrame) {
                        obj.mesh.position.copy(currentFrame.position);
                        obj.mesh.rotation.copy(currentFrame.rotation);
                        obj.mesh.scale.copy(currentFrame.scale);
                    }
                }
            });
        }

        // Rotate objects based on rotation control settings
        if (AppState.rotationEnabled) {
            AppState.objects.forEach((obj, idx) => {
                // If rotate selected only mode, only rotate the first object (or selected)
                if (!AppState.rotateSelectedOnly || idx === 0) {
                    obj.mesh.rotation.y += deltaTime * AppState.rotationSpeed;
                }
            });
        }

        // Update Glyphic Shader
        updateGlyphicShader(deltaTime);

        // Render
        AppState.renderer.render(AppState.scene, AppState.camera);

        // Update stats
        updateDebugInfo();
        updateEnvironmentStats();
    }

    // ============================================
    // ROTATION CONTROLS
    // ============================================
    function setupRotationControls() {
        const panel = document.getElementById('rotation-panel');
        const btnRotationControl = document.getElementById('btn-rotation-control');
        const btnToggleRotation = document.getElementById('btn-toggle-rotation');
        const btnRotateSelected = document.getElementById('btn-rotate-selected');
        const btnRotateSpeed = document.getElementById('btn-rotate-speed');

        let speedIndex = 1; // 0=slow, 1=normal, 2=fast
        const speeds = [0.05, 0.2, 0.5];
        const speedLabels = ['Slow', 'Normal', 'Fast'];

        btnRotationControl.addEventListener('click', () => {
            const isVisible = panel.style.display === 'flex';
            panel.style.display = isVisible ? 'none' : 'flex';
        });

        btnToggleRotation.addEventListener('click', () => {
            AppState.rotationEnabled = !AppState.rotationEnabled;
            btnToggleRotation.textContent = AppState.rotationEnabled ? '⏸️ Stop All Rotation' : '▶️ Start Rotation';
            btnToggleRotation.classList.toggle('active', !AppState.rotationEnabled);
        });

        btnRotateSelected.addEventListener('click', () => {
            AppState.rotateSelectedOnly = !AppState.rotateSelectedOnly;
            btnRotateSelected.textContent = AppState.rotateSelectedOnly ? '🌍 Rotate All' : '🎯 Rotate Selected Only';
            btnRotateSelected.classList.toggle('active', AppState.rotateSelectedOnly);
        });

        btnRotateSpeed.addEventListener('click', () => {
            speedIndex = (speedIndex + 1) % 3;
            AppState.rotationSpeed = speeds[speedIndex];
            btnRotateSpeed.textContent = `⚡ Speed: ${speedLabels[speedIndex]}`;
        });
    }

    // ============================================
    // TERRAIN BUILDER
    // ============================================

    // Simplified Perlin noise implementation
    class PerlinNoise {
        constructor(seed = 12345) {
            this.seed = seed;
            this.perm = this.generatePermutation();
        }

        generatePermutation() {
            const p = [];
            for (let i = 0; i < 256; i++) p[i] = i;

            // Shuffle using seed
            let random = this.seed;
            for (let i = 255; i > 0; i--) {
                random = (random * 1103515245 + 12345) & 0x7fffffff;
                const j = random % (i + 1);
                [p[i], p[j]] = [p[j], p[i]];
            }

            return p.concat(p);
        }

        fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        lerp(t, a, b) {
            return a + t * (b - a);
        }

        grad(hash, x, y) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        noise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;

            x -= Math.floor(x);
            y -= Math.floor(y);

            const u = this.fade(x);
            const v = this.fade(y);

            const a = this.perm[X] + Y;
            const aa = this.perm[a];
            const ab = this.perm[a + 1];
            const b = this.perm[X + 1] + Y;
            const ba = this.perm[b];
            const bb = this.perm[b + 1];

            return this.lerp(v,
                this.lerp(u, this.grad(this.perm[aa], x, y), this.grad(this.perm[ba], x - 1, y)),
                this.lerp(u, this.grad(this.perm[ab], x, y - 1), this.grad(this.perm[bb], x - 1, y - 1))
            );
        }

        octaveNoise(x, y, octaves, persistence, lacunarity) {
            let total = 0;
            let frequency = 1;
            let amplitude = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                total += this.noise(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= lacunarity;
            }

            return total / maxValue;
        }
    }

    function generateTerrain() {
        const width = parseFloat(document.getElementById('terrain-width').value);
        const height = parseFloat(document.getElementById('terrain-height').value);
        const resolution = parseInt(document.getElementById('terrain-resolution').value);
        const maxHeight = parseFloat(document.getElementById('terrain-max-height').value);
        const noiseScale = parseFloat(document.getElementById('terrain-noise-scale').value);
        const octaves = parseInt(document.getElementById('terrain-octaves').value);
        const persistence = parseFloat(document.getElementById('terrain-persistence').value);
        const lacunarity = parseFloat(document.getElementById('terrain-lacunarity').value);
        const seed = parseInt(document.getElementById('terrain-seed').value);
        const textureType = document.getElementById('terrain-texture-type').value;
        const colorMix = parseFloat(document.getElementById('terrain-color-mix').value);
        const roughness = parseFloat(document.getElementById('terrain-roughness').value);
        const metalness = parseFloat(document.getElementById('terrain-metalness').value);
        const erosion = parseFloat(document.getElementById('terrain-erosion').value);

        // Check if there's a selected boundary from Nexus Lab
        const selectedBoundary = AppState.nexusGraph.selectedBoundary;

        // Remove existing terrain
        if (AppState.terrainMesh) {
            AppState.scene.remove(AppState.terrainMesh);
            if (AppState.terrainMesh.geometry) AppState.terrainMesh.geometry.dispose();
            if (AppState.terrainMesh.material) AppState.terrainMesh.material.dispose();
        }

        // Create terrain geometry
        const geometry = new THREE.PlaneGeometry(width, height, resolution - 1, resolution - 1);
        const perlin = new PerlinNoise(seed);

        // Apply displacement
        const vertices = geometry.attributes.position.array;
        let verticesInBoundary = 0;

        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 1];  // Note: In PlaneGeometry, y is the height (will be z after rotation)

            // Check if this vertex is inside the boundary (if one is selected)
            let insideBoundary = true;
            if (selectedBoundary) {
                insideBoundary = isPointInBoundary(x, z, selectedBoundary);
            }

            if (insideBoundary) {
                let noise = perlin.octaveNoise(
                    x * noiseScale,
                    z * noiseScale,
                    octaves,
                    persistence,
                    lacunarity
                );

                // Apply erosion (smoothing)
                if (erosion > 0) {
                    noise = Math.pow(Math.abs(noise), 1 + erosion) * Math.sign(noise);
                }

                vertices[i + 2] = noise * maxHeight;
                verticesInBoundary++;
            } else {
                // Outside boundary: set height to 0 (flat)
                vertices[i + 2] = 0;
            }
        }

        geometry.computeVertexNormals();

        // Create material with texture
        const material = createTerrainMaterial(textureType, colorMix, roughness, metalness);

        // Create mesh
        const terrain = new THREE.Mesh(geometry, material);
        terrain.rotation.x = -Math.PI / 2;
        terrain.receiveShadow = true;
        terrain.castShadow = true;

        AppState.scene.add(terrain);
        AppState.terrainMesh = terrain;

        if (selectedBoundary) {
            showToast(`🏔️ Terrain generated in boundary: ${width}×${height}m, ${verticesInBoundary} vertices affected`, 'success');
        } else {
            showToast(`🏔️ Terrain generated: ${width}×${height}m, ${resolution}×${resolution} vertices`, 'success');
        }
    }

    function createTerrainMaterial(textureType, colorMix, roughness, metalness) {
        let color1, color2, color3;

        switch (textureType) {
            case 'grass':
                color1 = new THREE.Color(0x4a7c59);
                color2 = new THREE.Color(0x6b9b77);
                color3 = new THREE.Color(0x8fbc8f);
                break;
            case 'rock':
                color1 = new THREE.Color(0x4a4a4a);
                color2 = new THREE.Color(0x6a6a6a);
                color3 = new THREE.Color(0x8a8a8a);
                break;
            case 'sand':
                color1 = new THREE.Color(0xc2b280);
                color2 = new THREE.Color(0xddc9a3);
                color3 = new THREE.Color(0xf0e68c);
                break;
            case 'snow':
                color1 = new THREE.Color(0xd0e8f0);
                color2 = new THREE.Color(0xe8f4f8);
                color3 = new THREE.Color(0xffffff);
                break;
            case 'noise':
                color1 = new THREE.Color(0x2c3e50);
                color2 = new THREE.Color(0x34495e);
                color3 = new THREE.Color(0x5d6d7e);
                break;
            default: // gradient
                color1 = new THREE.Color(0x1a472a);
                color2 = new THREE.Color(0x5d8a66);
                color3 = new THREE.Color(0xffffff);
        }

        // Interpolate colors based on colorMix
        const finalColor = new THREE.Color().lerpColors(color1, color2, colorMix);

        return new THREE.MeshStandardMaterial({
            color: finalColor,
            roughness: roughness,
            metalness: metalness,
            flatShading: false,
            side: THREE.DoubleSide
        });
    }

    function clearTerrain() {
        if (AppState.terrainMesh) {
            AppState.scene.remove(AppState.terrainMesh);
            if (AppState.terrainMesh.geometry) AppState.terrainMesh.geometry.dispose();
            if (AppState.terrainMesh.material) AppState.terrainMesh.material.dispose();
            AppState.terrainMesh = null;
            showToast('🗑️ Terrain cleared', 'success');
        }
    }

    function setupTerrainBuilder() {
        const modal = document.getElementById('terrain-modal');
        const btnTerrainBuilder = document.getElementById('btn-terrain-builder');
        const btnGenerate = document.getElementById('btn-generate-terrain');
        const btnClear = document.getElementById('btn-clear-terrain');
        const btnClose = document.getElementById('btn-close-terrain');

        // Update boundary status display
        function updateBoundaryStatus() {
            const boundaryInfo = document.getElementById('boundary-info');
            const selectedBoundary = AppState.nexusGraph.selectedBoundary;

            if (selectedBoundary) {
                boundaryInfo.innerHTML = `✅ <strong>Boundary "${selectedBoundary.id}"</strong> active with ${selectedBoundary.nodes.length} nodes.<br>Terrain will only generate inside this boundary.`;
                boundaryInfo.style.color = '#10e0e0';
            } else if (AppState.nexusGraph.boundaries.length > 0) {
                boundaryInfo.innerHTML = `⚠️ ${AppState.nexusGraph.boundaries.length} boundaries exist, but none selected.<br>Terrain will generate normally (not constrained).`;
                boundaryInfo.style.color = '#ffaa00';
            } else {
                boundaryInfo.innerHTML = 'No boundary selected. Create a boundary in Nexus Lab to constrain terrain.';
                boundaryInfo.style.color = 'var(--muted)';
            }
        }

        // Open modal
        btnTerrainBuilder.addEventListener('click', () => {
            modal.classList.add('active');
            updateBoundaryStatus(); // Update status when opening
        });

        // Close modal
        btnClose.addEventListener('click', () => {
            modal.classList.remove('active');
        });

        // Generate terrain
        btnGenerate.addEventListener('click', () => {
            generateTerrain();
        });

        // Clear terrain
        btnClear.addEventListener('click', () => {
            clearTerrain();
        });

        // Setup all slider value displays
        const sliders = [
            'terrain-width', 'terrain-height', 'terrain-resolution',
            'terrain-max-height', 'terrain-noise-scale', 'terrain-octaves',
            'terrain-persistence', 'terrain-lacunarity', 'terrain-color-mix',
            'terrain-roughness', 'terrain-metalness', 'terrain-erosion'
        ];

        sliders.forEach(id => {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + '-val');

            slider.addEventListener('input', () => {
                valueDisplay.textContent = slider.value;
            });
        });

        // Close modal when clicking outside
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.classList.remove('active');
            }
        });
    }

    // ============================================
    // GEOMETRIC GRAPH MANAGER
    // ============================================

    class GraphNode {
        constructor(id, x, y, z = 0) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.z = z;
            this.connections = [];
            this.element = null;
            this.mesh = null;
        }

        createVisualElement(container) {
            // Create 2D overlay node
            this.element = document.createElement('div');
            this.element.className = 'graph-node';
            this.element.dataset.nodeId = this.id;
            this.element.style.left = `${this.x}px`;
            this.element.style.top = `${this.y}px`;
            container.appendChild(this.element);

            // Create 3D mesh
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0x3b82f6,
                emissive: 0x3b82f6,
                emissiveIntensity: 0.5
            });
            this.mesh = new THREE.Mesh(geometry, material);

            // Convert screen coordinates to world coordinates
            const worldPos = screenToWorld(this.x, this.y);
            this.mesh.position.set(worldPos.x, 0, worldPos.z);

            AppState.scene.add(this.mesh);
            return this.element;
        }

        updatePosition(x, y) {
            this.x = x;
            this.y = y;
            if (this.element) {
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
            }
            if (this.mesh) {
                const worldPos = screenToWorld(x, y);
                this.mesh.position.set(worldPos.x, 0, worldPos.z);
            }
        }

        remove() {
            if (this.element) {
                this.element.remove();
            }
            if (this.mesh) {
                AppState.scene.remove(this.mesh);
                if (this.mesh.geometry) this.mesh.geometry.dispose();
                if (this.mesh.material) this.mesh.material.dispose();
            }
        }

        setSelected(selected) {
            if (this.element) {
                if (selected) {
                    this.element.classList.add('selected');
                } else {
                    this.element.classList.remove('selected');
                }
            }
            if (this.mesh) {
                this.mesh.material.emissiveIntensity = selected ? 1.0 : 0.5;
            }
        }
    }

    class GraphLine {
        constructor(id, node1, node2) {
            this.id = id;
            this.node1 = node1;
            this.node2 = node2;
            this.mesh = null;
            this.createMesh();
        }

        createMesh() {
            const points = [
                new THREE.Vector3(this.node1.mesh.position.x, 0.1, this.node1.mesh.position.z),
                new THREE.Vector3(this.node2.mesh.position.x, 0.1, this.node2.mesh.position.z)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x3b82f6,
                linewidth: 2
            });
            this.mesh = new THREE.Line(geometry, material);
            AppState.scene.add(this.mesh);
        }

        update() {
            if (this.mesh) {
                const positions = this.mesh.geometry.attributes.position.array;
                positions[0] = this.node1.mesh.position.x;
                positions[1] = 0.1;
                positions[2] = this.node1.mesh.position.z;
                positions[3] = this.node2.mesh.position.x;
                positions[4] = 0.1;
                positions[5] = this.node2.mesh.position.z;
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        remove() {
            if (this.mesh) {
                AppState.scene.remove(this.mesh);
                if (this.mesh.geometry) this.mesh.geometry.dispose();
                if (this.mesh.material) this.mesh.material.dispose();
            }
        }
    }

    class Boundary {
        constructor(id, nodes) {
            this.id = id;
            this.nodes = nodes;
            this.mesh = null;
            this.createMesh();
        }

        createMesh() {
            if (this.nodes.length < 3) return;

            const shape = new THREE.Shape();
            const firstNode = this.nodes[0];
            shape.moveTo(firstNode.mesh.position.x, firstNode.mesh.position.z);

            for (let i = 1; i < this.nodes.length; i++) {
                const node = this.nodes[i];
                shape.lineTo(node.mesh.position.x, node.mesh.position.z);
            }
            shape.lineTo(firstNode.mesh.position.x, firstNode.mesh.position.z);

            const geometry = new THREE.ShapeGeometry(shape);
            const material = new THREE.MeshBasicMaterial({
                color: 0xef4444,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.rotation.x = -Math.PI / 2;
            this.mesh.position.y = 0.05;
            AppState.scene.add(this.mesh);

            // Mark nodes as boundary nodes
            this.nodes.forEach(node => {
                if (node.element) {
                    node.element.classList.add('boundary');
                }
            });
        }

        update() {
            this.remove();
            this.createMesh();
        }

        remove() {
            if (this.mesh) {
                AppState.scene.remove(this.mesh);
                if (this.mesh.geometry) this.mesh.geometry.dispose();
                if (this.mesh.material) this.mesh.material.dispose();
                this.mesh = null;
            }
        }

        contains(x, z) {
            // Point-in-polygon test (ray casting algorithm)
            let inside = false;
            const points = this.nodes.map(n => ({ x: n.mesh.position.x, z: n.mesh.position.z }));

            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                const xi = points[i].x, zi = points[i].z;
                const xj = points[j].x, zj = points[j].z;

                const intersect = ((zi > z) !== (zj > z))
                    && (x < (xj - xi) * (z - zi) / (zj - zi) + xi);
                if (intersect) inside = !inside;
            }

            return inside;
        }

        getCenter() {
            let sumX = 0, sumZ = 0;
            this.nodes.forEach(node => {
                sumX += node.mesh.position.x;
                sumZ += node.mesh.position.z;
            });
            return {
                x: sumX / this.nodes.length,
                z: sumZ / this.nodes.length
            };
        }

        getBounds() {
            let minX = Infinity, maxX = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            this.nodes.forEach(node => {
                const x = node.mesh.position.x;
                const z = node.mesh.position.z;
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (z < minZ) minZ = z;
                if (z > maxZ) maxZ = z;
            });

            return { minX, maxX, minZ, maxZ };
        }
    }

    function screenToWorld(screenX, screenY) {
        const canvas = AppState.renderer.domElement;
        const rect = canvas.getBoundingClientRect();

        const x = ((screenX - rect.left) / rect.width) * 2 - 1;
        const y = -((screenY - rect.top) / rect.height) * 2 + 1;

        const vector = new THREE.Vector3(x, y, 0.5);
        vector.unproject(AppState.camera);

        const dir = vector.sub(AppState.camera.position).normalize();
        const distance = -AppState.camera.position.y / dir.y;
        const pos = AppState.camera.position.clone().add(dir.multiplyScalar(distance));

        return { x: pos.x, z: pos.z };
    }

    function snapToGrid(value, gridSize) {
        return Math.round(value / gridSize) * gridSize;
    }

    function updateGraphInfo() {
        document.getElementById('graph-node-count').textContent = AppState.graphManager.nodes.length;
        document.getElementById('graph-line-count').textContent = AppState.graphManager.lines.length;
        document.getElementById('graph-boundary-count').textContent = AppState.graphManager.boundaries.length;
    }

    function addGraphNode(x, y) {
        const gm = AppState.graphManager;

        if (gm.gridEnabled) {
            x = snapToGrid(x, gm.gridSize);
            y = snapToGrid(y, gm.gridSize);
        }

        const node = new GraphNode(gm.nodeIdCounter++, x, y);
        const container = document.getElementById('canvas-container');
        node.createVisualElement(container);

        // Make node draggable
        let isDragging = false;
        let startX, startY;

        node.element.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            isDragging = true;
            startX = e.clientX - node.x;
            startY = e.clientY - node.y;

            // Handle selection
            if (e.ctrlKey || e.metaKey) {
                const idx = gm.selectedNodes.indexOf(node);
                if (idx > -1) {
                    gm.selectedNodes.splice(idx, 1);
                    node.setSelected(false);
                } else {
                    gm.selectedNodes.push(node);
                    node.setSelected(true);
                }
            } else if (!gm.selectedNodes.includes(node)) {
                gm.selectedNodes.forEach(n => n.setSelected(false));
                gm.selectedNodes = [node];
                node.setSelected(true);
            }

            // Connect mode
            if (gm.connectMode && gm.selectedNodes.length === 2 && gm.selectedNodes[1] === node) {
                connectNodes(gm.selectedNodes[0], gm.selectedNodes[1]);
                gm.selectedNodes.forEach(n => n.setSelected(false));
                gm.selectedNodes = [];
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                let newX = e.clientX - startX;
                let newY = e.clientY - startY;

                if (gm.gridEnabled) {
                    newX = snapToGrid(newX, gm.gridSize);
                    newY = snapToGrid(newY, gm.gridSize);
                }

                node.updatePosition(newX, newY);

                // Update connected lines
                gm.lines.forEach(line => {
                    if (line.node1 === node || line.node2 === node) {
                        line.update();
                    }
                });

                // Update boundaries
                gm.boundaries.forEach(boundary => {
                    if (boundary.nodes.includes(node)) {
                        boundary.update();
                    }
                });
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        gm.nodes.push(node);
        updateGraphInfo();
        showToast(`📍 Node ${node.id} added`, 'success');
        return node;
    }

    function connectNodes(node1, node2) {
        const gm = AppState.graphManager;

        // Check if connection already exists
        const exists = gm.lines.some(line =>
            (line.node1 === node1 && line.node2 === node2) ||
            (line.node1 === node2 && line.node2 === node1)
        );

        if (exists) {
            showToast('⚠️ Connection already exists', 'error');
            return;
        }

        const line = new GraphLine(gm.lines.length, node1, node2);
        node1.connections.push(node2);
        node2.connections.push(node1);
        gm.lines.push(line);

        updateGraphInfo();
        showToast(`🔗 Connected nodes ${node1.id} ↔ ${node2.id}`, 'success');
    }

    function createBoundary() {
        const gm = AppState.graphManager;

        if (gm.selectedNodes.length < 3) {
            showToast('⚠️ Select at least 3 nodes to create a boundary', 'error');
            return;
        }

        const boundary = new Boundary(gm.boundaries.length, [...gm.selectedNodes]);
        gm.boundaries.push(boundary);

        gm.selectedNodes.forEach(n => n.setSelected(false));
        gm.selectedNodes = [];

        updateGraphInfo();
        showToast(`⭕ Boundary created with ${boundary.nodes.length} nodes`, 'success');
    }

    function generateTerrainInBoundary(boundaryId) {
        const gm = AppState.graphManager;

        if (gm.boundaries.length === 0) {
            showToast('⚠️ No boundaries defined. Create a boundary first.', 'error');
            return;
        }

        const boundary = boundaryId !== undefined ? gm.boundaries[boundaryId] : gm.boundaries[gm.boundaries.length - 1];
        const bounds = boundary.getBounds();
        const center = boundary.getCenter();

        const width = Math.abs(bounds.maxX - bounds.minX);
        const height = Math.abs(bounds.maxZ - bounds.minZ);

        // Get terrain settings from terrain builder if available
        const resolution = parseInt(document.getElementById('terrain-resolution')?.value || 64);
        const maxHeight = parseFloat(document.getElementById('terrain-max-height')?.value || 10);
        const noiseScale = parseFloat(document.getElementById('terrain-noise-scale')?.value || 0.1);
        const octaves = parseInt(document.getElementById('terrain-octaves')?.value || 4);
        const persistence = parseFloat(document.getElementById('terrain-persistence')?.value || 0.5);
        const lacunarity = parseFloat(document.getElementById('terrain-lacunarity')?.value || 2.0);
        const seed = parseInt(document.getElementById('terrain-seed')?.value || Math.floor(Math.random() * 100000));

        // Create terrain geometry
        const geometry = new THREE.PlaneGeometry(width, height, resolution - 1, resolution - 1);
        const perlin = new PerlinNoise(seed);

        // Apply displacement only within boundary
        const vertices = geometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            const localX = vertices[i];
            const localZ = vertices[i + 1];

            const worldX = center.x + localX;
            const worldZ = center.z + localZ;

            // Check if point is inside boundary
            if (boundary.contains(worldX, worldZ)) {
                let noise = perlin.octaveNoise(
                    worldX * noiseScale,
                    worldZ * noiseScale,
                    octaves,
                    persistence,
                    lacunarity
                );
                vertices[i + 2] = noise * maxHeight;
            } else {
                vertices[i + 2] = 0; // Flat outside boundary
            }
        }

        geometry.computeVertexNormals();

        // Create material
        const material = new THREE.MeshStandardMaterial({
            color: 0x6b9b77,
            roughness: 0.8,
            metalness: 0.1,
            flatShading: false,
            side: THREE.DoubleSide
        });

        // Create mesh
        const terrain = new THREE.Mesh(geometry, material);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.set(center.x, 0, center.z);
        terrain.receiveShadow = true;
        terrain.castShadow = true;

        AppState.scene.add(terrain);

        showToast(`🏔️ Terrain generated in boundary (${width.toFixed(1)}×${height.toFixed(1)}m)`, 'success');
    }

    function clearGraph() {
        const gm = AppState.graphManager;

        gm.nodes.forEach(node => node.remove());
        gm.lines.forEach(line => line.remove());
        gm.boundaries.forEach(boundary => boundary.remove());

        gm.nodes = [];
        gm.lines = [];
        gm.boundaries = [];
        gm.selectedNodes = [];
        gm.nodeIdCounter = 0;

        updateGraphInfo();
        showToast('🗑️ Graph cleared', 'success');
    }

    // ============================================
    // NEXUS LAB - GRAPH SYNC HELPERS
    // ============================================

    // Convert screen position to 3D world position (on ground plane y=0)
    function screenToWorld3D(screenX, screenY, canvasWidth, canvasHeight) {
        // Map screen coords to world coords (assuming centered grid)
        const worldX = (screenX - canvasWidth / 2) * 0.1;  // Scale factor
        const worldZ = (screenY - canvasHeight / 2) * 0.1;
        return { x: worldX, y: 0, z: worldZ };
    }

    // Create 3D cube marker for node
    function createNodeMarker(worldPos) {
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshStandardMaterial({
            color: 0x10e0e0,
            emissive: 0x10e0e0,
            emissiveIntensity: 0.3,
            metalness: 0.5,
            roughness: 0.3
        });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(worldPos.x, worldPos.y + 1, worldPos.z); // Raise 1 unit above ground
        cube.castShadow = true;
        cube.receiveShadow = true;
        cube.userData.isNexusNode = true;
        AppState.scene.add(cube);
        return cube;
    }

    // Create 3D line between two nodes
    function createEdgeLine(nodeA, nodeB) {
        const points = [
            new THREE.Vector3(nodeA.mesh3D.position.x, 0.5, nodeA.mesh3D.position.z),
            new THREE.Vector3(nodeB.mesh3D.position.x, 0.5, nodeB.mesh3D.position.z)
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: 0x10e0e0, linewidth: 2 });
        const line = new THREE.Line(geometry, material);
        line.userData.isNexusEdge = true;
        AppState.scene.add(line);
        return line;
    }

    // Create 3D boundary plane
    function createBoundaryPlane(nodes) {
        if (nodes.length < 3) return null;

        // Create shape from node positions
        const shape = new THREE.Shape();
        nodes.forEach((node, i) => {
            const pos = node.mesh3D.position;
            if (i === 0) {
                shape.moveTo(pos.x, pos.z);
            } else {
                shape.lineTo(pos.x, pos.z);
            }
        });
        shape.closePath();

        const geometry = new THREE.ShapeGeometry(shape);
        const material = new THREE.MeshStandardMaterial({
            color: 0xff3aa5,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2; // Lay flat on ground
        mesh.position.y = 0.1; // Slightly above ground
        mesh.userData.isNexusBoundary = true;
        AppState.scene.add(mesh);
        return mesh;
    }

    // Update edge line when nodes move
    function updateEdgeLine(edge) {
        if (!edge.line3D) return;
        const positions = edge.line3D.geometry.attributes.position.array;
        positions[0] = edge.nodeA.mesh3D.position.x;
        positions[1] = 0.5;
        positions[2] = edge.nodeA.mesh3D.position.z;
        positions[3] = edge.nodeB.mesh3D.position.x;
        positions[4] = 0.5;
        positions[5] = edge.nodeB.mesh3D.position.z;
        edge.line3D.geometry.attributes.position.needsUpdate = true;
    }

    // Update boundary plane when nodes move
    function updateBoundaryPlane(boundary) {
        if (!boundary.mesh3D || boundary.nodes.length < 3) return;

        // Remove old mesh
        AppState.scene.remove(boundary.mesh3D);
        boundary.mesh3D.geometry.dispose();
        boundary.mesh3D.material.dispose();

        // Create new mesh with updated positions
        boundary.mesh3D = createBoundaryPlane(boundary.nodes);
    }

    // Point-in-polygon test (ray casting algorithm)
    function isPointInBoundary(x, z, boundary) {
        if (!boundary.nodes || boundary.nodes.length < 3) return false;

        let inside = false;
        const nodes = boundary.nodes;
        for (let i = 0, j = nodes.length - 1; i < nodes.length; j = i++) {
            const xi = nodes[i].mesh3D.position.x;
            const zi = nodes[i].mesh3D.position.z;
            const xj = nodes[j].mesh3D.position.x;
            const zj = nodes[j].mesh3D.position.z;

            const intersect = ((zi > z) !== (zj > z)) &&
                (x < (xj - xi) * (z - zi) / (zj - zi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    // Clear all Nexus graph data
    function clearNexusGraph() {
        const ng = AppState.nexusGraph;

        // Remove 3D objects from scene
        ng.nodes.forEach(node => {
            if (node.mesh3D) {
                AppState.scene.remove(node.mesh3D);
                node.mesh3D.geometry.dispose();
                node.mesh3D.material.dispose();
            }
        });

        ng.edges.forEach(edge => {
            if (edge.line3D) {
                AppState.scene.remove(edge.line3D);
                edge.line3D.geometry.dispose();
                edge.line3D.material.dispose();
            }
        });

        ng.boundaries.forEach(boundary => {
            if (boundary.mesh3D) {
                AppState.scene.remove(boundary.mesh3D);
                boundary.mesh3D.geometry.dispose();
                boundary.mesh3D.material.dispose();
            }
        });

        // Clear arrays
        ng.nodes = [];
        ng.edges = [];
        ng.boundaries = [];
        ng.selectedBoundary = null;
        ng.nodeIdCounter = 0;

        showToast('🗑️ Nexus graph cleared', 'success');
    }

    // ============================================
    // NEXUS LAB - 4D CANVAS SYSTEM
    // ============================================
    function setupNexusLab() {
        const btnNexusLab = document.getElementById('btn-nexus-lab');
        const nexusModal = document.getElementById('nexus-lab-modal');
        const nexusClose = document.getElementById('nexus-lab-close');
        const nexusContainer = document.getElementById('nexus-canvas-container');

        let nexusInitialized = false;

        btnNexusLab.addEventListener('click', () => {
            // Open nexus-LAB-CORRECT.html in new window/tab
            window.open('nexus-LAB-CORRECT.html', '_blank');
        });

        nexusClose.addEventListener('click', () => {
            nexusModal.style.display = 'none';
        });

        function initializeNexusCanvas() {
            // NEW SIMPLIFIED NEXUS LAB - Single grid mirror of main scene
            nexusContainer.innerHTML = `
                <style>
                    #nexus-canvas-container {
                        --bg:#0b0f14; --accent:#10e0e0; --text:#e8f0ff; --muted:#92a0b3;
                        background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui;
                        position: relative; width: 100%; height: 100%;
                    }

                    /* Collapsible Toolbar */
                    .nexus-toolbar {
                        position: absolute; top: 0; left: 0; right: 0; z-index: 10;
                        background: rgba(15, 22, 32, 0.95);
                        backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
                        border-bottom: 1px solid #1e2a3a;
                        padding: 10px;
                        transition: transform 0.3s ease;
                    }
                    .nexus-toolbar.collapsed { transform: translateY(-100%); }

                    .toolbar-toggle {
                        position: absolute; bottom: -30px; left: 50%; transform: translateX(-50%);
                        background: rgba(15, 22, 32, 0.95); border: 1px solid #1e2a3a;
                        border-top: none; padding: 5px 15px; border-radius: 0 0 8px 8px;
                        cursor: pointer; color: var(--accent); font-size: 12px;
                    }

                    .tool-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }

                    .tool-btn {
                        padding: 8px 12px; background: #0d1b26; color: var(--text);
                        border: 1px solid #204055; border-radius: 8px;
                        cursor: pointer; font-weight: 600; font-size: 13px;
                        transition: all 0.2s;
                    }
                    .tool-btn:hover { border-color: #2b6e7a; background: #1a2c3a; }
                    .tool-btn.active { background: #1a3a3a; border-color: var(--accent); box-shadow: 0 0 10px rgba(16,224,224,0.3); }
                    .tool-btn.danger { background: rgba(255,60,60,0.2); border-color: #ff3c3c; }

                    .tool-sep { width: 2px; height: 24px; background: #22313f; margin: 0 4px; }

                    /* Canvas */
                    #nx-canvas {
                        position: absolute; inset: 0; width: 100%; height: 100%;
                        cursor: crosshair;
                    }

                    /* Info Panel */
                    .info-panel {
                        position: absolute; bottom: 12px; left: 12px; z-index: 10;
                        background: rgba(15, 22, 32, 0.9); border: 1px solid #1e2a3a;
                        border-radius: 10px; padding: 12px; font-size: 12px;
                        min-width: 200px;
                    }
                    .info-line { display: flex; justify-content: space-between; margin: 4px 0; }
                    .info-line span:first-child { color: var(--muted); }
                    .info-line span:last-child { color: var(--accent); font-weight: bold; }

                    /* Layer Controls Panel */
                    .layer-controls-panel {
                        position: absolute; top: 80px; left: 12px; z-index: 10;
                        background: rgba(15, 22, 32, 0.95); border: 1px solid #1e2a3a;
                        border-radius: 10px; padding: 12px; font-size: 11px;
                        min-width: 220px; max-height: calc(100vh - 100px);
                        overflow-y: auto;
                    }
                    .slider-group {
                        margin: 8px 0;
                    }
                    .slider-group label {
                        display: flex; justify-content: space-between;
                        color: var(--muted); margin-bottom: 4px; font-size: 11px;
                    }
                    .slider-group label span {
                        color: var(--accent); font-weight: bold;
                    }
                    .alpha-slider {
                        width: 100%; height: 6px;
                        -webkit-appearance: none; appearance: none;
                        background: linear-gradient(to right, rgba(16,224,224,0.2), rgba(16,224,224,1));
                        border-radius: 3px; outline: none;
                        cursor: pointer;
                    }
                    .alpha-slider::-webkit-slider-thumb {
                        -webkit-appearance: none; appearance: none;
                        width: 14px; height: 14px; border-radius: 50%;
                        background: var(--accent); cursor: pointer;
                        box-shadow: 0 0 4px rgba(16,224,224,0.6);
                    }
                    .alpha-slider::-moz-range-thumb {
                        width: 14px; height: 14px; border-radius: 50%;
                        background: var(--accent); cursor: pointer; border: none;
                        box-shadow: 0 0 4px rgba(16,224,224,0.6);
                    }

                    /* Preview Canvas */
                    .preview-panel {
                        position: absolute; bottom: 12px; right: 12px; z-index: 10;
                        background: rgba(15, 22, 32, 0.9); border: 1px solid #1e2a3a;
                        border-radius: 10px; padding: 10px;
                    }
                    .preview-label {
                        font-size: 11px; color: var(--muted); margin-bottom: 6px;
                        display: flex; align-items: center; justify-content: space-between;
                    }
                    #preview-canvas { display: block; width: 300px; height: 200px; border-radius: 8px; background: #000; border: 1px solid #1e2a3a; }
                </style>

                <!-- Collapsible Toolbar -->
                <div class="nexus-toolbar" id="nx-toolbar">
                    <div class="tool-row">
                        <span style="color: var(--accent); font-weight: bold; font-size: 14px;">🧬 Nexus Lab</span>
                        <div class="tool-sep"></div>
                        <button id="nx-mode-pull" class="tool-btn active">⛰️ Pull Mountains</button>
                        <button id="nx-mode-boundary" class="tool-btn">📐 Draw Boundaries</button>
                        <div class="tool-sep"></div>
                        <button id="nx-spawn-node" class="tool-btn">➕ Node</button>
                        <button id="nx-spawn-lake" class="tool-btn">🌊 Lake</button>
                        <button id="nx-spawn-box" class="tool-btn">⬜ Box</button>
                        <button id="nx-spawn-radial" class="tool-btn">✨ Radial</button>
                        <button id="nx-connect" class="tool-btn">🔗 Connect</button>
                        <button id="nx-move-node" class="tool-btn">✋ Move</button>
                        <button id="nx-erase" class="tool-btn">🧹 Erase</button>
                        <button id="nx-select" class="tool-btn">🎯 Select</button>
                        <button id="nx-create-boundary" class="tool-btn">⭕ Boundary</button>
                        <div class="tool-sep"></div>
                        <button id="nx-zoom-front" class="tool-btn" title="Zoom to Front Side">🔍 Front</button>
                        <button id="nx-zoom-right" class="tool-btn" title="Zoom to Right Side">🔍 Right</button>
                        <button id="nx-zoom-back" class="tool-btn" title="Zoom to Back Side">🔍 Back</button>
                        <button id="nx-zoom-left" class="tool-btn" title="Zoom to Left Side">🔍 Left</button>
                        <button id="nx-zoom-reset" class="tool-btn" title="Reset View">🔄 Reset View</button>
                        <div class="tool-sep"></div>
                        <button id="nx-clear-all" class="tool-btn danger">🗑️ Clear All</button>
                        <div class="tool-sep"></div>
                        <button id="nx-save-to-region" class="tool-btn">💾 Save to Region</button>
                        <button id="nx-load-from-region" class="tool-btn">📂 Load Region</button>
                    </div>
                    <div class="toolbar-toggle" id="toolbar-toggle">▼ Hide Toolbar</div>
                </div>

                <!-- Main Canvas (mirrors main grid) -->
                <canvas id="nx-canvas"></canvas>

                <!-- Info Panel -->
                <div class="info-panel">
                    <div style="color: var(--accent); font-weight: bold; margin-bottom: 8px;">Graph Info</div>
                    <div class="info-line"><span>Mode:</span><span id="info-mode">Pull Mountains</span></div>
                    <div class="info-line"><span>Nodes:</span><span id="info-nodes">0</span></div>
                    <div class="info-line"><span>Connections:</span><span id="info-connections">0</span></div>
                    <div class="info-line"><span>Boundaries:</span><span id="info-boundaries">0</span></div>
                    <div class="info-line"><span>Selected:</span><span id="info-selected">None</span></div>
                </div>

                <!-- Layer Controls Panel -->
                <div class="layer-controls-panel">
                    <div style="color: var(--accent); font-weight: bold; margin-bottom: 8px;">Layer Opacity</div>

                    <div class="slider-group">
                        <label>Nodes <span id="nodes-alpha-val">100%</span></label>
                        <input type="range" id="nodes-alpha" min="0" max="100" value="100" class="alpha-slider">
                    </div>

                    <div class="slider-group">
                        <label>Links <span id="links-alpha-val">100%</span></label>
                        <input type="range" id="links-alpha" min="0" max="100" value="100" class="alpha-slider">
                    </div>

                    <div class="slider-group">
                        <label>Boundaries <span id="boundaries-alpha-val">100%</span></label>
                        <input type="range" id="boundaries-alpha" min="0" max="100" value="100" class="alpha-slider">
                    </div>

                    <div class="slider-group">
                        <label>Grid <span id="grid-alpha-val">100%</span></label>
                        <input type="range" id="grid-alpha" min="0" max="100" value="100" class="alpha-slider">
                    </div>

                    <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #1e2a3a;">
                        <div style="color: var(--accent); font-weight: bold; margin-bottom: 8px;">Shape Controls</div>

                        <div class="slider-group">
                            <label>Lake Size <span id="lake-size-val">40</span></label>
                            <input type="range" id="lake-size" min="10" max="100" value="40" class="alpha-slider">
                        </div>

                        <div class="slider-group">
                            <label>Box Size <span id="box-size-val">60</span></label>
                            <input type="range" id="box-size" min="20" max="120" value="60" class="alpha-slider">
                        </div>

                        <div class="slider-group">
                            <label>Radial Rings <span id="radial-rings-val">3</span></label>
                            <input type="range" id="radial-rings" min="1" max="6" value="3" class="alpha-slider">
                        </div>

                        <div class="slider-group">
                            <label>Points/Ring <span id="radial-points-val">6</span></label>
                            <input type="range" id="radial-points" min="3" max="12" value="6" class="alpha-slider">
                        </div>

                        <div class="slider-group">
                            <label>Link Width <span id="link-width-val">8</span></label>
                            <input type="range" id="link-width" min="2" max="20" value="8" class="alpha-slider">
                        </div>

                        <div class="slider-group">
                            <label>Link Curve <span id="link-curve-val">50</span></label>
                            <input type="range" id="link-curve" min="0" max="100" value="50" class="alpha-slider">
                        </div>
                    </div>
                </div>

                <!-- Preview Panel (3D Side View / Gallery Snapshot) -->
                <div class="preview-panel">
                    <div class="preview-label">
                        <span>Composite Preview (Top View)</span>
                        <button id="toggle-region-grid" class="tool-btn" style="margin-left: auto; font-size: 10px; padding: 4px 8px;">
                            📍 Show Region Grid
                        </button>
                    </div>
                    <div style="position: relative;">
                        <canvas id="preview-canvas" width="300" height="200"></canvas>
                        <canvas id="region-grid-canvas" width="300" height="200" style="position: absolute; top: 0; left: 0; pointer-events: all; cursor: pointer;"></canvas>
                    </div>
                    <div style="margin-top: 8px; font-size: 11px; color: var(--muted); text-align: center;">
                        <div id="region-info">
                            Editing: <span id="current-region-label" style="color: var(--accent);">Center (2,2)</span> |
                            Target: <span id="target-region-label" style="color: #ff3aa5;">Center (2,2)</span>
                        </div>
                        <div style="margin-top: 4px;">
                            Click grid to select import target
                        </div>
                    </div>
                </div>
            `;

            // Initialize the Simplified Nexus System
            initSimplifiedNexus();
        }

        function initSimplifiedNexus() {
            const canvas = document.getElementById('nx-canvas');
            const previewCanvas = document.getElementById('preview-canvas');
            const regionGridCanvas = document.getElementById('region-grid-canvas');
            const ctx = canvas.getContext('2d');
            const prevCtx = previewCanvas.getContext('2d');
            const regionCtx = regionGridCanvas.getContext('2d');

            const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            let W = 0, H = 0;

            // State
            let mode = 'pull'; // 'pull' or 'boundary'
            let tool = 'spawn'; // 'spawn', 'lake', 'box', 'radial', 'connect', 'select', 'drag', 'move', 'erase'
            let isDragging = false;
            let dragNode = null;
            let dragStartY = 0;
            let toolbarCollapsed = false;

            // Selection for boundary creation
            let selectedNodes = [];
            let connectStart = null;

            // Layer opacity settings
            let layerOpacity = {
                nodes: 1.0,
                links: 1.0,
                boundaries: 1.0,
                grid: 1.0
            };

            // Shape settings
            let shapeSettings = {
                lakeSize: 40,
                boxSize: 60,
                radialRings: 3,
                radialPoints: 6,
                linkWidth: 8,
                linkCurve: 50
            };

            // ============================================
            // ISOMETRIC VIEW STATE
            // ============================================
            let isometricAngle = 30; // degrees
            let rotationY = 45; // Y-axis rotation for perspective
            let zoomLevel = 1.0;
            let zoomedSide = null; // null, 'front', 'back', 'left', 'right'
            let cameraTransition = { active: false, progress: 0, from: {}, to: {} };

            // Isometric projection helper
            function toIsometric(x, y, z) {
                // Apply Y-axis rotation first
                const rotRad = rotationY * Math.PI / 180;
                const xRot = x * Math.cos(rotRad) + z * Math.sin(rotRad);
                const zRot = -x * Math.sin(rotRad) + z * Math.cos(rotRad);

                // Then apply isometric projection
                const angleRad = isometricAngle * Math.PI / 180;
                const isoX = xRot - zRot * Math.cos(angleRad);
                const isoY = y - zRot * Math.sin(angleRad);

                return { x: isoX, y: isoY };
            }

            // Transform canvas point to isometric space
            function screenToIso(screenX, screenY, z = 0) {
                // Center the view
                const centerX = W / 2;
                const centerY = H / 2;

                const x = (screenX - centerX) / zoomLevel;
                const y = (screenY - centerY) / zoomLevel;

                return toIsometric(x, y, z);
            }

            // Transform isometric point back to screen space
            function isoToScreen(x, y, z = 0) {
                const iso = toIsometric(x, y, z);
                const centerX = W / 2;
                const centerY = H / 2;

                return {
                    x: iso.x * zoomLevel + centerX,
                    y: iso.y * zoomLevel + centerY
                };
            }

            // ============================================
            // CANVAS SETUP
            // ============================================
            function setupCanvas(canvas) {
                const w = nexusContainer.clientWidth;
                const h = nexusContainer.clientHeight;
                canvas.width = Math.floor(w * DPR);
                canvas.height = Math.floor(h * DPR);
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                const c = canvas.getContext('2d');
                c.setTransform(DPR, 0, 0, DPR, 0, 0);
                return c;
            }

            function resizeCanvas() {
                W = nexusContainer.clientWidth;
                H = nexusContainer.clientHeight;
                setupCanvas(canvas);
                redraw();
            }

            const GRID_SIZE = 48; // Match main scene grid

            // ============================================
            // RENDERING
            // ============================================
            function drawGrid() {
                const gridAlpha = layerOpacity.grid;
                if (gridAlpha === 0) return;

                ctx.strokeStyle = `rgba(16, 224, 224, ${0.08 * gridAlpha})`;
                ctx.lineWidth = 1;

                // Vertical lines
                for (let x = 0.5; x < W; x += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, H);
                    ctx.stroke();
                }

                // Horizontal lines
                for (let y = 0.5; y < H; y += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(W, y);
                    ctx.stroke();
                }
            }

            function drawNodes() {
                const nodeAlpha = layerOpacity.nodes;
                if (nodeAlpha === 0) return;

                AppState.nexusGraph.nodes.forEach(node => {
                    // Transform to isometric space
                    const basePos = isoToScreen(node.x - W/2, node.y - H/2, 0);
                    const height = node.height || 0;
                    const topPos = isoToScreen(node.x - W/2, node.y - H/2 - height, 0);

                    // Draw vector influence arms if node is hovered or selected
                    if ((node.selected || node.hovered) && AppState.nexusGraph.edges.length > 0) {
                        drawVectorArms(node, basePos);
                    }

                    // Draw shape based on node type
                    const nodeType = node.type || 'node';

                    if (nodeType === 'lake') {
                        drawLakeNode(basePos, node, nodeAlpha);
                    } else if (nodeType === 'box') {
                        drawBoxNode(basePos, node, nodeAlpha);
                    } else {
                        drawStandardNode(basePos, topPos, node, height, nodeAlpha);
                    }
                });
            }

            function drawStandardNode(basePos, topPos, node, height, nodeAlpha) {
                // Draw pull height indicator if in pull mode
                if (mode === 'pull' && height > 0) {
                    // Draw vertical "string" to show height
                    ctx.strokeStyle = `rgba(16, 224, 224, ${0.6 * nodeAlpha})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(basePos.x, basePos.y);
                    ctx.lineTo(topPos.x, topPos.y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw peak indicator
                    ctx.fillStyle = node.selected ? `rgba(0, 255, 255, ${nodeAlpha})` : `rgba(255, 58, 165, ${nodeAlpha})`;
                    ctx.strokeStyle = `rgba(255, 136, 204, ${nodeAlpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(topPos.x, topPos.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Draw height label
                    ctx.fillStyle = `rgba(255, 255, 255, ${nodeAlpha})`;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${nodeAlpha * 0.8})`;
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 12px monospace';
                    ctx.strokeText(`${Math.round(height)}`, topPos.x + 12, topPos.y);
                    ctx.fillText(`${Math.round(height)}`, topPos.x + 12, topPos.y);
                }

                // Draw node base
                if (node.selected) {
                    ctx.fillStyle = `rgba(0, 255, 255, ${nodeAlpha})`;
                } else if (node.hovered) {
                    ctx.fillStyle = `rgba(0, 221, 255, ${nodeAlpha})`;
                } else {
                    ctx.fillStyle = `rgba(16, 224, 224, ${nodeAlpha})`;
                }
                ctx.strokeStyle = `rgba(10, 255, 255, ${nodeAlpha})`;
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.arc(basePos.x, basePos.y, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Draw shadow for depth perception
                if (height > 0) {
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.3 * nodeAlpha})`;
                    ctx.beginPath();
                    ctx.arc(basePos.x, basePos.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            function drawLakeNode(basePos, node, nodeAlpha) {
                const size = node.size || shapeSettings.lakeSize;

                // Draw water circle with gradient
                const gradient = ctx.createRadialGradient(basePos.x, basePos.y, 0, basePos.x, basePos.y, size);
                gradient.addColorStop(0, `rgba(100, 200, 255, ${0.6 * nodeAlpha})`);
                gradient.addColorStop(0.7, `rgba(50, 150, 255, ${0.4 * nodeAlpha})`);
                gradient.addColorStop(1, `rgba(16, 100, 200, ${0.2 * nodeAlpha})`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(basePos.x, basePos.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Draw shore outline
                ctx.strokeStyle = `rgba(100, 200, 255, ${nodeAlpha})`;
                ctx.lineWidth = node.selected ? 3 : 2;
                ctx.beginPath();
                ctx.arc(basePos.x, basePos.y, size, 0, Math.PI * 2);
                ctx.stroke();

                // Draw sparkles
                for (let i = 0; i < 3; i++) {
                    const angle = (Date.now() / 1000 + i * 2) % (Math.PI * 2);
                    const sparkleX = basePos.x + Math.cos(angle) * size * 0.5;
                    const sparkleY = basePos.y + Math.sin(angle) * size * 0.5;
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * nodeAlpha})`;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            function drawBoxNode(basePos, node, nodeAlpha) {
                const size = node.size || shapeSettings.boxSize;
                const halfSize = size / 2;

                // Draw box with isometric perspective
                ctx.fillStyle = node.selected ? `rgba(255, 200, 100, ${0.7 * nodeAlpha})` : `rgba(200, 150, 100, ${0.6 * nodeAlpha})`;
                ctx.strokeStyle = `rgba(255, 180, 80, ${nodeAlpha})`;
                ctx.lineWidth = node.selected ? 3 : 2;

                ctx.beginPath();
                ctx.rect(basePos.x - halfSize, basePos.y - halfSize, size, size);
                ctx.fill();
                ctx.stroke();

                // Draw inner detail
                ctx.strokeStyle = `rgba(255, 220, 150, ${0.5 * nodeAlpha})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.rect(basePos.x - halfSize * 0.7, basePos.y - halfSize * 0.7, size * 0.7, size * 0.7);
                ctx.stroke();
            }

            function drawVectorArms(node, nodePos) {
                // Find all connected nodes
                const connectedNodes = [];
                AppState.nexusGraph.edges.forEach(edge => {
                    if (edge.nodeA === node) connectedNodes.push(edge.nodeB);
                    if (edge.nodeB === node) connectedNodes.push(edge.nodeA);
                });

                if (connectedNodes.length === 0) return;

                // Draw influence gradient
                const gradient = ctx.createRadialGradient(nodePos.x, nodePos.y, 0, nodePos.x, nodePos.y, 150);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.15)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(nodePos.x, nodePos.y, 150, 0, Math.PI * 2);
                ctx.fill();

                // Draw vector arms to connected nodes
                connectedNodes.forEach(connectedNode => {
                    const connectedPos = isoToScreen(connectedNode.x - W/2, connectedNode.y - H/2, 0);

                    // Draw dashed line
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 4]);
                    ctx.beginPath();
                    ctx.moveTo(nodePos.x, nodePos.y);
                    ctx.lineTo(connectedPos.x, connectedPos.y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw influence sphere at connected node
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                    ctx.beginPath();
                    ctx.arc(connectedPos.x, connectedPos.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function drawEdges() {
                const linkAlpha = layerOpacity.links;
                if (linkAlpha === 0) return; // Skip if invisible

                AppState.nexusGraph.edges.forEach(edge => {
                    if (!edge.nodeA || !edge.nodeB) return;

                    // Transform both nodes to isometric space
                    const posA = isoToScreen(edge.nodeA.x - W/2, edge.nodeA.y - H/2, -(edge.nodeA.height || 0));
                    const posB = isoToScreen(edge.nodeB.x - W/2, edge.nodeB.y - H/2, -(edge.nodeB.height || 0));

                    // Draw curved ribbon link
                    drawCurvedRibbon(posA, posB, edge.nodeA, edge.nodeB);
                });
            }

            function drawCurvedRibbon(posA, posB, nodeA, nodeB) {
                const linkAlpha = layerOpacity.links;
                const linkWidth = shapeSettings.linkWidth;
                const curveFactor = shapeSettings.linkCurve / 100;

                // Calculate control point for Bezier curve
                const midX = (posA.x + posB.x) / 2;
                const midY = (posA.y + posB.y) / 2;
                const dx = posB.x - posA.x;
                const dy = posB.y - posB.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Perpendicular offset for curve
                const offsetAmount = distance * curveFactor * 0.3;
                const perpX = -dy;
                const perpY = dx;
                const perpLength = Math.sqrt(perpX * perpX + perpY * perpY) || 1;
                const controlX = midX + (perpX / perpLength) * offsetAmount;
                const controlY = midY + (perpY / perpLength) * offsetAmount;

                // Draw ribbon with gradient (simulating depth)
                const heightA = nodeA.height || 0;
                const heightB = nodeB.height || 0;
                const heightDiff = Math.abs(heightA - heightB);

                // Create gradient along curve
                const gradient = ctx.createLinearGradient(posA.x, posA.y, posB.x, posB.y);

                if (heightDiff > 5) {
                    // Height-based gradient (cyan to pink)
                    gradient.addColorStop(0, `rgba(16, 224, 224, ${linkAlpha * 0.8})`);
                    gradient.addColorStop(0.5, `rgba(135, 141, 219, ${linkAlpha * 0.6})`);
                    gradient.addColorStop(1, `rgba(255, 58, 165, ${linkAlpha * 0.8})`);
                } else {
                    // Depth gradient (darker in middle)
                    gradient.addColorStop(0, `rgba(16, 224, 224, ${linkAlpha * 0.9})`);
                    gradient.addColorStop(0.5, `rgba(16, 224, 224, ${linkAlpha * 0.5})`);
                    gradient.addColorStop(1, `rgba(16, 224, 224, ${linkAlpha * 0.9})`);
                }

                // Draw ribbon as thick curved stroke
                ctx.strokeStyle = gradient;
                ctx.lineWidth = linkWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(posA.x, posA.y);
                ctx.quadraticCurveTo(controlX, controlY, posB.x, posB.y);
                ctx.stroke();

                // Draw highlight edge for 3D effect
                ctx.strokeStyle = `rgba(255, 255, 255, ${linkAlpha * 0.3})`;
                ctx.lineWidth = Math.max(1, linkWidth * 0.2);
                ctx.beginPath();
                ctx.moveTo(posA.x, posA.y);
                ctx.quadraticCurveTo(controlX, controlY, posB.x, posB.y);
                ctx.stroke();

                // Draw shadow edge
                ctx.strokeStyle = `rgba(0, 0, 0, ${linkAlpha * 0.4})`;
                ctx.lineWidth = Math.max(1, linkWidth * 0.15);
                ctx.beginPath();
                ctx.moveTo(posA.x, posA.y + 1);
                ctx.quadraticCurveTo(controlX, controlY + 1, posB.x, posB.y + 1);
                ctx.stroke();
            }

            function drawBoundaries() {
                const boundaryAlpha = layerOpacity.boundaries;
                if (boundaryAlpha === 0) return;

                AppState.nexusGraph.boundaries.forEach((boundary, idx) => {
                    if (boundary.nodes.length < 3) return;

                    const isSelected = AppState.nexusGraph.selectedBoundary === boundary.id;

                    // Draw filled polygon in isometric space
                    ctx.fillStyle = isSelected
                        ? `rgba(255, 58, 165, ${0.15 * boundaryAlpha})`
                        : `rgba(255, 58, 165, ${0.08 * boundaryAlpha})`;
                    ctx.strokeStyle = isSelected
                        ? `rgba(255, 58, 165, ${boundaryAlpha})`
                        : `rgba(255, 58, 165, ${0.5 * boundaryAlpha})`;
                    ctx.lineWidth = isSelected ? 3 : 2;

                    ctx.beginPath();
                    boundary.nodes.forEach((node, i) => {
                        const pos = isoToScreen(node.x - W/2, node.y - H/2, 0);
                        if (i === 0) ctx.moveTo(pos.x, pos.y);
                        else ctx.lineTo(pos.x, pos.y);
                    });
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Draw boundary label at center
                    const centerX = boundary.nodes.reduce((sum, n) => sum + n.x, 0) / boundary.nodes.length;
                    const centerY = boundary.nodes.reduce((sum, n) => sum + n.y, 0) / boundary.nodes.length;
                    const centerPos = isoToScreen(centerX - W/2, centerY - H/2, 0);

                    ctx.fillStyle = `rgba(255, 58, 165, ${boundaryAlpha})`;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.8 * boundaryAlpha})`;
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 12px monospace';
                    ctx.strokeText(`Boundary ${idx + 1}`, centerPos.x - 40, centerPos.y);
                    ctx.fillText(`Boundary ${idx + 1}`, centerPos.x - 40, centerPos.y);
                });
            }

            function drawSelectionHighlights() {
                if (tool === 'select') {
                    selectedNodes.forEach(node => {
                        const pos = isoToScreen(node.x - W/2, node.y - H/2, 0);
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, 12, 0, Math.PI * 2);
                        ctx.stroke();
                    });
                }
            }

            function redraw() {
                ctx.clearRect(0, 0, W, H);
                drawGrid();
                drawBoundaries();
                drawEdges();
                drawNodes();
                drawSelectionHighlights();
                updatePreview();
                updateInfoPanel();
                drawRegionGrid();
                updateRegionLabels();
            }

            // ============================================
            // PREVIEW RENDERING
            // ============================================
            function updatePreview() {
                prevCtx.fillStyle = '#000';
                prevCtx.fillRect(0, 0, 300, 200);

                if (AppState.nexusGraph.nodes.length === 0) {
                    prevCtx.fillStyle = '#666';
                    prevCtx.font = '12px sans-serif';
                    prevCtx.textAlign = 'center';
                    prevCtx.fillText('No data yet', 150, 100);
                    return;
                }

                // Draw miniature version
                const scaleX = 280 / W;
                const scaleY = 180 / H;
                const scale = Math.min(scaleX, scaleY);
                const offsetX = (300 - W * scale) / 2;
                const offsetY = (200 - H * scale) / 2;

                prevCtx.save();
                prevCtx.translate(offsetX, offsetY);
                prevCtx.scale(scale, scale);

                // Draw boundaries
                AppState.nexusGraph.boundaries.forEach(boundary => {
                    if (boundary.nodes.length < 3) return;
                    prevCtx.fillStyle = 'rgba(255, 58, 165, 0.3)';
                    prevCtx.beginPath();
                    boundary.nodes.forEach((node, i) => {
                        if (i === 0) prevCtx.moveTo(node.x, node.y);
                        else prevCtx.lineTo(node.x, node.y);
                    });
                    prevCtx.closePath();
                    prevCtx.fill();
                });

                // Draw edges
                prevCtx.strokeStyle = '#10e0e0';
                prevCtx.lineWidth = 1.5;
                AppState.nexusGraph.edges.forEach(edge => {
                    if (!edge.nodeA || !edge.nodeB) return;
                    prevCtx.beginPath();
                    prevCtx.moveTo(edge.nodeA.x, edge.nodeA.y);
                    prevCtx.lineTo(edge.nodeB.x, edge.nodeB.y);
                    prevCtx.stroke();
                });

                // Draw nodes
                AppState.nexusGraph.nodes.forEach(node => {
                    prevCtx.fillStyle = '#10e0e0';
                    prevCtx.beginPath();
                    prevCtx.arc(node.x, node.y, 3, 0, Math.PI * 2);
                    prevCtx.fill();

                    if (mode === 'pull' && node.height && node.height > 0) {
                        prevCtx.fillStyle = '#ff3aa5';
                        prevCtx.beginPath();
                        prevCtx.arc(node.x, node.y, 2, 0, Math.PI * 2);
                        prevCtx.fill();
                    }
                });

                prevCtx.restore();
            }

            // ============================================
            // REGION GRID OVERLAY
            // ============================================
            function drawRegionGrid() {
                if (!AppState.masterGrid.showPreviewGrid) {
                    regionCtx.clearRect(0, 0, 300, 200);
                    return;
                }

                regionCtx.clearRect(0, 0, 300, 200);

                const gridW = AppState.masterGrid.gridWidth;
                const gridH = AppState.masterGrid.gridHeight;
                const cellW = 300 / gridW;
                const cellH = 200 / gridH;

                // Draw grid cells
                for (let y = 0; y < gridH; y++) {
                    for (let x = 0; x < gridW; x++) {
                        const screenX = x * cellW;
                        const screenY = y * cellH;

                        // Check if this cell has saved data
                        const hasData = AppState.masterGrid.regions[`${x},${y}`] !== undefined;

                        // Highlight current editing region
                        const isCurrent = (x === AppState.masterGrid.currentRegion.x &&
                                          y === AppState.masterGrid.currentRegion.y);

                        // Highlight target import region
                        const isTarget = (x === AppState.masterGrid.targetRegion.x &&
                                         y === AppState.masterGrid.targetRegion.y);

                        // Fill cell
                        if (isCurrent) {
                            regionCtx.fillStyle = 'rgba(16, 224, 224, 0.3)'; // Cyan - editing
                        } else if (isTarget) {
                            regionCtx.fillStyle = 'rgba(255, 58, 165, 0.3)'; // Pink - target
                        } else if (hasData) {
                            regionCtx.fillStyle = 'rgba(100, 200, 100, 0.2)'; // Green - has data
                        } else {
                            regionCtx.fillStyle = 'rgba(50, 50, 50, 0.4)'; // Gray - empty
                        }
                        regionCtx.fillRect(screenX, screenY, cellW, cellH);

                        // Draw cell border
                        regionCtx.strokeStyle = isCurrent ? '#10e0e0' : isTarget ? '#ff3aa5' : '#444';
                        regionCtx.lineWidth = isCurrent || isTarget ? 2 : 1;
                        regionCtx.strokeRect(screenX, screenY, cellW, cellH);

                        // Draw cell coordinates
                        regionCtx.fillStyle = '#fff';
                        regionCtx.font = '10px monospace';
                        regionCtx.textAlign = 'center';
                        regionCtx.fillText(`${x},${y}`, screenX + cellW/2, screenY + cellH/2);
                    }
                }

                // Draw legend
                regionCtx.textAlign = 'left';
                regionCtx.font = 'bold 9px sans-serif';
                regionCtx.fillStyle = '#10e0e0';
                regionCtx.fillText('■ Editing', 5, 12);
                regionCtx.fillStyle = '#ff3aa5';
                regionCtx.fillText('■ Target', 5, 24);
            }

            function updateRegionLabels() {
                const curr = AppState.masterGrid.currentRegion;
                const targ = AppState.masterGrid.targetRegion;
                document.getElementById('current-region-label').textContent =
                    `(${curr.x},${curr.y})`;
                document.getElementById('target-region-label').textContent =
                    `(${targ.x},${targ.y})`;
            }

            // ============================================
            // INFO PANEL UPDATES
            // ============================================
            function updateInfoPanel() {
                document.getElementById('info-mode').textContent = mode === 'pull' ? 'Pull Mountains' : 'Draw Boundaries';
                document.getElementById('info-nodes').textContent = AppState.nexusGraph.nodes.length;
                document.getElementById('info-connections').textContent = AppState.nexusGraph.edges.length;
                document.getElementById('info-boundaries').textContent = AppState.nexusGraph.boundaries.length;

                if (dragNode) {
                    document.getElementById('info-selected').textContent = `Node #${dragNode.id.replace('n-', '')}`;
                } else if (selectedNodes.length > 0) {
                    document.getElementById('info-selected').textContent = `${selectedNodes.length} nodes`;
                } else {
                    document.getElementById('info-selected').textContent = 'None';
                }
            }

            // ============================================
            // NODE MANAGEMENT
            // ============================================
            function findNodeAt(screenX, screenY, radius = 15) {
                // Find node by checking distance in screen space (after isometric projection)
                return AppState.nexusGraph.nodes.find(node => {
                    const nodeScreenPos = isoToScreen(node.x - W/2, node.y - H/2, 0);
                    const dx = nodeScreenPos.x - screenX;
                    const dy = nodeScreenPos.y - screenY;
                    return Math.sqrt(dx * dx + dy * dy) < radius;
                });
            }

            function spawnNode(x, y) {
                const nodeId = 'n-' + AppState.nexusGraph.nodeIdCounter++;
                const node = { id: nodeId, x, y, height: 0, selected: false, type: 'node' };

                // Create 3D marker
                const worldPos = screenToWorld3D(x, y, W, H);
                node.mesh3D = createNodeMarker(worldPos);

                AppState.nexusGraph.nodes.push(node);
                redraw();
                showToast(`✅ Node spawned at (${Math.round(x)}, ${Math.round(y)})`, 'success');
            }

            function spawnLake(x, y) {
                const nodeId = 'n-' + AppState.nexusGraph.nodeIdCounter++;
                const node = {
                    id: nodeId,
                    x,
                    y,
                    height: 0,
                    selected: false,
                    type: 'lake',
                    size: shapeSettings.lakeSize
                };

                AppState.nexusGraph.nodes.push(node);
                redraw();
                showToast(`🌊 Lake created at (${Math.round(x)}, ${Math.round(y)})`, 'success');
            }

            function spawnBox(x, y) {
                const nodeId = 'n-' + AppState.nexusGraph.nodeIdCounter++;
                const node = {
                    id: nodeId,
                    x,
                    y,
                    height: 0,
                    selected: false,
                    type: 'box',
                    size: shapeSettings.boxSize
                };

                AppState.nexusGraph.nodes.push(node);
                redraw();
                showToast(`⬜ Box spawned at (${Math.round(x)}, ${Math.round(y)})`, 'success');
            }

            function spawnRadial(x, y) {
                const rings = shapeSettings.radialRings;
                const pointsPerRing = shapeSettings.radialPoints;
                const baseRadius = 40;

                // Create center node
                const centerNode = {
                    id: 'n-' + AppState.nexusGraph.nodeIdCounter++,
                    x, y, height: 0, selected: false, type: 'node'
                };
                AppState.nexusGraph.nodes.push(centerNode);

                // Create rings of nodes
                for (let ring = 1; ring <= rings; ring++) {
                    const radius = baseRadius * ring;
                    const angleStep = (Math.PI * 2) / pointsPerRing;

                    for (let point = 0; point < pointsPerRing; point++) {
                        const angle = angleStep * point;
                        const nodeX = x + Math.cos(angle) * radius;
                        const nodeY = y + Math.sin(angle) * radius;

                        const node = {
                            id: 'n-' + AppState.nexusGraph.nodeIdCounter++,
                            x: nodeX,
                            y: nodeY,
                            height: 0,
                            selected: false,
                            type: 'node'
                        };
                        AppState.nexusGraph.nodes.push(node);

                        // Connect to center if first ring
                        if (ring === 1) {
                            AppState.nexusGraph.edges.push({
                                id: 'e-' + Date.now() + '-' + point,
                                nodeA: centerNode,
                                nodeB: node
                            });
                        }
                    }
                }

                redraw();
                showToast(`✨ Radial structure created (${rings} rings, ${pointsPerRing} points/ring)`, 'success');
            }

            function eraseNode(node) {
                // Remove all edges connected to this node
                AppState.nexusGraph.edges = AppState.nexusGraph.edges.filter(edge =>
                    edge.nodeA !== node && edge.nodeB !== node
                );

                // Remove from boundaries
                AppState.nexusGraph.boundaries.forEach(boundary => {
                    boundary.nodes = boundary.nodes.filter(n => n !== node);
                });

                // Remove boundaries with less than 3 nodes
                AppState.nexusGraph.boundaries = AppState.nexusGraph.boundaries.filter(b => b.nodes.length >= 3);

                // Remove from selected nodes
                selectedNodes = selectedNodes.filter(n => n !== node);

                // Remove the node itself
                AppState.nexusGraph.nodes = AppState.nexusGraph.nodes.filter(n => n !== node);

                redraw();
                showToast('🧹 Node erased', 'success');
            }

            function createConnection(nodeA, nodeB) {
                if (nodeA === nodeB) return;

                // Check if edge already exists
                const exists = AppState.nexusGraph.edges.some(e =>
                    (e.nodeA === nodeA && e.nodeB === nodeB) ||
                    (e.nodeA === nodeB && e.nodeB === nodeA)
                );

                if (exists) {
                    showToast('⚠️ Connection already exists', 'warning');
                    return;
                }

                const edge = { nodeA, nodeB };
                edge.line3D = createEdgeLine(nodeA, nodeB);
                AppState.nexusGraph.edges.push(edge);
                redraw();
                showToast('✅ Nodes connected', 'success');
            }

            function createBoundaryFromSelected() {
                if (selectedNodes.length < 3) {
                    showToast('❌ Select at least 3 nodes!', 'error');
                    return;
                }

                const boundaryId = 'boundary-' + Date.now();
                const boundary = {
                    id: boundaryId,
                    nodes: [...selectedNodes]
                };

                // Create 3D plane
                boundary.mesh3D = createBoundaryPlane(selectedNodes);
                AppState.nexusGraph.boundaries.push(boundary);
                AppState.nexusGraph.selectedBoundary = boundaryId;

                selectedNodes = [];
                redraw();
                showToast(`✅ Boundary ${AppState.nexusGraph.boundaries.length} created!`, 'success');
                updateBoundaryStatus();
            }

            // ============================================
            // PULL MODE (Mountain Creation)
            // ============================================
            function pullNode(node, deltaY) {
                if (!node.height) node.height = 0;

                // Update height (drag up = positive height)
                node.height = Math.max(0, node.height - deltaY);

                // Update 3D position
                if (node.mesh3D) {
                    const worldPos = screenToWorld3D(node.x, node.y, W, H);
                    node.mesh3D.position.set(worldPos.x, 1 + (node.height * 0.1), worldPos.z);
                }

                // Update connected edges in 3D
                AppState.nexusGraph.edges.forEach(edge => {
                    if (edge.nodeA === node || edge.nodeB === node) {
                        updateEdgeLine(edge);
                    }
                });

                redraw();
            }

            // ============================================
            // MOUSE EVENTS
            // ============================================
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            canvas.addEventListener('mousedown', (e) => {
                const pos = getMousePos(e);
                const node = findNodeAt(pos.x, pos.y);

                if (tool === 'move' && node) {
                    // Move mode: drag node in XY plane
                    isDragging = true;
                    dragNode = node;
                    dragNode.dragOffsetX = pos.x - node.x;
                    dragNode.dragOffsetY = pos.y - node.y;
                    canvas.style.cursor = 'grabbing';
                } else if (mode === 'pull' && node) {
                    // Pull mode: drag to create mountains
                    isDragging = true;
                    dragNode = node;
                    dragStartY = pos.y;
                    canvas.style.cursor = 'ns-resize';
                } else if (mode === 'boundary') {
                    // Boundary mode - Shape spawning
                    if (tool === 'spawn') {
                        spawnNode(pos.x, pos.y);
                    } else if (tool === 'lake') {
                        spawnLake(pos.x, pos.y);
                    } else if (tool === 'box') {
                        spawnBox(pos.x, pos.y);
                    } else if (tool === 'radial') {
                        spawnRadial(pos.x, pos.y);
                    } else if (tool === 'erase' && node) {
                        // Erase mode: remove node
                        eraseNode(node);
                    } else if (tool === 'connect' && node) {
                        // Connect nodes
                        if (!connectStart) {
                            connectStart = node;
                            showToast('🔗 Click another node to connect', 'info');
                        } else {
                            createConnection(connectStart, node);
                            connectStart = null;
                        }
                    } else if (tool === 'select' && node) {
                        // Toggle node selection
                        if (selectedNodes.includes(node)) {
                            selectedNodes = selectedNodes.filter(n => n !== node);
                        } else {
                            selectedNodes.push(node);
                        }
                        redraw();
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);

                if (isDragging && dragNode) {
                    if (tool === 'move') {
                        // Move node in XY plane while keeping connections
                        dragNode.x = pos.x - (dragNode.dragOffsetX || 0);
                        dragNode.y = pos.y - (dragNode.dragOffsetY || 0);
                        redraw();
                    } else if (mode === 'pull') {
                        // Pull node vertically
                        const deltaY = pos.y - dragStartY;
                        pullNode(dragNode, deltaY);
                        dragStartY = pos.y;
                    }
                } else {
                    // Update hover state and cursor
                    AppState.nexusGraph.nodes.forEach(n => n.hovered = false);
                    const node = findNodeAt(pos.x, pos.y);

                    if (node) {
                        node.hovered = true;
                        if (tool === 'move') {
                            canvas.style.cursor = 'grab';
                        } else if (mode === 'pull') {
                            canvas.style.cursor = 'ns-resize';
                        } else {
                            canvas.style.cursor = 'pointer';
                        }
                    } else {
                        canvas.style.cursor = tool === 'spawn' ? 'crosshair' : 'default';
                    }

                    redraw();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                dragNode = null;
                canvas.style.cursor = 'default';
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                dragNode = null;
            });

            // ============================================
            // TOOLBAR CONTROLS
            // ============================================
            document.getElementById('toolbar-toggle').addEventListener('click', () => {
                toolbarCollapsed = !toolbarCollapsed;
                const toolbar = document.getElementById('nx-toolbar');
                const toggle = document.getElementById('toolbar-toggle');

                toolbar.classList.toggle('collapsed', toolbarCollapsed);
                toggle.textContent = toolbarCollapsed ? '▲ Show Toolbar' : '▼ Hide Toolbar';
            });

            document.getElementById('nx-mode-pull').addEventListener('click', () => {
                mode = 'pull';
                document.getElementById('nx-mode-pull').classList.add('active');
                document.getElementById('nx-mode-boundary').classList.remove('active');
                showToast('⛰️ Pull Mode: Drag nodes to create mountains', 'info');
                redraw();
            });

            document.getElementById('nx-mode-boundary').addEventListener('click', () => {
                mode = 'boundary';
                document.getElementById('nx-mode-pull').classList.remove('active');
                document.getElementById('nx-mode-boundary').classList.add('active');
                showToast('📐 Boundary Mode: Create regions for terrain', 'info');
                redraw();
            });

            document.getElementById('nx-spawn-node').addEventListener('click', () => {
                tool = 'spawn';
                updateToolButtons();
                showToast('➕ Click on canvas to spawn nodes', 'info');
            });

            document.getElementById('nx-spawn-lake').addEventListener('click', () => {
                tool = 'lake';
                updateToolButtons();
                showToast('🌊 Click to create lake (circle water feature)', 'info');
            });

            document.getElementById('nx-spawn-box').addEventListener('click', () => {
                tool = 'box';
                updateToolButtons();
                showToast('⬜ Click to spawn box structure', 'info');
            });

            document.getElementById('nx-spawn-radial').addEventListener('click', () => {
                tool = 'radial';
                updateToolButtons();
                showToast('✨ Click to create radial ring structure', 'info');
            });

            document.getElementById('nx-connect').addEventListener('click', () => {
                tool = 'connect';
                connectStart = null;
                updateToolButtons();
                showToast('🔗 Click two nodes to connect them', 'info');
            });

            document.getElementById('nx-move-node').addEventListener('click', () => {
                tool = 'move';
                updateToolButtons();
                showToast('✋ Move Mode: Drag nodes while keeping connections', 'info');
            });

            document.getElementById('nx-erase').addEventListener('click', () => {
                tool = 'erase';
                updateToolButtons();
                showToast('🧹 Click nodes or edges to erase them', 'info');
            });

            document.getElementById('nx-select').addEventListener('click', () => {
                tool = 'select';
                updateToolButtons();
                showToast('🎯 Click nodes to select for boundary creation', 'info');
            });

            document.getElementById('nx-create-boundary').addEventListener('click', () => {
                createBoundaryFromSelected();
            });

            // ============================================
            // ZOOM CONTROLS
            // ============================================
            document.getElementById('nx-zoom-front').addEventListener('click', () => {
                animateCameraTo({ rotationY: 0, zoomLevel: 1.5, side: 'front' });
                showToast('🔍 Front View', 'info');
            });

            document.getElementById('nx-zoom-right').addEventListener('click', () => {
                animateCameraTo({ rotationY: 90, zoomLevel: 1.5, side: 'right' });
                showToast('🔍 Right View', 'info');
            });

            document.getElementById('nx-zoom-back').addEventListener('click', () => {
                animateCameraTo({ rotationY: 180, zoomLevel: 1.5, side: 'back' });
                showToast('🔍 Back View', 'info');
            });

            document.getElementById('nx-zoom-left').addEventListener('click', () => {
                animateCameraTo({ rotationY: 270, zoomLevel: 1.5, side: 'left' });
                showToast('🔍 Left View', 'info');
            });

            document.getElementById('nx-zoom-reset').addEventListener('click', () => {
                animateCameraTo({ rotationY: 45, zoomLevel: 1.0, side: null });
                showToast('🔄 View Reset', 'info');
            });

            function animateCameraTo(target) {
                cameraTransition = {
                    active: true,
                    progress: 0,
                    from: {
                        rotationY: rotationY,
                        zoomLevel: zoomLevel
                    },
                    to: target,
                    duration: 500 // milliseconds
                };

                zoomedSide = target.side;
                animateCamera();
            }

            function animateCamera() {
                if (!cameraTransition.active) return;

                const startTime = performance.now();
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    cameraTransition.progress = Math.min(elapsed / cameraTransition.duration, 1);

                    // Easing function (easeInOutCubic)
                    const t = cameraTransition.progress < 0.5
                        ? 4 * Math.pow(cameraTransition.progress, 3)
                        : 1 - Math.pow(-2 * cameraTransition.progress + 2, 3) / 2;

                    // Interpolate camera properties
                    rotationY = cameraTransition.from.rotationY +
                                (cameraTransition.to.rotationY - cameraTransition.from.rotationY) * t;
                    zoomLevel = cameraTransition.from.zoomLevel +
                                (cameraTransition.to.zoomLevel - cameraTransition.from.zoomLevel) * t;

                    redraw();

                    if (cameraTransition.progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        cameraTransition.active = false;
                    }
                };

                requestAnimationFrame(animate);
            }

            document.getElementById('nx-clear-all').addEventListener('click', () => {
                if (confirm('⚠️ Clear all nodes, connections, and boundaries?')) {
                    clearNexusGraph();
                    redraw();
                    showToast('🗑️ Nexus Lab cleared', 'success');
                }
            });

            // ============================================
            // LAYER OPACITY SLIDERS
            // ============================================
            document.getElementById('nodes-alpha').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                layerOpacity.nodes = value / 100;
                document.getElementById('nodes-alpha-val').textContent = `${value}%`;
                redraw();
            });

            document.getElementById('links-alpha').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                layerOpacity.links = value / 100;
                document.getElementById('links-alpha-val').textContent = `${value}%`;
                redraw();
            });

            document.getElementById('boundaries-alpha').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                layerOpacity.boundaries = value / 100;
                document.getElementById('boundaries-alpha-val').textContent = `${value}%`;
                redraw();
            });

            document.getElementById('grid-alpha').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                layerOpacity.grid = value / 100;
                document.getElementById('grid-alpha-val').textContent = `${value}%`;
                redraw();
            });

            // ============================================
            // SHAPE CONTROL SLIDERS
            // ============================================
            document.getElementById('lake-size').addEventListener('input', (e) => {
                shapeSettings.lakeSize = parseInt(e.target.value);
                document.getElementById('lake-size-val').textContent = e.target.value;
                redraw();
            });

            document.getElementById('box-size').addEventListener('input', (e) => {
                shapeSettings.boxSize = parseInt(e.target.value);
                document.getElementById('box-size-val').textContent = e.target.value;
                redraw();
            });

            document.getElementById('radial-rings').addEventListener('input', (e) => {
                shapeSettings.radialRings = parseInt(e.target.value);
                document.getElementById('radial-rings-val').textContent = e.target.value;
            });

            document.getElementById('radial-points').addEventListener('input', (e) => {
                shapeSettings.radialPoints = parseInt(e.target.value);
                document.getElementById('radial-points-val').textContent = e.target.value;
            });

            document.getElementById('link-width').addEventListener('input', (e) => {
                shapeSettings.linkWidth = parseInt(e.target.value);
                document.getElementById('link-width-val').textContent = e.target.value;
                redraw();
            });

            document.getElementById('link-curve').addEventListener('input', (e) => {
                shapeSettings.linkCurve = parseInt(e.target.value);
                document.getElementById('link-curve-val').textContent = e.target.value;
                redraw();
            });

            // ============================================
            // REGION GRID CONTROLS
            // ============================================
            document.getElementById('toggle-region-grid').addEventListener('click', () => {
                AppState.masterGrid.showPreviewGrid = !AppState.masterGrid.showPreviewGrid;
                const btn = document.getElementById('toggle-region-grid');
                btn.textContent = AppState.masterGrid.showPreviewGrid ? '📍 Hide Grid' : '📍 Show Region Grid';
                drawRegionGrid();
            });

            regionGridCanvas.addEventListener('click', (e) => {
                if (!AppState.masterGrid.showPreviewGrid) return;

                const rect = regionGridCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const gridW = AppState.masterGrid.gridWidth;
                const gridH = AppState.masterGrid.gridHeight;
                const cellW = 300 / gridW;
                const cellH = 200 / gridH;

                const gridX = Math.floor(x / cellW);
                const gridY = Math.floor(y / cellH);

                if (gridX >= 0 && gridX < gridW && gridY >= 0 && gridY < gridH) {
                    AppState.masterGrid.targetRegion = { x: gridX, y: gridY };
                    drawRegionGrid();
                    updateRegionLabels();
                    showToast(`🎯 Target region set to (${gridX}, ${gridY})`, 'info');
                }
            });

            document.getElementById('nx-save-to-region').addEventListener('click', () => {
                saveToRegion();
            });

            document.getElementById('nx-load-from-region').addEventListener('click', () => {
                loadFromRegion();
            });

            function saveToRegion() {
                if (AppState.nexusGraph.nodes.length === 0) {
                    showToast('❌ Create some nodes first!', 'error');
                    return;
                }

                const target = AppState.masterGrid.targetRegion;
                const regionKey = `${target.x},${target.y}`;

                // Deep clone current graph data
                const graphData = {
                    nodes: JSON.parse(JSON.stringify(AppState.nexusGraph.nodes.map(n => ({
                        id: n.id,
                        x: n.x,
                        y: n.y,
                        height: n.height || 0
                    })))),
                    edges: JSON.parse(JSON.stringify(AppState.nexusGraph.edges.map(e => ({
                        id: e.id,
                        nodeAId: e.nodeA.id,
                        nodeBId: e.nodeB.id
                    })))),
                    boundaries: JSON.parse(JSON.stringify(AppState.nexusGraph.boundaries.map(b => ({
                        id: b.id,
                        nodeIds: b.nodes.map(n => n.id)
                    })))),
                    rotation: rotationY, // Save current viewing angle
                    timestamp: Date.now()
                };

                // Save to master grid
                AppState.masterGrid.regions[regionKey] = graphData;

                // TODO: Generate 3D terrain mesh and place it in the 3D scene at the target region
                generateTerrainFromGraph(graphData, target);

                drawRegionGrid();
                showToast(`💾 Saved to region (${target.x}, ${target.y})`, 'success');
            }

            function loadFromRegion() {
                const target = AppState.masterGrid.targetRegion;
                const regionKey = `${target.x},${target.y}`;
                const graphData = AppState.masterGrid.regions[regionKey];

                if (!graphData) {
                    showToast(`❌ No data in region (${target.x}, ${target.y})`, 'error');
                    return;
                }

                // Clear current graph
                clearNexusGraph();

                // Restore nodes
                graphData.nodes.forEach(nodeData => {
                    const node = {
                        id: nodeData.id,
                        x: nodeData.x,
                        y: nodeData.y,
                        height: nodeData.height || 0,
                        selected: false,
                        hovered: false
                    };
                    AppState.nexusGraph.nodes.push(node);
                });

                // Restore edges
                graphData.edges.forEach(edgeData => {
                    const nodeA = AppState.nexusGraph.nodes.find(n => n.id === edgeData.nodeAId);
                    const nodeB = AppState.nexusGraph.nodes.find(n => n.id === edgeData.nodeBId);
                    if (nodeA && nodeB) {
                        AppState.nexusGraph.edges.push({
                            id: edgeData.id,
                            nodeA: nodeA,
                            nodeB: nodeB
                        });
                    }
                });

                // Restore boundaries
                graphData.boundaries.forEach(boundaryData => {
                    const nodes = boundaryData.nodeIds
                        .map(id => AppState.nexusGraph.nodes.find(n => n.id === id))
                        .filter(n => n !== undefined);
                    if (nodes.length >= 3) {
                        AppState.nexusGraph.boundaries.push({
                            id: boundaryData.id,
                            nodes: nodes
                        });
                    }
                });

                // Restore camera rotation
                if (graphData.rotation !== undefined) {
                    rotationY = graphData.rotation;
                }

                // Update current region
                AppState.masterGrid.currentRegion = { x: target.x, y: target.y };
                updateRegionLabels();

                redraw();
                showToast(`� Loaded region (${target.x}, ${target.y})`, 'success');
            }

            function generateTerrainFromGraph(graphData, regionCoords) {
                // Calculate world position for this region
                const cellSize = AppState.masterGrid.cellSize;
                const offsetX = (regionCoords.x - 2) * cellSize; // Center is (2,2)
                const offsetZ = (regionCoords.y - 2) * cellSize;

                // TODO: Create actual 3D terrain mesh from nodes/boundaries
                // For now, just create markers at node positions
                graphData.nodes.forEach(node => {
                    const worldX = offsetX + (node.x - W/2) * 0.5; // Scale to world units
                    const worldZ = offsetZ + (node.y - H/2) * 0.5;
                    const worldY = node.height * 0.1; // Scale height

                    // Create visual marker (small cube)
                    const geometry = new THREE.BoxGeometry(4, node.height * 0.1 + 4, 4);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x10e0e0,
                        emissive: 0x10e0e0,
                        emissiveIntensity: 0.3
                    });
                    const marker = new THREE.Mesh(geometry, material);
                    marker.position.set(worldX, worldY / 2, worldZ);
                    marker.userData.isNexusMarker = true;
                    marker.userData.regionCoords = regionCoords;
                    AppState.scene.add(marker);
                });

                console.log(`Generated terrain markers for region (${regionCoords.x}, ${regionCoords.y})`);
            }

            function updateToolButtons() {
                document.getElementById('nx-spawn-node').classList.toggle('active', tool === 'spawn');
                document.getElementById('nx-spawn-lake').classList.toggle('active', tool === 'lake');
                document.getElementById('nx-spawn-box').classList.toggle('active', tool === 'box');
                document.getElementById('nx-spawn-radial').classList.toggle('active', tool === 'radial');
                document.getElementById('nx-connect').classList.toggle('active', tool === 'connect');
                document.getElementById('nx-move-node').classList.toggle('active', tool === 'move');
                document.getElementById('nx-erase').classList.toggle('active', tool === 'erase');
                document.getElementById('nx-select').classList.toggle('active', tool === 'select');
            }

            // ============================================
            // INITIALIZATION
            // ============================================
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // ============================================
            // NEXUS DASHBOARD WELCOME MESSAGE
            // ============================================
            console.log('%c🚀 NEXUS Dashboard Ready!', 'color: #10e0e0; font-size: 16px; font-weight: bold;');
            console.log('%cWelcome to NEXUS Dashboard (React Edition)', 'color: #92a0b3; font-size: 12px;');
            console.log('%cStart coding here...', 'color: #92a0b3; font-size: 12px;');

            // Example: Integrated environment
            const NEXUS = {
                clock: {
                    bpm: 120,
                    phase: 0,
                    start() {
                        console.log('Clock started at ' + this.bpm + ' BPM');
                    }
                },
                audio: {
                    spectralCentroid: 440,
                    synthesize(freq) {
                        return `Synthesizing at ${freq}Hz`;
                    }
                },
                swarm: {
                    agents: 7,
                    analyze(code) {
                        return {
                            complexity: code.length / 1000,
                            patterns: (code.match(/function/g) || []).length
                        };
                    }
                }
            };

            // Test the system
            NEXUS.clock.start();
            console.log(NEXUS.audio.synthesize(440));
            const analysis = NEXUS.swarm.analyze('function example() {}');
            console.log('Code analysis:', analysis);

            // Make NEXUS available globally for user interaction
            window.NEXUS = NEXUS;
            console.log('%cNEXUS object available globally as window.NEXUS', 'color: #10e0e0; font-size: 11px;');

            showToast('🧬 Nexus Lab ready! Pull nodes for mountains or draw boundaries for regions.', 'success');
        }
    }

    // ============================================
    // EXTERNAL TOOL NAVIGATION
    // ============================================
    function setupExternalTools() {
        // Avatar Pipeline
        const btnAvatarPipeline = document.getElementById('btn-avatar-pipeline');
        if (btnAvatarPipeline) {
            btnAvatarPipeline.addEventListener('click', () => {
                window.open('Avatar-Pipeline.html', '_blank', 'noopener,noreferrer');
            });
        }

        // City Sandbox with Weather
        const btnCitySandbox = document.getElementById('btn-city-sandbox');
        if (btnCitySandbox) {
            btnCitySandbox.addEventListener('click', () => {
                window.open('City-Sandbox-Weather.html', '_blank', 'noopener,noreferrer');
            });
        }

        // Multi-Arm Vector IK Sandbox
        const btnVectorIK = document.getElementById('btn-vector-ik');
        if (btnVectorIK) {
            btnVectorIK.addEventListener('click', () => {
                window.open('Multi-Arm-Vector-IK Sandbox.html', '_blank', 'noopener,noreferrer');
            });
        }

        // Avatar Hub redirects to Avatar Pipeline
        const btnAvatarHub = document.getElementById('btn-avatar-hub');
        if (btnAvatarHub) {
            btnAvatarHub.addEventListener('click', () => {
                window.open('Avatar-Pipeline.html', '_blank', 'noopener,noreferrer');
            });
        }

        // Sandbox Store - Marketplace
        const btnSandboxStore = document.getElementById('btn-sandbox-store');
        if (btnSandboxStore) {
            btnSandboxStore.addEventListener('click', () => {
                window.open('Sandbox-Store.html', '_blank', 'noopener,noreferrer');
            });
        }

        // WebStore - Full Marketplace
        const btnWebStore = document.getElementById('btn-webstore');
        if (btnWebStore) {
            btnWebStore.addEventListener('click', () => {
                window.open('WebStore.html', '_blank', 'noopener,noreferrer');
            });
        }
        
        // Nexus Visualizer - Audio/Visual features from Nexus Lab
        const btnNexusVisualizer = document.getElementById('btn-nexus-visualizer');
        if (btnNexusVisualizer) {
            btnNexusVisualizer.addEventListener('click', () => {
                window.open('nexus-LAB-CORRECT.html', '_blank', 'noopener,noreferrer');
            });
        }
        
        // Unified Studio - 3D Creative Studio with nodes + timeline + recording
        const btnUnifiedStudio = document.getElementById('btn-unified-studio');
        if (btnUnifiedStudio) {
            btnUnifiedStudio.addEventListener('click', () => {
                window.open('Unified-3D-Creative-Studio.html', '_blank', 'noopener,noreferrer');
            });
        }

        // Game Builder - 3D Grid-based game builder (standalone)
        const btnGameBuilder = document.getElementById('btn-game-builder');
        if (btnGameBuilder) {
            btnGameBuilder.addEventListener('click', () => {
                window.open('game-builder-grid.html', '_blank', 'noopener,noreferrer');
            });
        }
    }

    // ============================================
    // GAME BUILDER - Extended Grid System (Standalone)
    // Note: Now opens in separate window via game-builder-grid.html
    // ============================================
    function initGameBuilder() {
        const modal = document.getElementById('game-builder-modal');
        const container = document.getElementById('game-builder-canvas');
        const closeBtn = document.getElementById('game-builder-close');
        const clearBtn = document.getElementById('game-builder-clear');
        const countDisplay = document.getElementById('game-builder-count');
        const prefabBtns = document.querySelectorAll('.gb-prefab-btn');

        modal.style.display = 'block';

        // Game Builder State
        const gbState = {
            scene: null,
            camera: null,
            renderer: null,
            previewMesh: null,
            placedMeshes: [],
            ground: null,
            selectedPrefab: 'cube',
            cameraControls: {
                isDragging: false,
                previousMousePosition: { x: 0, y: 0 },
                theta: Math.PI / 4,
                phi: Math.PI / 3,
                distance: 40,
                targetDistance: 40
            }
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog = new THREE.Fog(0x0a0a1a, 60, 150);
        gbState.scene = scene;

        // Camera
        const camera = new THREE.PerspectiveCamera(
            60,
            container.clientWidth / container.clientHeight,
            0.1,
            500
        );
        camera.position.set(30, 25, 30);
        camera.lookAt(0, 0, 0);
        gbState.camera = camera;

        // Renderer
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);
        gbState.renderer = renderer;

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(30, 50, 20);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 200;
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0x8080ff, 0x404040, 0.4);
        scene.add(hemisphereLight);

        // Extended Grid - 200x200 units
        const gridSize = 200;
        const gridDivisions = 100;
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x4a6fa5, 0x1a2a3a);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a2a3a,
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        gbState.ground = ground;

        // Prefab materials
        const materials = {
            cube: new THREE.MeshStandardMaterial({ color: 0xff4757, roughness: 0.4, metalness: 0.3 }),
            sphere: new THREE.MeshStandardMaterial({ color: 0x5352ed, roughness: 0.2, metalness: 0.7 }),
            cylinder: new THREE.MeshStandardMaterial({ color: 0x2ed573, roughness: 0.5, metalness: 0.2 }),
            cone: new THREE.MeshStandardMaterial({ color: 0xffa502, roughness: 0.4, metalness: 0.4 }),
            torus: new THREE.MeshStandardMaterial({ color: 0xa55eea, roughness: 0.3, metalness: 0.6 }),
            pyramid: new THREE.MeshStandardMaterial({ color: 0xfd79a8, roughness: 0.6, metalness: 0.2 })
        };

        // Create prefab geometry
        function createPrefabGeometry(type) {
            switch(type) {
                case 'cube': return new THREE.BoxGeometry(3, 3, 3);
                case 'sphere': return new THREE.SphereGeometry(1.8, 32, 32);
                case 'cylinder': return new THREE.CylinderGeometry(1.5, 1.5, 4, 32);
                case 'cone': return new THREE.ConeGeometry(1.8, 4, 32);
                case 'torus': return new THREE.TorusGeometry(1.5, 0.6, 24, 48);
                case 'pyramid': return new THREE.ConeGeometry(2, 4, 4);
                default: return new THREE.BoxGeometry(3, 3, 3);
            }
        }

        // Get object height offset
        function getObjectHeight(type) {
            switch(type) {
                case 'cube': return 1.5;
                case 'sphere': return 1.8;
                case 'cylinder': return 2;
                case 'cone': return 2;
                case 'torus': return 1.5;
                case 'pyramid': return 2;
                default: return 1.5;
            }
        }

        // Create preview mesh
        function createPreview(type) {
            if (gbState.previewMesh) {
                scene.remove(gbState.previewMesh);
                gbState.previewMesh.geometry.dispose();
                gbState.previewMesh.material.dispose();
            }
            
            const geometry = createPrefabGeometry(type);
            const material = materials[type].clone();
            material.transparent = true;
            material.opacity = 0.6;
            material.emissive = new THREE.Color(0x444444);
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = false;
            mesh.position.y = -100;
            scene.add(mesh);
            gbState.previewMesh = mesh;
        }

        createPreview(gbState.selectedPrefab);

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Mouse interaction
        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onClick(event) {
            if (gbState.cameraControls.isDragging) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(gbState.ground);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const snapSize = 2;
                const x = Math.round(point.x / snapSize) * snapSize;
                const z = Math.round(point.z / snapSize) * snapSize;
                const y = getObjectHeight(gbState.selectedPrefab);
                
                const geometry = createPrefabGeometry(gbState.selectedPrefab);
                const mesh = new THREE.Mesh(geometry, materials[gbState.selectedPrefab].clone());
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                
                gbState.placedMeshes.push(mesh);
                countDisplay.textContent = `Objects: ${gbState.placedMeshes.length}`;
                showToast(`Placed ${gbState.selectedPrefab} at (${x}, ${z})`, 'success');
            }
        }

        // Camera controls
        function onMouseDown(event) {
            if (event.button === 2) {
                event.preventDefault();
                gbState.cameraControls.isDragging = true;
                gbState.cameraControls.previousMousePosition = { 
                    x: event.clientX, 
                    y: event.clientY 
                };
            }
        }

        function onMouseMoveCamera(event) {
            const controls = gbState.cameraControls;
            
            if (controls.isDragging) {
                const deltaX = event.clientX - controls.previousMousePosition.x;
                const deltaY = event.clientY - controls.previousMousePosition.y;

                controls.theta -= deltaX * 0.008;
                controls.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, controls.phi - deltaY * 0.008));

                controls.previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                gbState.cameraControls.isDragging = false;
            }
        }

        function onWheel(event) {
            event.preventDefault();
            const controls = gbState.cameraControls;
            controls.targetDistance += event.deltaY * 0.03;
            controls.targetDistance = Math.max(15, Math.min(120, controls.targetDistance));
        }

        // Event listeners
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('click', onClick);
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMoveCamera);
        document.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

        // Prefab button handlers
        prefabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                gbState.selectedPrefab = btn.dataset.prefab;
                createPreview(gbState.selectedPrefab);
                
                // Update button styles
                prefabBtns.forEach(b => b.style.boxShadow = 'none');
                btn.style.boxShadow = '0 0 0 3px rgba(255,255,255,0.5)';
                
                showToast(`Selected: ${gbState.selectedPrefab}`, 'info');
            });
        });

        // Clear all button
        clearBtn.addEventListener('click', () => {
            gbState.placedMeshes.forEach(mesh => {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            });
            gbState.placedMeshes = [];
            countDisplay.textContent = 'Objects: 0';
            showToast('All objects cleared', 'info');
        });

        // Animation loop
        let animationFrameId;
        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            const controls = gbState.cameraControls;
            
            // Smooth zoom
            controls.distance += (controls.targetDistance - controls.distance) * 0.1;

            // Update camera position
            camera.position.x = controls.distance * Math.sin(controls.phi) * Math.cos(controls.theta);
            camera.position.y = controls.distance * Math.cos(controls.phi);
            camera.position.z = controls.distance * Math.sin(controls.phi) * Math.sin(controls.theta);
            camera.lookAt(0, 0, 0);

            // Update preview position
            if (gbState.previewMesh && !controls.isDragging) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(gbState.ground);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const snapSize = 2;
                    gbState.previewMesh.position.set(
                        Math.round(point.x / snapSize) * snapSize,
                        getObjectHeight(gbState.selectedPrefab),
                        Math.round(point.z / snapSize) * snapSize
                    );
                    gbState.previewMesh.visible = true;
                } else {
                    gbState.previewMesh.visible = false;
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        function handleResize() {
            if (!container || !camera || !renderer) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        window.addEventListener('resize', handleResize);

        // Close button
        closeBtn.addEventListener('click', () => {
            cancelAnimationFrame(animationFrameId);
            window.removeEventListener('resize', handleResize);
            renderer.domElement.removeEventListener('mousemove', onMouseMove);
            renderer.domElement.removeEventListener('click', onClick);
            renderer.domElement.removeEventListener('mousedown', onMouseDown);
            document.removeEventListener('mousemove', onMouseMoveCamera);
            document.removeEventListener('mouseup', onMouseUp);
            renderer.domElement.removeEventListener('wheel', onWheel);
            
            if (container && renderer.domElement) {
                container.removeChild(renderer.domElement);
            }
            
            renderer.dispose();
            modal.style.display = 'none';
            showToast('Game Builder closed', 'info');
        });

        showToast('Game Builder initialized - 200x200 grid ready!', 'success');
    }

    // ============================================
    // LOCAL STORAGE MANAGER
    // ============================================
    const StorageManager = {
        prefix: 'gamelite_',
        
        // Save any data with automatic JSON serialization
        save(key, data) {
            try {
                const serialized = JSON.stringify(data);
                localStorage.setItem(this.prefix + key, serialized);
                console.log(`💾 Saved: ${key} (${(serialized.length / 1024).toFixed(2)}KB)`);
                return true;
            } catch (e) {
                console.error('❌ Storage save failed:', e);
                if (e.name === 'QuotaExceededError') {
                    showToast('⚠️ Storage full! Clear some saved data.', 'warn');
                }
                return false;
            }
        },

        // Load data with automatic JSON deserialization
        load(key, defaultValue = null) {
            try {
                const item = localStorage.getItem(this.prefix + key);
                if (item === null) return defaultValue;
                return JSON.parse(item);
            } catch (e) {
                console.error('❌ Storage load failed:', e);
                return defaultValue;
            }
        },

        // Remove specific item
        remove(key) {
            localStorage.removeItem(this.prefix + key);
            console.log(`🗑️ Removed: ${key}`);
        },

        // Check if key exists
        has(key) {
            return localStorage.getItem(this.prefix + key) !== null;
        },

        // Get all GameLite keys
        getAllKeys() {
            const keys = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(this.prefix)) {
                    keys.push(key.substring(this.prefix.length));
                }
            }
            return keys;
        },

        // Get storage usage info
        getUsageInfo() {
            let totalSize = 0;
            const items = {};
            
            this.getAllKeys().forEach(key => {
                const data = localStorage.getItem(this.prefix + key);
                const size = data ? data.length : 0;
                totalSize += size;
                items[key] = {
                    size: size,
                    sizeKB: (size / 1024).toFixed(2),
                    sizeMB: (size / 1024 / 1024).toFixed(2)
                };
            });

            return {
                totalSize,
                totalKB: (totalSize / 1024).toFixed(2),
                totalMB: (totalSize / 1024 / 1024).toFixed(2),
                itemCount: Object.keys(items).length,
                items: items,
                percentUsed: ((totalSize / (5 * 1024 * 1024)) * 100).toFixed(2) // Assuming 5MB limit
            };
        },

        // Clear all GameLite storage
        clearAll() {
            const keys = this.getAllKeys();
            keys.forEach(key => this.remove(key));
            console.log(`🧹 Cleared ${keys.length} items from storage`);
            showToast(`Cleared ${keys.length} saved items`, 'success');
        },

        // Export all data as JSON file
        exportAll() {
            const data = {};
            this.getAllKeys().forEach(key => {
                data[key] = this.load(key);
            });
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gamelite_backup_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('📦 Exported storage data');
            showToast('Storage exported successfully!', 'success');
        },

        // Import data from JSON file
        async importFromFile(file) {
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                let imported = 0;
                for (const [key, value] of Object.entries(data)) {
                    if (this.save(key, value)) imported++;
                }
                
                console.log(`📥 Imported ${imported} items`);
                showToast(`Imported ${imported} items successfully!`, 'success');
                return imported;
            } catch (e) {
                console.error('❌ Import failed:', e);
                showToast('Import failed! Check file format.', 'error');
                return 0;
            }
        }
    };

    // Auto-save user preferences
    const Preferences = {
        defaults: {
            theme: 'dark',
            autoSave: true,
            gridVisible: true,
            rotationSpeed: 1,
            cameraSensitivity: 1,
            volumeLevel: 0.5,
            lastProject: null,
            recentFiles: [],
            favoriteTools: ['nexus-lab', 'terrain-builder']
        },

        load() {
            return StorageManager.load('preferences', this.defaults);
        },

        save(prefs) {
            return StorageManager.save('preferences', prefs);
        },

        get(key) {
            const prefs = this.load();
            return prefs[key] !== undefined ? prefs[key] : this.defaults[key];
        },

        set(key, value) {
            const prefs = this.load();
            prefs[key] = value;
            this.save(prefs);
            console.log(`⚙️ Preference updated: ${key} = ${value}`);
        },

        reset() {
            this.save(this.defaults);
            console.log('🔄 Preferences reset to defaults');
            showToast('Preferences reset!', 'success');
        }
    };

    // Project auto-save system
    const ProjectManager = {
        currentProject: null,

        saveProject(name, data) {
            const project = {
                name: name,
                data: data,
                timestamp: Date.now(),
                version: '1.0'
            };
            
            StorageManager.save(`project_${name}`, project);
            this.addToRecentProjects(name);
            showToast(`💾 Project "${name}" saved!`, 'success');
        },

        loadProject(name) {
            const project = StorageManager.load(`project_${name}`);
            if (project) {
                this.currentProject = name;
                console.log(`📂 Loaded project: ${name}`);
                return project.data;
            }
            return null;
        },

        deleteProject(name) {
            StorageManager.remove(`project_${name}`);
            this.removeFromRecentProjects(name);
            showToast(`🗑️ Project "${name}" deleted`, 'success');
        },

        listProjects() {
            return StorageManager.getAllKeys()
                .filter(key => key.startsWith('project_'))
                .map(key => {
                    const project = StorageManager.load(key);
                    return {
                        name: key.substring(8),
                        timestamp: project.timestamp,
                        date: new Date(project.timestamp).toLocaleString()
                    };
                })
                .sort((a, b) => b.timestamp - a.timestamp);
        },

        addToRecentProjects(name) {
            const prefs = Preferences.load();
            const recent = prefs.recentFiles || [];
            
            // Remove if already exists
            const index = recent.indexOf(name);
            if (index > -1) recent.splice(index, 1);
            
            // Add to front
            recent.unshift(name);
            
            // Keep only last 10
            if (recent.length > 10) recent.length = 10;
            
            prefs.recentFiles = recent;
            Preferences.save(prefs);
        },

        removeFromRecentProjects(name) {
            const prefs = Preferences.load();
            const recent = prefs.recentFiles || [];
            const index = recent.indexOf(name);
            if (index > -1) {
                recent.splice(index, 1);
                prefs.recentFiles = recent;
                Preferences.save(prefs);
            }
        },

        autoSave() {
            if (!Preferences.get('autoSave')) return;
            
            try {
                const sceneData = {
                    objects: (AppState.objects || [])
                        .filter(obj => obj && obj.position && obj.rotation && obj.scale)
                        .map(obj => ({
                            id: obj.id,
                            type: obj.type,
                            position: obj.position.toArray ? obj.position.toArray() : [0, 0, 0],
                            rotation: obj.rotation.toArray ? obj.rotation.toArray() : [0, 0, 0],
                            scale: obj.scale.toArray ? obj.scale.toArray() : [1, 1, 1]
                        })),
                    camera: AppState.camera ? {
                        position: AppState.camera.position?.toArray?.() || [0, 5, 10],
                        rotation: AppState.camera.rotation?.toArray?.() || [0, 0, 0]
                    } : {
                        position: [0, 5, 10],
                        rotation: [0, 0, 0]
                    }
                };
                
                this.saveProject('_autosave', sceneData);
            } catch (error) {
                console.error('[autoSave] Error saving project:', error);
            }
        }
    };

    // Initialize preferences on startup
    const userPrefs = Preferences.load();
    console.log('⚙️ Loaded preferences:', userPrefs);

    // Auto-save every 30 seconds
    setInterval(() => {
        ProjectManager.autoSave();
    }, 30000);

    // Show storage info in console
    console.log('💾 Storage Info:', StorageManager.getUsageInfo());

    // ============================================
    // STORAGE MANAGER UI
    // ============================================
    function setupStorageManagerUI() {
        const modal = document.getElementById('storageModal');
        const openBtn = document.getElementById('btn-storage-manager');
        const closeBtn = document.getElementById('storageClose');
        const exportBtn = document.getElementById('storage-export');
        const importBtn = document.getElementById('storage-import');
        const clearBtn = document.getElementById('storage-clear');

        function updateStorageUI() {
            const usage = StorageManager.getUsageInfo();
            
            // Update stats
            document.getElementById('storage-total').textContent = `${usage.totalKB} KB`;
            document.getElementById('storage-count').textContent = usage.itemCount;
            document.getElementById('storage-percent').textContent = `${usage.percentUsed}%`;
            document.getElementById('storage-bar').style.width = `${usage.percentUsed}%`;

            // Color code the percentage
            const percentEl = document.getElementById('storage-percent');
            if (usage.percentUsed > 80) {
                percentEl.style.color = 'var(--bad)';
            } else if (usage.percentUsed > 50) {
                percentEl.style.color = 'var(--gold)';
            } else {
                percentEl.style.color = 'var(--good)';
            }

            // Update items list
            const itemsList = document.getElementById('storage-items');
            const keys = StorageManager.getAllKeys().filter(k => !k.startsWith('project_'));
            
            if (keys.length === 0) {
                itemsList.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 2rem;">No saved items yet</div>';
            } else {
                itemsList.innerHTML = keys.map(key => {
                    const info = usage.items[key];
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 6px; margin-bottom: 0.5rem;">
                            <div>
                                <div style="font-weight: bold;">${key}</div>
                                <div style="font-size: 0.75rem; color: var(--muted);">${info.sizeKB} KB</div>
                            </div>
                            <button onclick="StorageManager.remove('${key}'); setupStorageManagerUI.update();" style="padding: 0.25rem 0.75rem; background: var(--bad); color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>
                        </div>
                    `;
                }).join('');
            }

            // Update projects list
            const projectsList = document.getElementById('storage-projects');
            const projects = ProjectManager.listProjects();
            
            if (projects.length === 0) {
                projectsList.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 2rem;">No saved projects yet</div>';
            } else {
                projectsList.innerHTML = projects.map(proj => `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 6px; margin-bottom: 0.5rem;">
                        <div>
                            <div style="font-weight: bold;">${proj.name}</div>
                            <div style="font-size: 0.75rem; color: var(--muted);">${proj.date}</div>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button onclick="ProjectManager.loadProject('${proj.name}'); showToast('Loaded: ${proj.name}', 'success');" style="padding: 0.25rem 0.75rem; background: var(--mana); color: white; border: none; border-radius: 4px; cursor: pointer;">Load</button>
                            <button onclick="if(confirm('Delete ${proj.name}?')) { ProjectManager.deleteProject('${proj.name}'); setupStorageManagerUI.update(); }" style="padding: 0.25rem 0.75rem; background: var(--bad); color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>
                        </div>
                    </div>
                `).join('');
            }
        }

        // Export the update function so buttons can call it
        setupStorageManagerUI.update = updateStorageUI;

        // Open modal
        openBtn?.addEventListener('click', () => {
            modal.style.display = 'block';
            updateStorageUI();
        });

        // Close modal
        closeBtn?.addEventListener('click', () => {
            modal.style.display = 'none';
        });

        // Export data
        exportBtn?.addEventListener('click', () => {
            StorageManager.exportAll();
        });

        // Import data
        importBtn?.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await StorageManager.importFromFile(file);
                    updateStorageUI();
                }
            };
            input.click();
        });

        // Clear all data
        clearBtn?.addEventListener('click', () => {
            if (confirm('⚠️ Are you sure you want to clear ALL saved data? This cannot be undone!')) {
                StorageManager.clearAll();
                updateStorageUI();
            }
        });

        // Keyboard shortcut: Ctrl+S to open storage manager
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                openBtn.click();
            }
        });
    }

    // ============================================
    // START APPLICATION
    // ============================================
    init();
    setupRotationControls();
    setupTerrainBuilder();
    setupNexusLab();
    setupExternalTools();
    setupStorageManagerUI();
</script>
</body>
</html>


