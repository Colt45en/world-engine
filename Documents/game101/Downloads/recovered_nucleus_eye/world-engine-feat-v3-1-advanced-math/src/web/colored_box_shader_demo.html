<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colored Box Shader Demo - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            max-width: 300px;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
        }

        button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 12px;
            margin: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }

        button:hover {
            background: #555;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="info">
        <h3>üé® Colored Box Shader Demo</h3>
        <div><strong>Box Types:</strong></div>
        <div>üî¥ Solid Color</div>
        <div>üü¢ Gradient Effect</div>
        <div>üü£ Animated Colors</div>
        <div>üü° Noise Pattern</div>
        <div>üîµ Custom Pattern</div>
        <br>
        <div><em>Click anywhere to randomize colors!</em></div>
    </div>

    <div id="controls">
        <h4>Controls</h4>
        <button onclick="randomizeColors()">üé≤ Random Colors</button>
        <button onclick="changePattern()">üîÑ Change Pattern</button>
        <button onclick="toggleAnimation()">‚èØÔ∏è Toggle Animation</button>
        <button onclick="resetView()">üîÑ Reset View</button>
    </div>

    <div id="canvas-container"></div>

    <script>
        // Shader definitions
        const vertexShader = `
            attribute vec3 position;
            attribute vec2 uv;
            attribute vec3 normal;

            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat3 normalMatrix;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;

            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);

                vec4 worldPosition = modelViewMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;

                gl_Position = projectionMatrix * worldPosition;
            }
        `;

        const fragmentShader = `
            precision highp float;

            uniform vec3 boxColor;
            uniform float time;
            uniform float intensity;
            uniform bool gradient;
            uniform vec3 gradientColor;
            uniform bool animate;
            uniform float pattern;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                vec3 finalColor = boxColor;

                if (pattern < 0.5) {
                    // Solid color
                    finalColor = boxColor;

                } else if (pattern < 1.5) {
                    // Gradient pattern
                    if (gradient) {
                        float gradientFactor = vUv.y;
                        finalColor = mix(boxColor, gradientColor, gradientFactor);
                    }

                } else if (pattern < 2.5) {
                    // Animated color pattern
                    if (animate) {
                        float animationFactor = sin(time * 2.0 + vUv.x * 10.0) * 0.5 + 0.5;
                        vec3 animatedColor = hsv2rgb(vec3(
                            fract(time * 0.1 + vUv.x * 0.5),
                            0.7,
                            0.8
                        ));
                        finalColor = mix(boxColor, animatedColor, animationFactor);
                    }

                } else {
                    // Procedural noise pattern
                    float noiseValue = noise(vUv * 10.0 + time);
                    finalColor = mix(boxColor, gradientColor, noiseValue);
                }

                // Simple lighting
                vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0));
                float lightIntensity = max(dot(vNormal, lightDirection), 0.3);
                finalColor *= lightIntensity;

                finalColor *= intensity;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // Scene setup
        let scene, camera, renderer, boxes = [];
        let animationEnabled = true;
        const clock = new THREE.Clock();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create boxes with different patterns
            createBoxes();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', randomizeColors);

            // Start animation
            animate();
        }

        function createBoxes() {
            const boxConfigs = [
                // Solid red box
                {
                    position: [-3, 1, 0],
                    color: new THREE.Color(0xff0000),
                    pattern: 0,
                    gradient: false,
                    animate: false
                },
                // Gradient box
                {
                    position: [-1, 1, 0],
                    color: new THREE.Color(0x00ff00),
                    gradientColor: new THREE.Color(0x0000ff),
                    pattern: 1,
                    gradient: true,
                    animate: false
                },
                // Animated box
                {
                    position: [1, 1, 0],
                    color: new THREE.Color(0xff00ff),
                    pattern: 2,
                    gradient: false,
                    animate: true
                },
                // Noise pattern box
                {
                    position: [3, 1, 0],
                    color: new THREE.Color(0xffff00),
                    gradientColor: new THREE.Color(0xff0000),
                    pattern: 3,
                    gradient: false,
                    animate: false
                },
                // Custom pattern box
                {
                    position: [0, -1, 0],
                    color: new THREE.Color(0x00ffff),
                    gradientColor: new THREE.Color(0xff8800),
                    pattern: 1.5,
                    gradient: true,
                    animate: true
                }
            ];

            boxConfigs.forEach(config => {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        boxColor: { value: config.color },
                        gradientColor: { value: config.gradientColor || new THREE.Color(0x000000) },
                        time: { value: 0 },
                        intensity: { value: 1.0 },
                        gradient: { value: config.gradient },
                        animate: { value: config.animate },
                        pattern: { value: config.pattern }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(...config.position);
                scene.add(mesh);
                boxes.push({ mesh, material, config });
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            boxes.forEach(({ mesh, material }) => {
                // Update time uniform
                material.uniforms.time.value += deltaTime;

                // Rotate boxes
                if (animationEnabled) {
                    mesh.rotation.x += deltaTime * 0.5;
                    mesh.rotation.y += deltaTime * 0.3;
                }
            });

            renderer.render(scene, camera);
        }

        function randomizeColors() {
            boxes.forEach(({ material }) => {
                const randomColor = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
                material.uniforms.boxColor.value.copy(randomColor);

                if (material.uniforms.gradientColor) {
                    const randomGradient = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
                    material.uniforms.gradientColor.value.copy(randomGradient);
                }
            });
        }

        function changePattern() {
            boxes.forEach(({ material }) => {
                const newPattern = Math.floor(Math.random() * 4);
                material.uniforms.pattern.value = newPattern;

                // Enable appropriate settings for the pattern
                material.uniforms.gradient.value = newPattern === 1 || newPattern === 3;
                material.uniforms.animate.value = newPattern === 2;
            });
        }

        function toggleAnimation() {
            animationEnabled = !animationEnabled;
        }

        function resetView() {
            camera.position.set(0, 0, 5);
            camera.rotation.set(0, 0, 0);

            boxes.forEach(({ mesh, config }) => {
                mesh.position.set(...config.position);
                mesh.rotation.set(0, 0, 0);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize the demo
        init();
    </script>
</body>
</html>
